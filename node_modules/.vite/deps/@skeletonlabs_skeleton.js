import {
  writable
} from "./chunk-XJH56O4N.js";
import {
  fade,
  fly,
  slide
} from "./chunk-XFU24KLV.js";
import "./chunk-ACBGUER4.js";
import "./chunk-GECN4ROB.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  action_destroyer,
  add_location,
  add_render_callback,
  afterUpdate,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  setContext,
  set_attributes,
  set_custom_element_data_map,
  set_data_dev,
  set_input_value,
  set_store_value,
  set_style,
  space,
  src_url_equal,
  subscribe,
  svg_element,
  text,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_each_argument,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-3LMUIDXO.js";

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/CodeBlock/stores.js
var storeHighlightJs = writable(void 0);

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/Drawer/stores.js
function drawerService() {
  const { subscribe: subscribe2, set, update } = writable({});
  return {
    subscribe: subscribe2,
    set,
    update,
    open: (newSettings) => update(() => {
      return { open: true, ...newSettings };
    }),
    close: () => update((d) => {
      d.open = false;
      return d;
    })
  };
}
var drawerStore = drawerService();

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/Modal/stores.js
function modalService() {
  const { subscribe: subscribe2, set, update } = writable([]);
  return {
    subscribe: subscribe2,
    set,
    update,
    trigger: (modal) => update((mStore) => {
      mStore.push(modal);
      return mStore;
    }),
    close: () => update((mStore) => {
      if (mStore.length > 0)
        mStore.shift();
      return mStore;
    }),
    clear: () => set([])
  };
}
var modalStore = modalService();

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/Toast/stores.js
var toastDefaults = { message: "Missing Toast Message", autohide: true, timeout: 5e3 };
function randomUUID() {
  const random = Math.random();
  return Number(random).toString(32);
}
function handleAutoHide(toast) {
  if (toast.autohide === true) {
    setTimeout(() => {
      toastStore.close(toast.id);
    }, toast.timeout);
  }
}
function toastService() {
  const { subscribe: subscribe2, set, update } = writable([]);
  return {
    subscribe: subscribe2,
    trigger: (toast) => update((tStore) => {
      const id = randomUUID();
      const tMerged = { ...toastDefaults, ...toast, id };
      tStore.push(tMerged);
      handleAutoHide(tMerged);
      return tStore;
    }),
    close: (id) => update((tStore) => {
      if (tStore.length > 0) {
        const index = tStore.findIndex((t) => t.id === id);
        tStore.splice(index, 1);
      }
      return tStore;
    }),
    clear: () => set([])
  };
}
var toastStore = toastService();

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/LocalStorageStore/LocalStorageStore.js
var stores = {};
function localStorageStore(key, initialValue, options) {
  const browser = typeof localStorage != "undefined" && typeof window != "undefined";
  const serializer = (options == null ? void 0 : options.serializer) || JSON;
  function updateStorage(key2, value) {
    if (!browser)
      return;
    localStorage.setItem(key2, serializer.stringify(value));
  }
  if (!stores[key]) {
    const store = writable(initialValue, (set2) => {
      const json = browser ? localStorage.getItem(key) : null;
      if (json) {
        set2(serializer.parse(json));
      }
      if (browser) {
        const handleStorage = (event) => {
          if (event.key === key)
            set2(event.newValue ? serializer.parse(event.newValue) : null);
        };
        window.addEventListener("storage", handleStorage);
        return () => window.removeEventListener("storage", handleStorage);
      }
    });
    const { subscribe: subscribe2, set } = store;
    stores[key] = {
      set(value) {
        updateStorage(key, value);
        set(value);
      },
      update(updater) {
        const value = updater(get_store_value(store));
        updateStorage(key, value);
        set(value);
      },
      subscribe: subscribe2
    };
  }
  return stores[key];
}

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/LightSwitch/stores.js
var storePrefersDarkScheme = localStorageStore("storePrefersDarkScheme", false);
var storeLightSwitch = localStorageStore("storeLightSwitch", void 0);

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/DataTable/actions.js
function tableInteraction(node) {
  const classAsc = "table-sort-asc";
  const classDsc = "table-sort-dsc";
  const onClick = (e) => {
    if (!(e.target instanceof Element))
      return;
    const sortTarget = e.target;
    const targetAscSorted = sortTarget.classList.contains(classAsc);
    const sortTargetKey = sortTarget.getAttribute("data-sort");
    const elemAsc = node.querySelector(`.${classAsc}`);
    if (elemAsc)
      elemAsc.classList.remove(classAsc);
    const elemDsc = node.querySelector(`.${classDsc}`);
    if (elemDsc)
      elemDsc.classList.remove(classDsc);
    if (sortTargetKey) {
      const classToApply = targetAscSorted ? classDsc : classAsc;
      e.target.classList.add(classToApply);
    }
  };
  node.addEventListener("click", onClick);
  return {
    destroy() {
      node.removeEventListener("click", onClick);
    }
  };
}
function tableA11y(node) {
  const keyWhitelist = ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown", "Home", "End"];
  const onKeyDown3 = (event) => {
    if (keyWhitelist.includes(event.code)) {
      event.preventDefault();
      switch (event.code) {
        case "ArrowUp":
          a11ySetActiveCell(node, 0, -1);
          break;
        case "ArrowDown":
          a11ySetActiveCell(node, 0, 1);
          break;
        case "ArrowLeft":
          a11ySetActiveCell(node, -1, 0);
          break;
        case "ArrowRight":
          a11ySetActiveCell(node, 1, 0);
          break;
        case "Home":
          a11yJumpToOuterColumn(node, "first");
          break;
        case "End":
          a11yJumpToOuterColumn(node, "last");
          break;
        default:
          break;
      }
    }
  };
  node.addEventListener("keydown", onKeyDown3);
  return {
    destroy() {
      node.removeEventListener("keydown", onKeyDown3);
    }
  };
}
function a11ySetActiveCell(node, x, y) {
  const focusedElem = document.activeElement;
  if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex || !focusedElem.ariaColIndex)
    return;
  const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
  const focusedElemColIndex = parseInt(focusedElem.ariaColIndex);
  const targetRowElement = node.querySelector(`[aria-rowindex="${focusedElemRowIndex + y}"]`);
  if (targetRowElement !== null) {
    const targetColElement = targetRowElement.querySelector(`[aria-colindex="${focusedElemColIndex + x}"]`);
    if (targetColElement !== null)
      targetColElement.focus();
  }
}
function a11yGetTargetElem(node) {
  const focusedElem = document.activeElement;
  if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex)
    return null;
  const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
  return node.querySelector(`[aria-rowindex="${focusedElemRowIndex}"]`);
}
function a11yJumpToOuterColumn(node, type = "first") {
  const targetRowElement = a11yGetTargetElem(node);
  if (targetRowElement === null)
    return;
  const lastIndex = targetRowElement.children.length;
  const selected = type === "first" ? 1 : lastIndex;
  const targetColElement = targetRowElement.querySelector(`[aria-colindex="${selected}"]`);
  if (targetColElement === null)
    return;
  targetColElement.focus();
}

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/DataTable/DataTable.js
function createDataTableStore(source, options = {}) {
  const modifiedList = source.map((rowObj) => ({ ...rowObj, dataTableChecked: false }));
  const { subscribe: subscribe2, set, update } = writable({
    source,
    base: modifiedList,
    filtered: modifiedList,
    sortState: { lastKey: "", asc: true },
    selection: [],
    search: options.search ?? "",
    sort: options.sort ?? "",
    pagination: options.pagination
  });
  return {
    subscribe: subscribe2,
    set,
    updateSource: (data) => update((model) => {
      model.source = data;
      model.base = data.map((row, i) => {
        var _a;
        return { ...row, dataTableChecked: ((_a = model.base[i]) == null ? void 0 : _a.dataTableChecked) ?? false };
      });
      return { ...model, filtered: model.base };
    }),
    selectAll: (checked) => {
      update((model) => {
        model.base.forEach((row) => {
          row.dataTableChecked = checked;
          return row;
        });
        return model;
      });
    },
    select: (key, valuesArr) => {
      update((model) => {
        model.filtered.map((row) => {
          if (valuesArr.includes(row[key]))
            row.dataTableChecked = true;
          return row;
        });
        return model;
      });
    },
    sort: (event) => {
      update((model) => {
        if (!(event.target instanceof Element))
          return model;
        const newSortKey = event.target.getAttribute("data-sort");
        if (newSortKey !== "" && newSortKey === model.sortState.lastKey)
          model.sortState.asc = !model.sortState.asc;
        model.sortState.lastKey = newSortKey;
        model.sort = newSortKey ?? "";
        return model;
      });
    }
  };
}
function dataTableHandler(model) {
  searchHandler(model);
  selectionHandler(model);
  sortHandler(model);
  paginationHandler(model);
}
function searchHandler(store) {
  store.filtered = store.base.filter((rowObj) => {
    var _a;
    const formattedSearchTerm = ((_a = store.search) == null ? void 0 : _a.toLowerCase()) || "";
    return Object.values(rowObj).join(" ").toLowerCase().includes(formattedSearchTerm);
  });
}
function selectionHandler(store) {
  store.selection = store.base.filter((row) => row.dataTableChecked === true);
}
function sortHandler(store) {
  if (!store.sort)
    return;
  store.sortState.asc ? sortOrder("asc", store) : sortOrder("dsc", store);
}
function sortOrder(order, store) {
  const key = store.sort;
  store.filtered = store.base.sort((x, y) => {
    if (order === "dsc")
      [x, y] = [y, x];
    if (typeof x[key] === "string" && typeof y[key] === "string") {
      return String(x[key]).localeCompare(String(y[key]));
    } else {
      return x[key] - y[key];
    }
  });
}
function paginationHandler(store) {
  if (store.pagination) {
    const filtered = store.base.slice(
      store.pagination.offset * store.pagination.limit,
      store.pagination.offset * store.pagination.limit + store.pagination.limit
    );
    if (store.search !== "") {
      store.filtered = store.filtered.slice(0, store.pagination.limit);
      store.pagination.size = store.filtered.length;
      store.pagination.offset = 0;
    } else {
      store.filtered = filtered;
      store.pagination.size = store.base.length;
    }
  }
}

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Table/utils.js
function tableSourceMapper(source, keys) {
  return source.map((row) => {
    const mappedRow = {};
    keys.forEach((key) => mappedRow[key] = row[key]);
    return mappedRow;
  });
}
function tableSourceValues(source) {
  return source.map((row) => Object.values(row));
}
function tableMapperValues(source, keys) {
  return tableSourceValues(tableSourceMapper(source, keys));
}

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Clipboard/clipboard.js
function clipboard(node, args) {
  const onClick = () => {
    if (typeof args === "object") {
      if (Object.prototype.hasOwnProperty.call(args, "element")) {
        const element2 = document.querySelector(`[data-clipboard="${args.element}"]`);
        copyToClipboard(element2 == null ? void 0 : element2.innerHTML);
        return;
      }
      if (Object.prototype.hasOwnProperty.call(args, "input")) {
        const input = document.querySelector(`[data-clipboard="${args.input}"]`);
        copyToClipboard(input == null ? void 0 : input.value);
        return;
      }
    }
    copyToClipboard(args);
  };
  node.addEventListener("click", onClick);
  return {
    update(newArgs) {
      args = newArgs;
    },
    destroy() {
      node.removeEventListener("click", onClick);
    }
  };
}
function copyToClipboard(data) {
  navigator.clipboard.writeText(String(data));
}

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/filter.js
function filter(node, filterName) {
  if (filterName === void 0)
    return;
  const applyFilter = () => {
    const isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
    if (isFirefox) {
      return;
    }
    node.setAttribute("style", `filter: url("#${filterName}")`);
  };
  applyFilter();
  return {
    update(newArgs) {
      filterName = newArgs;
      applyFilter();
    }
  };
}

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/FocusTrap/focusTrap.js
function focusTrap(node, enabled) {
  const elemWhitelist = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
  let elemFirst;
  let elemLast;
  function onFirstElemKeydown(e) {
    if (e.shiftKey && e.code === "Tab") {
      e.preventDefault();
      elemLast.focus();
    }
  }
  function onLastElemKeydown(e) {
    if (!e.shiftKey && e.code === "Tab") {
      e.preventDefault();
      elemFirst.focus();
    }
  }
  const onInit = () => {
    if (enabled === false)
      return;
    const focusableElems = Array.from(node.querySelectorAll(elemWhitelist));
    if (focusableElems.length) {
      elemFirst = focusableElems[0];
      elemLast = focusableElems[focusableElems.length - 1];
      elemFirst.focus();
      elemFirst.addEventListener("keydown", onFirstElemKeydown);
      elemLast.addEventListener("keydown", onLastElemKeydown);
    }
  };
  onInit();
  function onDestory() {
    if (elemFirst)
      elemFirst.removeEventListener("keydown", onFirstElemKeydown);
    if (elemLast)
      elemLast.removeEventListener("keydown", onLastElemKeydown);
  }
  return {
    update(newArgs) {
      enabled = newArgs;
      newArgs ? onInit() : onDestory();
    },
    destroy() {
      onDestory();
    }
  };
}

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/Menu/menu.js
function menu(node, args) {
  const elemMenu = document.querySelector(`[data-menu="${args.menu}"]`);
  if (!elemMenu)
    return;
  const elemWhitelist = 'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
  let activeFocusIdx;
  let focusableElems;
  const onInit = () => {
    autoUpdateOrigin();
    elemMenu.setAttribute("role", "menu");
  };
  const menuOpen = (openWithFocus = false) => {
    var _a;
    elemMenu.style.display = "block";
    stateEventHandler(true);
    focusableElems = Array.from(elemMenu.querySelectorAll(elemWhitelist));
    activeFocusIdx = -1;
    if (openWithFocus) {
      activeFocusIdx = 0;
      (_a = focusableElems[0]) == null ? void 0 : _a.focus();
    }
  };
  const menuClose = () => {
    elemMenu.style.display = "none";
    stateEventHandler(false);
  };
  const stateEventHandler = (state) => {
    if (args.state)
      args.state({ menu: args.menu, state });
  };
  const onTriggerClick = () => {
    if (elemMenu.style.display === "none") {
      autoUpdateOrigin();
      menuOpen();
    } else {
      menuClose();
    }
  };
  const onWindowClick = (event) => {
    args.interactive === true ? interactiveClickHandler(event) : standardClickHandler(event);
  };
  const standardClickHandler = (event) => {
    const outsideNode = node && !node.contains(event.target);
    if (outsideNode) {
      menuClose();
    }
  };
  const interactiveClickHandler = (event) => {
    const outsideNode = node && !node.contains(event.target);
    const outsideMenu = elemMenu && !elemMenu.contains(event.target);
    if (outsideNode && outsideMenu) {
      menuClose();
    }
  };
  const autoUpdateOrigin = () => {
    if (!args.fixed && !elemMenu.classList.contains("hidden")) {
      const elemTriggerBounds = node.getBoundingClientRect();
      const vert = elemTriggerBounds.y < window.innerHeight / 2 ? "t" : "b";
      const horz = elemTriggerBounds.x < window.innerWidth / 2 ? "l" : "r";
      elemMenu.classList.remove("menu-tl", "menu-tr", "menu-bl", "menu-br");
      elemMenu.classList.add(`menu-${vert}${horz}`);
    }
  };
  const onTriggerKeyDown = (event) => {
    const key = event.key;
    if (key === "Enter" || key === "Space") {
      event.preventDefault();
      onTriggerClick();
    }
  };
  const onWindowKeyDown = (event) => {
    var _a, _b, _c;
    const key = event.key;
    if (elemMenu.style.display === "none")
      return;
    if (key === "Escape" || key === "Tab") {
      event.preventDefault();
      menuClose();
      node.focus();
    } else if (key === "ArrowDown") {
      event.preventDefault();
      if (activeFocusIdx < focusableElems.length - 1) {
        activeFocusIdx += 1;
        (_a = focusableElems[activeFocusIdx]) == null ? void 0 : _a.focus();
      }
    } else if (key === "ArrowUp") {
      event.preventDefault();
      if (activeFocusIdx > 0) {
        activeFocusIdx -= 1;
        (_b = focusableElems[activeFocusIdx]) == null ? void 0 : _b.focus();
      } else if (focusableElems.length && activeFocusIdx === -1) {
        event.preventDefault();
        activeFocusIdx = focusableElems.length - 1;
        (_c = focusableElems[activeFocusIdx]) == null ? void 0 : _c.focus();
      }
    }
  };
  onInit();
  window.addEventListener("resize", autoUpdateOrigin, true);
  window.addEventListener("click", onWindowClick, true);
  window.addEventListener("keydown", onWindowKeyDown, true);
  node.addEventListener("click", onTriggerClick);
  node.addEventListener("keydown", onTriggerKeyDown);
  node.addEventListener("change", (e) => {
    console.log(e);
  });
  return {
    update: (newArgs) => {
      args = newArgs;
    },
    destroy: () => {
      window.removeEventListener("resize", onWindowClick, true);
      window.removeEventListener("click", onWindowClick, true);
      window.removeEventListener("keydown", onWindowKeyDown, true);
      node.removeEventListener("click", onTriggerClick);
      node.removeEventListener("keydown", onTriggerKeyDown);
    }
  };
}

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/Tooltip/tooltip.js
function tooltip(node, args) {
  const animDuration = 150;
  let elemTooltip;
  const {
    content = "(tooltip)",
    position = "top",
    inline = true,
    regionContainer = "regionContainer",
    regionTooltip = "regionTooltip",
    regionArrow = "regionArrow"
  } = args;
  const createElemContainer = () => {
    var _a;
    const elemContainer = document.createElement(inline ? "span" : "div");
    elemContainer.classList.add("tooltip-container", "relative", regionContainer);
    (_a = node.parentNode) == null ? void 0 : _a.insertBefore(elemContainer, node);
    elemContainer.appendChild(node);
  };
  createElemContainer();
  const createElemTooltip = () => {
    var _a;
    elemTooltip = document.createElement("div");
    elemTooltip.classList.add("tooltip", `tooltip-${position}`, "hidden", regionTooltip);
    if (args.background) {
      elemTooltip.classList.add(args.background);
    }
    if (args.color)
      elemTooltip.classList.add(args.color);
    if (args.width)
      elemTooltip.classList.add(args.width);
    if (args.padding)
      elemTooltip.classList.add(args.padding);
    if (args.shadow)
      elemTooltip.classList.add(args.shadow);
    if (args.rounded)
      elemTooltip.classList.add(args.rounded);
    elemTooltip.setAttribute("role", "tooltip");
    elemTooltip.setAttribute("data-testid", "tooltip");
    elemTooltip.innerHTML = content;
    (_a = node.parentNode) == null ? void 0 : _a.insertBefore(elemTooltip, node);
  };
  createElemTooltip();
  const createElemArrow = () => {
    const elemArrow = document.createElement("div");
    elemArrow.classList.add(`tooltip-arrow-${position}`, regionArrow);
    if (args.background)
      elemArrow.classList.add(args.background);
    elemTooltip.append(elemArrow);
  };
  createElemArrow();
  const onMouseEnter = () => {
    elemTooltip.classList.remove("hidden");
    setTimeout(() => {
      elemTooltip.classList.add("!opacity-100");
    }, animDuration);
    stateEventHandler(true);
  };
  const onMouseLeave = () => {
    elemTooltip.classList.remove("!opacity-100");
    setTimeout(() => {
      elemTooltip.classList.add("hidden");
    }, animDuration);
    stateEventHandler(false);
  };
  const stateEventHandler = (state) => {
    if (args.state)
      args.state({ trigger: node, state });
  };
  const onWindowKeyDown = (event) => {
    if (event.code === "Escape")
      onMouseLeave();
  };
  node.addEventListener("mouseenter", onMouseEnter);
  node.addEventListener("mouseleave", onMouseLeave);
  window.addEventListener("keydown", onWindowKeyDown);
  return {
    update(newArgs) {
      args = newArgs;
    },
    destroy() {
      node.removeEventListener("mouseenter", onMouseEnter);
      node.removeEventListener("mouseleave", onMouseLeave);
      window.removeEventListener("keydown", onWindowKeyDown);
    }
  };
}

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Accordion/AccordionGroup.svelte
var file = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Accordion\\AccordionGroup.svelte";
function create_fragment(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "accordion-group " + ctx[1]);
      attr_dev(div, "data-testid", "accordion-group");
      add_location(div, file, 44, 0, 1451);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[9](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && div_class_value !== (div_class_value = "accordion-group " + ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase = "rounded-container-token";
function instance($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionGroup", slots, ["default"]);
  let { collapse = true } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { padding = "px-4 py-2" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  setContext("hover", hover);
  setContext("spacing", spacing);
  setContext("padding", padding);
  setContext("rounded", rounded);
  let elemAccordian;
  onMount(() => {
    if (collapse) {
      const details = Array.from(elemAccordian.querySelectorAll("details"));
      details.forEach((detail) => {
        detail.addEventListener("click", (e) => {
          const active = details.find((d) => d.open);
          if (!e.currentTarget.open && active) {
            active.open = false;
          }
        });
      });
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemAccordian = $$value;
      $$invalidate(0, elemAccordian);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("collapse" in $$new_props)
      $$invalidate(2, collapse = $$new_props.collapse);
    if ("hover" in $$new_props)
      $$invalidate(3, hover = $$new_props.hover);
    if ("spacing" in $$new_props)
      $$invalidate(4, spacing = $$new_props.spacing);
    if ("padding" in $$new_props)
      $$invalidate(5, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(6, rounded = $$new_props.rounded);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    setContext,
    collapse,
    hover,
    spacing,
    padding,
    rounded,
    cBase,
    elemAccordian,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    if ("collapse" in $$props)
      $$invalidate(2, collapse = $$new_props.collapse);
    if ("hover" in $$props)
      $$invalidate(3, hover = $$new_props.hover);
    if ("spacing" in $$props)
      $$invalidate(4, spacing = $$new_props.spacing);
    if ("padding" in $$props)
      $$invalidate(5, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(6, rounded = $$new_props.rounded);
    if ("elemAccordian" in $$props)
      $$invalidate(0, elemAccordian = $$new_props.elemAccordian);
    if ("classesBase" in $$props)
      $$invalidate(1, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classesBase = `${cBase} ${spacing} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    elemAccordian,
    classesBase,
    collapse,
    hover,
    spacing,
    padding,
    rounded,
    $$scope,
    slots,
    div_binding
  ];
}
var AccordionGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      collapse: 2,
      hover: 3,
      spacing: 4,
      padding: 5,
      rounded: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionGroup",
      options,
      id: create_fragment.name
    });
  }
  get collapse() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapse(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<AccordionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<AccordionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionGroup_default = AccordionGroup;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/SvgIcon/icons.js
var icons = {
  image: {
    path: "M447.1 32h-384C28.64 32-.0091 60.65-.0091 96v320c0 35.35 28.65 64 63.1 64h384c35.35 0 64-28.65 64-64V96C511.1 60.65 483.3 32 447.1 32zM111.1 96c26.51 0 48 21.49 48 48S138.5 192 111.1 192s-48-21.49-48-48S85.48 96 111.1 96zM446.1 407.6C443.3 412.8 437.9 416 432 416H82.01c-6.021 0-11.53-3.379-14.26-8.75c-2.73-5.367-2.215-11.81 1.334-16.68l70-96C142.1 290.4 146.9 288 152 288s9.916 2.441 12.93 6.574l32.46 44.51l93.3-139.1C293.7 194.7 298.7 192 304 192s10.35 2.672 13.31 7.125l128 192C448.6 396 448.9 402.3 446.1 407.6z"
  },
  github: {
    path: "M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"
  },
  discord: {
    viewBox: "0 0 640 512",
    path: "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"
  },
  twitter: {
    path: "M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"
  },
  svelte: {
    viewBox: `0 0 513.978 597.129`,
    path: "M179.547 545.729c-63.418-10.114-114.409-57.647-126.738-118.147-6.814-33.436-1.056-69.7 15.357-96.718l3.628-5.972-4.271-9.908c-24.281-56.32-9.106-121.877 36.892-159.376 10.666-8.695 132.771-86.226 145.148-92.162 21.395-10.261 41.161-14.203 66.834-13.328 18.527.631 27.235 2.147 43.648 7.597 51.619 17.139 90.63 60.248 101.124 111.747 6.814 33.436 1.056 69.7-15.357 96.719l-3.628 5.972 4.272 9.907c24.28 56.32 9.105 121.877-36.893 159.376-10.665 8.696-132.77 86.227-145.148 92.163-12.055 5.781-25.266 9.867-39.22 12.13-11.505 1.867-33.943 1.866-45.648 0zm40.107-56.452c8.462-1.864 18.23-5.676 24.437-9.538 35.719-22.223 123.574-78.887 127.592-82.293 12.127-10.28 21.731-25.243 26.045-40.577 3.4-12.09 3.396-31.504-.01-43.495-13.838-48.709-63.665-77.61-112.356-65.171-10.868 2.776-18.714 6.93-45.78 24.232-13.075 8.359-25.352 15.857-27.283 16.664-4.16 1.738-13.889 1.925-18.096.347-17.67-6.628-23.849-28.21-11.645-40.68 5.378-5.494 122.039-79.894 127.75-81.47 9.037-2.496 20.352 1.013 26.744 8.293 4.882 5.56 6.727 10.52 6.695 17.99l-.029 6.446 4.904 1.306c12.307 3.278 34.058 14.246 45.35 22.869 2.72 2.076 5.285 3.775 5.7 3.775 1.288 0 5.255-14.95 6.4-24.12 3.407-27.296-9.063-57.132-31.933-76.408-26.294-22.162-62.304-28-94.067-15.252-6.577 2.64-.2-1.29-74.004 45.59-55.791 35.438-59.99 38.319-68.987 47.332-10.858 10.879-16.752 20.816-20.829 35.118-3.414 11.98-3.41 31.399.01 43.435 13.837 48.71 63.663 77.611 112.355 65.171 10.824-2.765 18.631-6.896 45.876-24.271 13.128-8.373 25.406-15.869 27.283-16.657 4.071-1.71 13.823-1.88 18-.314 17.67 6.628 23.848 28.21 11.644 40.679-5.378 5.494-122.038 79.894-127.749 81.47-9.037 2.496-20.352-1.013-26.744-8.293-4.883-5.56-6.728-10.52-6.695-17.99l.028-6.446-4.904-1.306c-12.306-3.278-34.057-14.246-45.35-22.868-2.72-2.077-5.284-3.776-5.699-3.776-1.288 0-5.255 14.95-6.4 24.121-4.265 34.178 16.128 70.808 48.833 87.712 20.186 10.434 40.992 13.203 62.915 8.375z"
  },
  tailwind: {
    viewBox: `0.15 0.13 799.7 479.69`,
    path: "M400 .13c-106.63 0-173.27 53.3-199.93 159.89 39.99-53.3 86.64-73.28 139.95-59.96 30.42 7.6 52.16 29.67 76.23 54.09 39.2 39.78 84.57 85.82 183.68 85.82 106.62 0 173.27-53.3 199.92-159.9-39.98 53.3-86.63 73.29-139.95 59.97-30.41-7.6-52.15-29.67-76.22-54.09C544.48 46.17 499.1.13 400 .13zM200.07 239.97c-106.62 0-173.27 53.3-199.92 159.9 39.98-53.3 86.63-73.29 139.95-59.96 30.41 7.61 52.15 29.67 76.22 54.08 39.2 39.78 84.58 85.83 183.68 85.83 106.63 0 173.27-53.3 199.93-159.9-39.99 53.3-86.64 73.29-139.95 59.96-30.42-7.59-52.16-29.67-76.23-54.08-39.2-39.78-84.57-85.83-183.68-85.83z"
  },
  astro: {
    viewBox: "0 0 1280 1280",
    path: "M815 95c10 12 15 28 25 61l216 711c-80-42-167-72-259-88L656 303a18 18 0 0 0-35 0L482 779c-92 16-180 46-260 88l217-712c10-32 15-48 25-60 9-11 20-19 32-24 15-6 32-6 66-6h155c34 0 51 0 66 6 12 5 23 13 32 24Zm26 806c-36 30-107 51-189 51-101 0-185-31-208-73-8 24-9 51-9 69 0 0-6 87 55 147 0-31 25-57 56-57 54 0 54 47 54 85v4c0 57 35 107 85 128-7-16-11-33-11-51 0-55 32-76 70-100 29-19 63-40 86-82a155 155 0 0 0 11-121Z"
  },
  linkedin: {
    path: "M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"
  },
  npm: {
    viewBox: `0 0 576 512`,
    path: "M288 288h-32v-64h32v64zm288-128v192H288v32H160v-32H0V160h576zm-416 32H32v128h64v-96h32v96h32V192zm160 0H192v160h64v-32h64V192zm224 0H352v128h64v-96h32v96h32v-96h32v96h32V192z"
  },
  "angle-down": {
    viewBox: `0 0 384 512`,
    path: "M192 384c-8.188 0-16.38-3.125-22.62-9.375l-160-160c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L192 306.8l137.4-137.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-160 160C208.4 380.9 200.2 384 192 384z"
  },
  "copy-button": {
    viewBox: "0 0 512 512",
    path: "M224 0c-35.3 0-64 28.7-64 64V288c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64H224zM64 160c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H288c35.3 0 64-28.7 64-64V384H288v64H64V224h64V160H64z"
  },
  sun: {
    path: "M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"
  },
  moon: {
    path: "M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"
  },
  bars: {
    viewBox: "0 0 576 512",
    path: "M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"
  },
  house: {
    viewBox: "0 0 576 512",
    path: "M575.8 255.5C575.8 273.5 560.8 287.6 543.8 287.6H511.8L512.5 447.7C512.5 450.5 512.3 453.1 512 455.8V472C512 494.1 494.1 512 472 512H456C454.9 512 453.8 511.1 452.7 511.9C451.3 511.1 449.9 512 448.5 512H392C369.9 512 352 494.1 352 472V384C352 366.3 337.7 352 320 352H256C238.3 352 224 366.3 224 384V472C224 494.1 206.1 512 184 512H128.1C126.6 512 125.1 511.9 123.6 511.8C122.4 511.9 121.2 512 120 512H104C81.91 512 64 494.1 64 472V360C64 359.1 64.03 358.1 64.09 357.2V287.6H32.05C14.02 287.6 0 273.5 0 255.5C0 246.5 3.004 238.5 10.01 231.5L266.4 8.016C273.4 1.002 281.4 0 288.4 0C295.4 0 303.4 2.004 309.5 7.014L564.8 231.5C572.8 238.5 576.9 246.5 575.8 255.5L575.8 255.5z"
  },
  "circle-question": {
    path: "M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 400c-18 0-32-14-32-32s13.1-32 32-32c17.1 0 32 14 32 32S273.1 400 256 400zM325.1 258L280 286V288c0 13-11 24-24 24S232 301 232 288V272c0-8 4-16 12-21l57-34C308 213 312 206 312 198C312 186 301.1 176 289.1 176h-51.1C225.1 176 216 186 216 198c0 13-11 24-24 24s-24-11-24-24C168 159 199 128 237.1 128h51.1C329 128 360 159 360 198C360 222 347 245 325.1 258z"
  },
  "circle-check": {
    path: "M0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM371.8 211.8C382.7 200.9 382.7 183.1 371.8 172.2C360.9 161.3 343.1 161.3 332.2 172.2L224 280.4L179.8 236.2C168.9 225.3 151.1 225.3 140.2 236.2C129.3 247.1 129.3 264.9 140.2 275.8L204.2 339.8C215.1 350.7 232.9 350.7 243.8 339.8L371.8 211.8z"
  },
  heart: {
    path: "M0 190.9V185.1C0 115.2 50.52 55.58 119.4 44.1C164.1 36.51 211.4 51.37 244 84.02L256 96L267.1 84.02C300.6 51.37 347 36.51 392.6 44.1C461.5 55.58 512 115.2 512 185.1V190.9C512 232.4 494.8 272.1 464.4 300.4L283.7 469.1C276.2 476.1 266.3 480 256 480C245.7 480 235.8 476.1 228.3 469.1L47.59 300.4C17.23 272.1 .0003 232.4 .0003 190.9L0 190.9z"
  },
  skull: {
    path: "M416 400V464C416 490.5 394.5 512 368 512H320V464C320 455.2 312.8 448 304 448C295.2 448 288 455.2 288 464V512H224V464C224 455.2 216.8 448 208 448C199.2 448 192 455.2 192 464V512H144C117.5 512 96 490.5 96 464V400C96 399.6 96 399.3 96.01 398.9C37.48 357.8 0 294.7 0 224C0 100.3 114.6 0 256 0C397.4 0 512 100.3 512 224C512 294.7 474.5 357.8 415.1 398.9C415.1 399.3 416 399.6 416 400V400zM160 192C124.7 192 96 220.7 96 256C96 291.3 124.7 320 160 320C195.3 320 224 291.3 224 256C224 220.7 195.3 192 160 192zM352 320C387.3 320 416 291.3 416 256C416 220.7 387.3 192 352 192C316.7 192 288 220.7 288 256C288 291.3 316.7 320 352 320z"
  },
  "align-left": {
    viewBox: "0 0 448 512",
    path: "M256 96H32C14.33 96 0 81.67 0 64C0 46.33 14.33 32 32 32H256C273.7 32 288 46.33 288 64C288 81.67 273.7 96 256 96zM256 352H32C14.33 352 0 337.7 0 320C0 302.3 14.33 288 32 288H256C273.7 288 288 302.3 288 320C288 337.7 273.7 352 256 352zM0 192C0 174.3 14.33 160 32 160H416C433.7 160 448 174.3 448 192C448 209.7 433.7 224 416 224H32C14.33 224 0 209.7 0 192zM416 480H32C14.33 480 0 465.7 0 448C0 430.3 14.33 416 32 416H416C433.7 416 448 430.3 448 448C448 465.7 433.7 480 416 480z"
  },
  "align-justify": {
    viewBox: "0 0 448 512",
    path: "M416 96H32C14.33 96 0 81.67 0 64C0 46.33 14.33 32 32 32H416C433.7 32 448 46.33 448 64C448 81.67 433.7 96 416 96zM416 352H32C14.33 352 0 337.7 0 320C0 302.3 14.33 288 32 288H416C433.7 288 448 302.3 448 320C448 337.7 433.7 352 416 352zM0 192C0 174.3 14.33 160 32 160H416C433.7 160 448 174.3 448 192C448 209.7 433.7 224 416 224H32C14.33 224 0 209.7 0 192zM416 480H32C14.33 480 0 465.7 0 448C0 430.3 14.33 416 32 416H416C433.7 416 448 430.3 448 448C448 465.7 433.7 480 416 480z"
  },
  "align-right": {
    viewBox: "0 0 448 512",
    path: "M416 96H192C174.3 96 160 81.67 160 64C160 46.33 174.3 32 192 32H416C433.7 32 448 46.33 448 64C448 81.67 433.7 96 416 96zM416 352H192C174.3 352 160 337.7 160 320C160 302.3 174.3 288 192 288H416C433.7 288 448 302.3 448 320C448 337.7 433.7 352 416 352zM0 192C0 174.3 14.33 160 32 160H416C433.7 160 448 174.3 448 192C448 209.7 433.7 224 416 224H32C14.33 224 0 209.7 0 192zM416 480H32C14.33 480 0 465.7 0 448C0 430.3 14.33 416 32 416H416C433.7 416 448 430.3 448 448C448 465.7 433.7 480 416 480z"
  },
  book: {
    path: "M448 336v-288C448 21.49 426.5 0 400 0H96C42.98 0 0 42.98 0 96v320c0 53.02 42.98 96 96 96h320c17.67 0 32-14.33 32-31.1c0-11.72-6.607-21.52-16-27.1v-81.36C441.8 362.8 448 350.2 448 336zM143.1 128h192C344.8 128 352 135.2 352 144C352 152.8 344.8 160 336 160H143.1C135.2 160 128 152.8 128 144C128 135.2 135.2 128 143.1 128zM143.1 192h192C344.8 192 352 199.2 352 208C352 216.8 344.8 224 336 224H143.1C135.2 224 128 216.8 128 208C128 199.2 135.2 192 143.1 192zM384 448H96c-17.67 0-32-14.33-32-32c0-17.67 14.33-32 32-32h288V448z"
  },
  clapperboard: {
    path: "M326.1 160l127.4-127.4C451.7 32.39 449.9 32 448 32h-86.06l-128 128H326.1zM166.1 160l128-128H201.9l-128 128H166.1zM497.7 56.19L393.9 160H512V96C512 80.87 506.5 67.15 497.7 56.19zM134.1 32H64C28.65 32 0 60.65 0 96v64h6.062L134.1 32zM0 416c0 35.35 28.65 64 64 64h384c35.35 0 64-28.65 64-64V192H0V416z"
  },
  tv: {
    viewBox: "0 0 640 512",
    path: "M463.1 32h-416C21.49 32-.0001 53.49-.0001 80v352c0 26.51 21.49 48 47.1 48h416c26.51 0 48-21.49 48-48v-352C511.1 53.49 490.5 32 463.1 32zM111.1 408c0 4.418-3.582 8-8 8H55.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8L111.1 408zM111.1 280c0 4.418-3.582 8-8 8H55.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8V280zM111.1 152c0 4.418-3.582 8-8 8H55.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8L111.1 152zM351.1 400c0 8.836-7.164 16-16 16H175.1c-8.836 0-16-7.164-16-16v-96c0-8.838 7.164-16 16-16h160c8.836 0 16 7.162 16 16V400zM351.1 208c0 8.836-7.164 16-16 16H175.1c-8.836 0-16-7.164-16-16v-96c0-8.838 7.164-16 16-16h160c8.836 0 16 7.162 16 16V208zM463.1 408c0 4.418-3.582 8-8 8h-47.1c-4.418 0-7.1-3.582-7.1-8l0-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8V408zM463.1 280c0 4.418-3.582 8-8 8h-47.1c-4.418 0-8-3.582-8-8v-48c0-4.418 3.582-8 8-8h47.1c4.418 0 8 3.582 8 8V280zM463.1 152c0 4.418-3.582 8-8 8h-47.1c-4.418 0-8-3.582-8-8l0-48c0-4.418 3.582-8 7.1-8h47.1c4.418 0 8 3.582 8 8V152z"
  },
  swatchbook: {
    path: "M0 32C0 14.33 14.33 0 32 0H160C177.7 0 192 14.33 192 32V416C192 469 149 512 96 512C42.98 512 0 469 0 416V32zM128 64H64V128H128V64zM64 256H128V192H64V256zM96 440C109.3 440 120 429.3 120 416C120 402.7 109.3 392 96 392C82.75 392 72 402.7 72 416C72 429.3 82.75 440 96 440zM224 416V154L299.4 78.63C311.9 66.13 332.2 66.13 344.7 78.63L435.2 169.1C447.7 181.6 447.7 201.9 435.2 214.4L223.6 425.9C223.9 422.7 224 419.3 224 416V416zM374.8 320H480C497.7 320 512 334.3 512 352V480C512 497.7 497.7 512 480 512H182.8L374.8 320z"
  },
  screwdriver: {
    path: "M331.8 224.1c28.29 0 54.88 10.99 74.86 30.97l19.59 19.59c40.01-17.74 71.25-53.3 81.62-96.65c5.725-23.92 5.34-47.08 .2148-68.4c-2.613-10.88-16.43-14.51-24.34-6.604l-68.9 68.9h-75.6V97.2l68.9-68.9c7.912-7.912 4.275-21.73-6.604-24.34c-21.32-5.125-44.48-5.51-68.4 .2148c-55.3 13.23-98.39 60.22-107.2 116.4C224.5 128.9 224.2 137 224.3 145l82.78 82.86C315.2 225.1 323.5 224.1 331.8 224.1zM384 278.6c-23.16-23.16-57.57-27.57-85.39-13.9L191.1 158L191.1 95.99l-127.1-95.99L0 63.1l96 127.1l62.04 .0077l106.7 106.6c-13.67 27.82-9.251 62.23 13.91 85.39l117 117.1c14.62 14.5 38.21 14.5 52.71-.0016l52.75-52.75c14.5-14.5 14.5-38.08-.0016-52.71L384 278.6zM227.9 307L168.7 247.9l-148.9 148.9c-26.37 26.37-26.37 69.08 0 95.45C32.96 505.4 50.21 512 67.5 512s34.54-6.592 47.72-19.78l119.1-119.1C225.5 352.3 222.6 329.4 227.9 307zM64 472c-13.25 0-24-10.75-24-24c0-13.26 10.75-24 24-24S88 434.7 88 448C88 461.3 77.25 472 64 472z"
  },
  "pen-ruler": {
    path: "M469.3 19.3l23.4 23.4c25 25 25 65.5 0 90.5l-56.4 56.4L322.3 75.7l56.4-56.4c25-25 65.5-25 90.5 0zM44.9 353.2L299.7 98.3 413.7 212.3 158.8 467.1c-6.7 6.7-15.1 11.6-24.2 14.2l-104 29.7c-8.4 2.4-17.4 .1-23.6-6.1s-8.5-15.2-6.1-23.6l29.7-104c2.6-9.2 7.5-17.5 14.2-24.2zM249.4 103.4L103.4 249.4 16 161.9c-18.7-18.7-18.7-49.1 0-67.9L94.1 16c18.7-18.7 49.1-18.7 67.9 0l19.8 19.8c-.3 .3-.7 .6-1 .9l-64 64c-6.2 6.2-6.2 16.4 0 22.6s16.4 6.2 22.6 0l64-64c.3-.3 .6-.7 .9-1l45.1 45.1zM408.6 262.6l45.1 45.1c-.3 .3-.7 .6-1 .9l-64 64c-6.2 6.2-6.2 16.4 0 22.6s16.4 6.2 22.6 0l64-64c.3-.3 .6-.7 .9-1L496 350.1c18.7 18.7 18.7 49.1 0 67.9L417.9 496c-18.7 18.7-49.1 18.7-67.9 0l-87.4-87.4L408.6 262.6z"
  },
  keyboard: {
    viewBox: "0 0 576 512",
    path: "M512 64H64C28.65 64 0 92.65 0 128v256c0 35.35 28.65 64 64 64h448c35.35 0 64-28.65 64-64V128C576 92.65 547.3 64 512 64zM528 384c0 8.822-7.178 16-16 16H64c-8.822 0-16-7.178-16-16V128c0-8.822 7.178-16 16-16h448c8.822 0 16 7.178 16 16V384zM140 152h-24c-6.656 0-12 5.344-12 12v24c0 6.656 5.344 12 12 12h24c6.656 0 12-5.344 12-12v-24C152 157.3 146.7 152 140 152zM196 200h24c6.656 0 12-5.344 12-12v-24c0-6.656-5.344-12-12-12h-24c-6.656 0-12 5.344-12 12v24C184 194.7 189.3 200 196 200zM276 200h24c6.656 0 12-5.344 12-12v-24c0-6.656-5.344-12-12-12h-24c-6.656 0-12 5.344-12 12v24C264 194.7 269.3 200 276 200zM356 200h24c6.656 0 12-5.344 12-12v-24c0-6.656-5.344-12-12-12h-24c-6.656 0-12 5.344-12 12v24C344 194.7 349.3 200 356 200zM460 152h-24c-6.656 0-12 5.344-12 12v24c0 6.656 5.344 12 12 12h24c6.656 0 12-5.344 12-12v-24C472 157.3 466.7 152 460 152zM140 232h-24c-6.656 0-12 5.344-12 12v24c0 6.656 5.344 12 12 12h24c6.656 0 12-5.344 12-12v-24C152 237.3 146.7 232 140 232zM196 280h24c6.656 0 12-5.344 12-12v-24c0-6.656-5.344-12-12-12h-24c-6.656 0-12 5.344-12 12v24C184 274.7 189.3 280 196 280zM276 280h24c6.656 0 12-5.344 12-12v-24c0-6.656-5.344-12-12-12h-24c-6.656 0-12 5.344-12 12v24C264 274.7 269.3 280 276 280zM356 280h24c6.656 0 12-5.344 12-12v-24c0-6.656-5.344-12-12-12h-24c-6.656 0-12 5.344-12 12v24C344 274.7 349.3 280 356 280zM460 232h-24c-6.656 0-12 5.344-12 12v24c0 6.656 5.344 12 12 12h24c6.656 0 12-5.344 12-12v-24C472 237.3 466.7 232 460 232zM400 320h-224C167.1 320 160 327.1 160 336V352c0 8.875 7.125 16 16 16h224c8.875 0 16-7.125 16-16v-16C416 327.1 408.9 320 400 320z"
  },
  rocket: {
    path: "M156.6 384.9L125.7 354c-8.5-8.5-11.5-20.8-7.7-32.2c3-8.9 7-20.5 11.8-33.8L24 288c-8.6 0-16.6-4.6-20.9-12.1s-4.2-16.7 .2-24.1l52.5-88.5c13-21.9 36.5-35.3 61.9-35.3l82.3 0c2.4-4 4.8-7.7 7.2-11.3C289.1-4.1 411.1-8.1 483.9 5.3c11.6 2.1 20.6 11.2 22.8 22.8c13.4 72.9 9.3 194.8-111.4 276.7c-3.5 2.4-7.3 4.8-11.3 7.2v82.3c0 25.4-13.4 49-35.3 61.9l-88.5 52.5c-7.4 4.4-16.6 4.5-24.1 .2s-12.1-12.2-12.1-20.9V380.8c-14.1 4.9-26.4 8.9-35.7 11.9c-11.2 3.6-23.4 .5-31.8-7.8zM384 168c22.1 0 40-17.9 40-40s-17.9-40-40-40s-40 17.9-40 40s17.9 40 40 40z"
  },
  copy: {
    viewBox: "0 0 512 512",
    path: "M224 0c-35.3 0-64 28.7-64 64V288c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64H224zM64 160c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H288c35.3 0 64-28.7 64-64V384H288v64H64V224h64V160H64z"
  },
  cubes: {
    viewBox: "0 0 576 512",
    path: "M290.8 48.6l78.4 29.7L288 109.5 206.8 78.3l78.4-29.7c1.8-.7 3.8-.7 5.7 0zM136 92.5V204.7c-1.3 .4-2.6 .8-3.9 1.3l-96 36.4C14.4 250.6 0 271.5 0 294.7V413.9c0 22.2 13.1 42.3 33.5 51.3l96 42.2c14.4 6.3 30.7 6.3 45.1 0L288 457.5l113.5 49.9c14.4 6.3 30.7 6.3 45.1 0l96-42.2c20.3-8.9 33.5-29.1 33.5-51.3V294.7c0-23.3-14.4-44.1-36.1-52.4l-96-36.4c-1.3-.5-2.6-.9-3.9-1.3V92.5c0-23.3-14.4-44.1-36.1-52.4l-96-36.4c-12.8-4.8-26.9-4.8-39.7 0l-96 36.4C150.4 48.4 136 69.3 136 92.5zM392 210.6l-82.4 31.2V152.6L392 121v89.6zM154.8 250.9l78.4 29.7L152 311.7 70.8 280.6l78.4-29.7c1.8-.7 3.8-.7 5.7 0zm18.8 204.4V354.8L256 323.2v95.9l-82.4 36.2zM421.2 250.9c1.8-.7 3.8-.7 5.7 0l78.4 29.7L424 311.7l-81.2-31.1 78.4-29.7zM523.2 421.2l-77.6 34.1V354.8L528 323.2v90.7c0 3.2-1.9 6-4.8 7.3z"
  },
  search: {
    viewBox: "0 0 512 512",
    path: "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"
  }
};

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/SvgIcon/SvgIcon.svelte
var file2 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\SvgIcon\\SvgIcon.svelte";
function create_if_block_1(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[4]);
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", {});
      var title_1_nodes = children(title_1);
      t = claim_text(title_1_nodes, ctx[4]);
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(title_1, file2, 38, 15, 1115);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(39:4) {#if title}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let path;
  let path_d_value;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", path_d_value = icons[ctx[0]].path);
      add_location(path, file2, 42, 8, 1206);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && path_d_value !== (path_d_value = icons[ctx2[0]].path)) {
        attr_dev(path, "d", path_d_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(42:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(40:4) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let svg;
  let if_block0_anchor;
  let current_block_type_index;
  let if_block1;
  let svg_class_value;
  let current;
  let if_block0 = ctx[4] && create_if_block_1(ctx);
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7].default)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        x: true,
        y: true,
        viewBox: true,
        class: true,
        focusable: true,
        "data-testid": true
      });
      var svg_nodes = children(svg);
      if (if_block0)
        if_block0.l(svg_nodes);
      if_block0_anchor = empty();
      if_block1.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "x", ctx[1]);
      attr_dev(svg, "y", ctx[2]);
      attr_dev(svg, "viewBox", ctx[3]);
      attr_dev(svg, "class", svg_class_value = "svg-icon " + ctx[5] + " " + (ctx[6].class ?? ""));
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "data-testid", "svg-icon");
      add_location(svg, file2, 30, 0, 925);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block0)
        if_block0.m(svg, null);
      append_hydration_dev(svg, if_block0_anchor);
      if_blocks[current_block_type_index].m(svg, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(svg, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(svg, null);
      }
      if (!current || dirty & 2) {
        attr_dev(svg, "x", ctx2[1]);
      }
      if (!current || dirty & 4) {
        attr_dev(svg, "y", ctx2[2]);
      }
      if (!current || dirty & 8) {
        attr_dev(svg, "viewBox", ctx2[3]);
      }
      if (!current || dirty & 96 && svg_class_value !== (svg_class_value = "svg-icon " + ctx2[5] + " " + (ctx2[6].class ?? ""))) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase2 = "inline-block outline-none";
function instance2($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvgIcon", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { name = "image" } = $$props;
  let { x = "0px" } = $$props;
  let { y = "0px" } = $$props;
  let { viewBox = icons[name].viewBox || "0 0 512 512" } = $$props;
  let { fill = "fill-current" } = $$props;
  let { width = "w-5" } = $$props;
  let { height = "h-5" } = $$props;
  let { title = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("x" in $$new_props)
      $$invalidate(1, x = $$new_props.x);
    if ("y" in $$new_props)
      $$invalidate(2, y = $$new_props.y);
    if ("viewBox" in $$new_props)
      $$invalidate(3, viewBox = $$new_props.viewBox);
    if ("fill" in $$new_props)
      $$invalidate(8, fill = $$new_props.fill);
    if ("width" in $$new_props)
      $$invalidate(9, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(10, height = $$new_props.height);
    if ("title" in $$new_props)
      $$invalidate(4, title = $$new_props.title);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    icons,
    name,
    x,
    y,
    viewBox,
    fill,
    width,
    height,
    title,
    cBase: cBase2,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(0, name = $$new_props.name);
    if ("x" in $$props)
      $$invalidate(1, x = $$new_props.x);
    if ("y" in $$props)
      $$invalidate(2, y = $$new_props.y);
    if ("viewBox" in $$props)
      $$invalidate(3, viewBox = $$new_props.viewBox);
    if ("fill" in $$props)
      $$invalidate(8, fill = $$new_props.fill);
    if ("width" in $$props)
      $$invalidate(9, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(10, height = $$new_props.height);
    if ("title" in $$props)
      $$invalidate(4, title = $$new_props.title);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1792) {
      $:
        $$invalidate(5, classesBase = `${cBase2} ${fill} ${width} ${height}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    x,
    y,
    viewBox,
    title,
    classesBase,
    $$props,
    $$slots,
    fill,
    width,
    height,
    $$scope,
    slots
  ];
}
var SvgIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      name: 0,
      x: 1,
      y: 2,
      viewBox: 3,
      fill: 8,
      width: 9,
      height: 10,
      title: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvgIcon",
      options,
      id: create_fragment2.name
    });
  }
  get name() {
    throw new Error("<SvgIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SvgIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<SvgIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<SvgIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<SvgIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<SvgIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get viewBox() {
    throw new Error("<SvgIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewBox(value) {
    throw new Error("<SvgIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<SvgIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<SvgIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<SvgIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<SvgIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<SvgIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<SvgIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<SvgIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SvgIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvgIcon_default = SvgIcon;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Accordion/AccordionItem.svelte
var file3 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Accordion\\AccordionItem.svelte";
function add_css(target) {
  append_styles(target, "svelte-kkbihn", "details.svelte-kkbihn summary.svelte-kkbihn::-webkit-details-marker{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWNjb3JkaW9uSXRlbS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUVDLHFCQUFBLENBQUEscUJBQUEsd0JBQUEsQUFBQSxDQUFBLEFBQ0MsT0FBQSxDQUFBLElBQWEsQUFDZCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkFjY29yZGlvbkl0ZW0uc3ZlbHRlIl19 */");
}
var get_content_slot_changes = (dirty) => ({});
var get_content_slot_context = (ctx) => ({});
var get_summary_slot_changes = (dirty) => ({});
var get_summary_slot_context = (ctx) => ({});
var get_lead_slot_changes = (dirty) => ({});
var get_lead_slot_context = (ctx) => ({});
function create_if_block2(ctx) {
  let div;
  let current;
  const lead_slot_template = ctx[16].lead;
  const lead_slot = create_slot(lead_slot_template, ctx, ctx[15], get_lead_slot_context);
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "accordion-summary-lead");
      add_location(div, file3, 49, 20, 2263);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(lead_slot_template, ctx2[15], dirty, get_lead_slot_changes),
            get_lead_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(50:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(summary)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(summary)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(52:83) (summary)",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(content)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(content)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(61:23) (content)",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let details;
  let summary;
  let t0;
  let div0;
  let t1;
  let div1;
  let svgicon;
  let div1_class_value;
  let summary_class_value;
  let t2;
  let div2;
  let div2_class_value;
  let details_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[7].lead && create_if_block2(ctx);
  const summary_slot_template = ctx[16].summary;
  const summary_slot = create_slot(summary_slot_template, ctx, ctx[15], get_summary_slot_context);
  const summary_slot_or_fallback = summary_slot || fallback_block_1(ctx);
  svgicon = new SvgIcon_default({
    props: { name: "angle-down", class: "opacity-50" },
    $$inline: true
  });
  const content_slot_template = ctx[16].content;
  const content_slot = create_slot(content_slot_template, ctx, ctx[15], get_content_slot_context);
  const content_slot_or_fallback = content_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      details = element("details");
      summary = element("summary");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.c();
      t1 = space();
      div1 = element("div");
      create_component(svgicon.$$.fragment);
      t2 = space();
      div2 = element("div");
      if (content_slot_or_fallback)
        content_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      details = claim_element(nodes, "DETAILS", { class: true, "data-testid": true });
      var details_nodes = children(details);
      summary = claim_element(details_nodes, "SUMMARY", {
        id: true,
        class: true,
        "aria-expanded": true,
        "aria-controls": true
      });
      var summary_nodes = children(summary);
      if (if_block)
        if_block.l(summary_nodes);
      t0 = claim_space(summary_nodes);
      div0 = claim_element(summary_nodes, "DIV", { class: true, role: true });
      var div0_nodes = children(div0);
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(summary_nodes);
      div1 = claim_element(summary_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(svgicon.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      summary_nodes.forEach(detach_dev);
      t2 = claim_space(details_nodes);
      div2 = claim_element(details_nodes, "DIV", {
        id: true,
        class: true,
        role: true,
        "aria-labelledby": true
      });
      var div2_nodes = children(div2);
      if (content_slot_or_fallback)
        content_slot_or_fallback.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      details_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "accordion-summary-text flex-auto");
      attr_dev(div0, "role", "button");
      add_location(div0, file3, 51, 2, 2355);
      attr_dev(div1, "class", div1_class_value = "accordion-summary-caret " + ctx[4]);
      add_location(div1, file3, 53, 2, 2478);
      attr_dev(summary, "id", ctx[1]);
      attr_dev(summary, "class", summary_class_value = "accordion-summary " + ctx[5] + " svelte-kkbihn");
      attr_dev(summary, "aria-expanded", ctx[0]);
      attr_dev(summary, "aria-controls", ctx[2]);
      add_location(summary, file3, 47, 1, 2106);
      attr_dev(div2, "id", ctx[2]);
      attr_dev(div2, "class", div2_class_value = "accordion-content " + ctx[3]);
      attr_dev(div2, "role", "region");
      attr_dev(div2, "aria-labelledby", ctx[1]);
      add_location(div2, file3, 59, 1, 2623);
      attr_dev(details, "class", details_class_value = "accordion-item " + ctx[6] + " svelte-kkbihn");
      attr_dev(details, "data-testid", "accordion-item");
      add_location(details, file3, 45, 0, 1957);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, details, anchor);
      append_hydration_dev(details, summary);
      if (if_block)
        if_block.m(summary, null);
      append_hydration_dev(summary, t0);
      append_hydration_dev(summary, div0);
      if (summary_slot_or_fallback) {
        summary_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(summary, t1);
      append_hydration_dev(summary, div1);
      mount_component(svgicon, div1, null);
      append_hydration_dev(details, t2);
      append_hydration_dev(details, div2);
      if (content_slot_or_fallback) {
        content_slot_or_fallback.m(div2, null);
      }
      details.open = ctx[0];
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(details, "toggle", ctx[21]),
          listen_dev(details, "click", ctx[17], false, false, false),
          listen_dev(details, "keydown", ctx[18], false, false, false),
          listen_dev(details, "keyup", ctx[19], false, false, false),
          listen_dev(details, "keypress", ctx[20], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[7].lead) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(summary, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            summary_slot,
            summary_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(summary_slot_template, ctx2[15], dirty, get_summary_slot_changes),
            get_summary_slot_context
          );
        }
      }
      if (!current || dirty & 16 && div1_class_value !== (div1_class_value = "accordion-summary-caret " + ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & 2) {
        attr_dev(summary, "id", ctx2[1]);
      }
      if (!current || dirty & 32 && summary_class_value !== (summary_class_value = "accordion-summary " + ctx2[5] + " svelte-kkbihn")) {
        attr_dev(summary, "class", summary_class_value);
      }
      if (!current || dirty & 1) {
        attr_dev(summary, "aria-expanded", ctx2[0]);
      }
      if (!current || dirty & 4) {
        attr_dev(summary, "aria-controls", ctx2[2]);
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(content_slot_template, ctx2[15], dirty, get_content_slot_changes),
            get_content_slot_context
          );
        }
      }
      if (!current || dirty & 4) {
        attr_dev(div2, "id", ctx2[2]);
      }
      if (!current || dirty & 8 && div2_class_value !== (div2_class_value = "accordion-content " + ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & 2) {
        attr_dev(div2, "aria-labelledby", ctx2[1]);
      }
      if (!current || dirty & 64 && details_class_value !== (details_class_value = "accordion-item " + ctx2[6] + " svelte-kkbihn")) {
        attr_dev(details, "class", details_class_value);
      }
      if (dirty & 1) {
        details.open = ctx2[0];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(summary_slot_or_fallback, local);
      transition_in(svgicon.$$.fragment, local);
      transition_in(content_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(summary_slot_or_fallback, local);
      transition_out(svgicon.$$.fragment, local);
      transition_out(content_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(details);
      if (if_block)
        if_block.d();
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.d(detaching);
      destroy_component(svgicon);
      if (content_slot_or_fallback)
        content_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBaseDetails = "";
var cBaseSummary = "list-none flex items-center space-x-4 cursor-pointer";
var cBaseIcon = "flex justify-center items-center w-3 fill-black dark:fill-white transition-all duration-[100ms]";
function instance3($$self, $$props, $$invalidate) {
  let classesDetails;
  let classesSummary;
  let classesIconState;
  let classesIcon;
  let classesContent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["lead", "summary", "content"]);
  const $$slots = compute_slots(slots);
  let { open = false } = $$props;
  let { summaryId = "" } = $$props;
  let { contentId = "" } = $$props;
  let { regionSummary = "" } = $$props;
  let { regionContent = "" } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function details_toggle_handler() {
    open = this.open;
    $$invalidate(0, open);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("summaryId" in $$new_props)
      $$invalidate(1, summaryId = $$new_props.summaryId);
    if ("contentId" in $$new_props)
      $$invalidate(2, contentId = $$new_props.contentId);
    if ("regionSummary" in $$new_props)
      $$invalidate(8, regionSummary = $$new_props.regionSummary);
    if ("regionContent" in $$new_props)
      $$invalidate(9, regionContent = $$new_props.regionContent);
    if ("hover" in $$new_props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("spacing" in $$new_props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("padding" in $$new_props)
      $$invalidate(12, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    SvgIcon: SvgIcon_default,
    open,
    summaryId,
    contentId,
    regionSummary,
    regionContent,
    hover,
    spacing,
    padding,
    rounded,
    cBaseDetails,
    cBaseSummary,
    cBaseIcon,
    classesContent,
    classesIconState,
    classesIcon,
    classesSummary,
    classesDetails
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("summaryId" in $$props)
      $$invalidate(1, summaryId = $$new_props.summaryId);
    if ("contentId" in $$props)
      $$invalidate(2, contentId = $$new_props.contentId);
    if ("regionSummary" in $$props)
      $$invalidate(8, regionSummary = $$new_props.regionSummary);
    if ("regionContent" in $$props)
      $$invalidate(9, regionContent = $$new_props.regionContent);
    if ("hover" in $$props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("spacing" in $$props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("padding" in $$props)
      $$invalidate(12, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("classesContent" in $$props)
      $$invalidate(3, classesContent = $$new_props.classesContent);
    if ("classesIconState" in $$props)
      $$invalidate(14, classesIconState = $$new_props.classesIconState);
    if ("classesIcon" in $$props)
      $$invalidate(4, classesIcon = $$new_props.classesIcon);
    if ("classesSummary" in $$props)
      $$invalidate(5, classesSummary = $$new_props.classesSummary);
    if ("classesDetails" in $$props)
      $$invalidate(6, classesDetails = $$new_props.classesDetails);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesDetails = `${cBaseDetails} ${spacing} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 13568) {
      $:
        $$invalidate(5, classesSummary = `${cBaseSummary} ${padding} ${rounded} ${hover} ${regionSummary}`);
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(14, classesIconState = open ? "-rotate-180" : "");
    }
    if ($$self.$$.dirty & 16384) {
      $:
        $$invalidate(4, classesIcon = `${cBaseIcon} ${classesIconState}`);
    }
    if ($$self.$$.dirty & 4608) {
      $:
        $$invalidate(3, classesContent = `${padding} ${regionContent}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    open,
    summaryId,
    contentId,
    classesContent,
    classesIcon,
    classesSummary,
    classesDetails,
    $$slots,
    regionSummary,
    regionContent,
    hover,
    spacing,
    padding,
    rounded,
    classesIconState,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    details_toggle_handler
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        open: 0,
        summaryId: 1,
        contentId: 2,
        regionSummary: 8,
        regionContent: 9,
        hover: 10,
        spacing: 11,
        padding: 12,
        rounded: 13
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment3.name
    });
  }
  get open() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get summaryId() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set summaryId(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentId() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentId(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSummary() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSummary(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionContent() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionContent(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Alert/Alert.svelte
var file4 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Alert\\Alert.svelte";
var get_trail_slot_changes = (dirty) => ({});
var get_trail_slot_context = (ctx) => ({});
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
var get_lead_slot_changes2 = (dirty) => ({});
var get_lead_slot_context2 = (ctx) => ({});
function create_if_block3(ctx) {
  let div;
  let t0;
  let section;
  let t1;
  let section_class_value;
  let t2;
  let div_class_value;
  let div_transition;
  let current;
  let if_block0 = ctx[7].lead && create_if_block_4(ctx);
  let if_block1 = ctx[7].title && create_if_block_3(ctx);
  let if_block2 = ctx[7].default && create_if_block_2(ctx);
  let if_block3 = ctx[7].trail && create_if_block_12(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      section = element("section");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-live": true
      });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      section = claim_element(div_nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      if (if_block1)
        if_block1.l(section_nodes);
      t1 = claim_space(section_nodes);
      if (if_block2)
        if_block2.l(section_nodes);
      section_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (if_block3)
        if_block3.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(section, "class", section_class_value = "alert-content " + ctx[4]);
      add_location(section, file4, 50, 2, 1934);
      attr_dev(div, "class", div_class_value = "alert " + ctx[6]);
      attr_dev(div, "data-testid", "alert");
      attr_dev(div, "role", "alert");
      attr_dev(div, "aria-live", "polite");
      add_location(div, file4, 41, 1, 1653);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, section);
      if (if_block1)
        if_block1.m(section, null);
      append_hydration_dev(section, t1);
      if (if_block2)
        if_block2.m(section, null);
      append_hydration_dev(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[7].lead) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx[7].title) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & 128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx[7].default) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty & 128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(section, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & 16 && section_class_value !== (section_class_value = "alert-content " + ctx[4])) {
        attr_dev(section, "class", section_class_value);
      }
      if (ctx[7].trail) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
          if (dirty & 128) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_12(ctx);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & 64 && div_class_value !== (div_class_value = "alert " + ctx[6])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, fade, { duration: ctx[2] }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, { duration: ctx[2] }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(41:0) {#if visible}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let section;
  let section_class_value;
  let current;
  const lead_slot_template = ctx[15].lead;
  const lead_slot = create_slot(lead_slot_template, ctx, ctx[14], get_lead_slot_context2);
  const block = {
    c: function create() {
      section = element("section");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      if (lead_slot)
        lead_slot.l(section_nodes);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(section, "class", section_class_value = "alert-lead " + ctx[5]);
      add_location(section, file4, 44, 3, 1822);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      if (lead_slot) {
        lead_slot.m(section, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(lead_slot_template, ctx2[14], dirty, get_lead_slot_changes2),
            get_lead_slot_context2
          );
        }
      }
      if (!current || dirty & 32 && section_class_value !== (section_class_value = "alert-lead " + ctx2[5])) {
        attr_dev(section, "class", section_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(section);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(44:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let h3;
  let current;
  const title_slot_template = ctx[15].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[14], get_title_slot_context);
  const block = {
    c: function create() {
      h3 = element("h3");
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      h3 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h3);
      if (title_slot)
        title_slot.l(h3_nodes);
      h3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h3, "class", "alert-title");
      add_location(h3, file4, 52, 22, 2029);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h3, anchor);
      if (title_slot) {
        title_slot.m(h3, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(title_slot_template, ctx2[14], dirty, get_title_slot_changes),
            get_title_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h3);
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(53:3) {#if $$slots.title}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "alert-message " + ctx[1]);
      add_location(div, file4, 54, 24, 2135);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && div_class_value !== (div_class_value = "alert-message " + ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(55:3) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let section;
  let section_class_value;
  let current;
  const trail_slot_template = ctx[15].trail;
  const trail_slot = create_slot(trail_slot_template, ctx, ctx[14], get_trail_slot_context);
  const block = {
    c: function create() {
      section = element("section");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      if (trail_slot)
        trail_slot.l(section_nodes);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(section, "class", section_class_value = "alert-trail " + ctx[3]);
      add_location(section, file4, 59, 3, 2252);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      if (trail_slot) {
        trail_slot.m(section, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(trail_slot_template, ctx2[14], dirty, get_trail_slot_changes),
            get_trail_slot_context
          );
        }
      }
      if (!current || dirty & 8 && section_class_value !== (section_class_value = "alert-trail " + ctx2[3])) {
        attr_dev(section, "class", section_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(section);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(59:2) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block3(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let classesCard;
  let classesLead;
  let classesContent;
  let classesTrail;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Alert", slots, ["lead", "title", "default", "trail"]);
  const $$slots = compute_slots(slots);
  let { visible = true } = $$props;
  let { background = "bg-tertiary-500/20" } = $$props;
  let { border = "border border-tertiary-500" } = $$props;
  let { color = "" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { duration = 200 } = $$props;
  let { slotLead = "" } = $$props;
  let { slotContent = "" } = $$props;
  let { slotTrail = "" } = $$props;
  let cBaseCard = "flex flex-col items-start lg:items-center lg:flex-row p-5 space-y-4 lg:space-y-0 lg:space-x-4 shadow";
  let cLead2 = "flex justify-center items-center";
  let cContent = "flex flex-col w-full justify-center space-y-2";
  let cTrail2 = "flex items-center space-x-4";
  $$self.$$set = ($$new_props) => {
    $$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("visible" in $$new_props)
      $$invalidate(0, visible = $$new_props.visible);
    if ("background" in $$new_props)
      $$invalidate(8, background = $$new_props.background);
    if ("border" in $$new_props)
      $$invalidate(9, border = $$new_props.border);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("rounded" in $$new_props)
      $$invalidate(10, rounded = $$new_props.rounded);
    if ("duration" in $$new_props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("slotLead" in $$new_props)
      $$invalidate(11, slotLead = $$new_props.slotLead);
    if ("slotContent" in $$new_props)
      $$invalidate(12, slotContent = $$new_props.slotContent);
    if ("slotTrail" in $$new_props)
      $$invalidate(13, slotTrail = $$new_props.slotTrail);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    visible,
    background,
    border,
    color,
    rounded,
    duration,
    slotLead,
    slotContent,
    slotTrail,
    cBaseCard,
    cLead: cLead2,
    cContent,
    cTrail: cTrail2,
    classesTrail,
    classesContent,
    classesLead,
    classesCard
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
    if ("visible" in $$props)
      $$invalidate(0, visible = $$new_props.visible);
    if ("background" in $$props)
      $$invalidate(8, background = $$new_props.background);
    if ("border" in $$props)
      $$invalidate(9, border = $$new_props.border);
    if ("color" in $$props)
      $$invalidate(1, color = $$new_props.color);
    if ("rounded" in $$props)
      $$invalidate(10, rounded = $$new_props.rounded);
    if ("duration" in $$props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("slotLead" in $$props)
      $$invalidate(11, slotLead = $$new_props.slotLead);
    if ("slotContent" in $$props)
      $$invalidate(12, slotContent = $$new_props.slotContent);
    if ("slotTrail" in $$props)
      $$invalidate(13, slotTrail = $$new_props.slotTrail);
    if ("cBaseCard" in $$props)
      $$invalidate(16, cBaseCard = $$new_props.cBaseCard);
    if ("cLead" in $$props)
      $$invalidate(17, cLead2 = $$new_props.cLead);
    if ("cContent" in $$props)
      $$invalidate(18, cContent = $$new_props.cContent);
    if ("cTrail" in $$props)
      $$invalidate(19, cTrail2 = $$new_props.cTrail);
    if ("classesTrail" in $$props)
      $$invalidate(3, classesTrail = $$new_props.classesTrail);
    if ("classesContent" in $$props)
      $$invalidate(4, classesContent = $$new_props.classesContent);
    if ("classesLead" in $$props)
      $$invalidate(5, classesLead = $$new_props.classesLead);
    if ("classesCard" in $$props)
      $$invalidate(6, classesCard = $$new_props.classesCard);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesCard = `${cBaseCard} ${background} ${border} ${color} ${rounded} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 2048) {
      $:
        $$invalidate(5, classesLead = `${cLead2} ${slotLead}`);
    }
    if ($$self.$$.dirty & 4096) {
      $:
        $$invalidate(4, classesContent = `${cContent} ${slotContent}`);
    }
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(3, classesTrail = `${cTrail2} ${slotTrail}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    visible,
    color,
    duration,
    classesTrail,
    classesContent,
    classesLead,
    classesCard,
    $$slots,
    background,
    border,
    rounded,
    slotLead,
    slotContent,
    slotTrail,
    $$scope,
    slots
  ];
}
var Alert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      visible: 0,
      background: 8,
      border: 9,
      color: 1,
      rounded: 10,
      duration: 2,
      slotLead: 11,
      slotContent: 12,
      slotTrail: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Alert",
      options,
      id: create_fragment4.name
    });
  }
  get visible() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotLead() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotLead(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotContent() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotContent(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotTrail() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotTrail(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Alert_default = Alert;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/AppBar/AppBar.svelte
var file5 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\AppBar\\AppBar.svelte";
var get_trail_slot_changes2 = (dirty) => ({});
var get_trail_slot_context2 = (ctx) => ({});
var get_lead_slot_changes3 = (dirty) => ({});
var get_lead_slot_context3 = (ctx) => ({});
function create_if_block_13(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = ctx[16].lead;
  const lead_slot = create_slot(lead_slot_template, ctx, ctx[15], get_lead_slot_context3);
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-lead " + ctx[4]);
      add_location(div, file5, 43, 2, 1693);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(lead_slot_template, ctx2[15], dirty, get_lead_slot_changes3),
            get_lead_slot_context3
          );
        }
      }
      if (!current || dirty & 16 && div_class_value !== (div_class_value = "app-bar-lead " + ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(43:1) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let div;
  let div_class_value;
  let current;
  const trail_slot_template = ctx[16].trail;
  const trail_slot = create_slot(trail_slot_template, ctx, ctx[15], get_trail_slot_context2);
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-trail " + ctx[2]);
      add_location(div, file5, 51, 2, 1897);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(trail_slot_template, ctx2[15], dirty, get_trail_slot_changes2),
            get_trail_slot_context2
          );
        }
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "app-bar-trail " + ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(51:1) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div1;
  let t0;
  let div0;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let current;
  let if_block0 = ctx[6].lead && create_if_block_13(ctx);
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  let if_block1 = ctx[6].trail && create_if_block4(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-labelledby": true
      });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-bar-center " + ctx[3]);
      add_location(div0, file5, 47, 1, 1792);
      attr_dev(div1, "class", div1_class_value = "app-bar " + ctx[5]);
      attr_dev(div1, "data-testid", "app-bar");
      attr_dev(div1, "role", "toolbar");
      attr_dev(div1, "aria-label", ctx[0]);
      attr_dev(div1, "aria-labelledby", ctx[1]);
      add_location(div1, file5, 40, 0, 1529);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[6].lead) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 8 && div0_class_value !== (div0_class_value = "app-bar-center " + ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (ctx2[6].trail) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 32 && div1_class_value !== (div1_class_value = "app-bar " + ctx2[5])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & 1) {
        attr_dev(div1, "aria-label", ctx2[0]);
      }
      if (!current || dirty & 2) {
        attr_dev(div1, "aria-labelledby", ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase3 = "flex items-center";
var cLead = "flex-none flex justify-between items-center";
var cCenter = "flex-auto";
var cTrail = "flex-none flex items-center space-x-4";
function instance5($$self, $$props, $$invalidate) {
  let classesBase;
  let classesLead;
  let classesCenter;
  let classesTrail;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppBar", slots, ["lead", "default", "trail"]);
  const $$slots = compute_slots(slots);
  let { background = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { padding = "p-4" } = $$props;
  let { shadow = "shadow-lg" } = $$props;
  let { space: space2 = "space-x-4" } = $$props;
  let { slotLead = "" } = $$props;
  let { slotDefault = "" } = $$props;
  let { slotTrail = "" } = $$props;
  let { label = "" } = $$props;
  let { labelledby = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("background" in $$new_props)
      $$invalidate(7, background = $$new_props.background);
    if ("border" in $$new_props)
      $$invalidate(8, border = $$new_props.border);
    if ("padding" in $$new_props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("shadow" in $$new_props)
      $$invalidate(10, shadow = $$new_props.shadow);
    if ("space" in $$new_props)
      $$invalidate(11, space2 = $$new_props.space);
    if ("slotLead" in $$new_props)
      $$invalidate(12, slotLead = $$new_props.slotLead);
    if ("slotDefault" in $$new_props)
      $$invalidate(13, slotDefault = $$new_props.slotDefault);
    if ("slotTrail" in $$new_props)
      $$invalidate(14, slotTrail = $$new_props.slotTrail);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("labelledby" in $$new_props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    background,
    border,
    padding,
    shadow,
    space: space2,
    slotLead,
    slotDefault,
    slotTrail,
    label,
    labelledby,
    cBase: cBase3,
    cLead,
    cCenter,
    cTrail,
    classesTrail,
    classesCenter,
    classesLead,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    if ("background" in $$props)
      $$invalidate(7, background = $$new_props.background);
    if ("border" in $$props)
      $$invalidate(8, border = $$new_props.border);
    if ("padding" in $$props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("shadow" in $$props)
      $$invalidate(10, shadow = $$new_props.shadow);
    if ("space" in $$props)
      $$invalidate(11, space2 = $$new_props.space);
    if ("slotLead" in $$props)
      $$invalidate(12, slotLead = $$new_props.slotLead);
    if ("slotDefault" in $$props)
      $$invalidate(13, slotDefault = $$new_props.slotDefault);
    if ("slotTrail" in $$props)
      $$invalidate(14, slotTrail = $$new_props.slotTrail);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("labelledby" in $$props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("classesTrail" in $$props)
      $$invalidate(2, classesTrail = $$new_props.classesTrail);
    if ("classesCenter" in $$props)
      $$invalidate(3, classesCenter = $$new_props.classesCenter);
    if ("classesLead" in $$props)
      $$invalidate(4, classesLead = $$new_props.classesLead);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classesBase = `${cBase3} ${background} ${border} ${padding} ${shadow} ${space2} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 4096) {
      $:
        $$invalidate(4, classesLead = `${cLead} ${slotLead}`);
    }
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(3, classesCenter = `${cCenter} ${slotDefault}`);
    }
    if ($$self.$$.dirty & 16384) {
      $:
        $$invalidate(2, classesTrail = `${cTrail} ${slotTrail}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    labelledby,
    classesTrail,
    classesCenter,
    classesLead,
    classesBase,
    $$slots,
    background,
    border,
    padding,
    shadow,
    space2,
    slotLead,
    slotDefault,
    slotTrail,
    $$scope,
    slots
  ];
}
var AppBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      background: 7,
      border: 8,
      padding: 9,
      shadow: 10,
      space: 11,
      slotLead: 12,
      slotDefault: 13,
      slotTrail: 14,
      label: 0,
      labelledby: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppBar",
      options,
      id: create_fragment5.name
    });
  }
  get background() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get space() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set space(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotLead() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotLead(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotDefault() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotDefault(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotTrail() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotTrail(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppBar_default = AppBar;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/AppRail/AppRail.svelte
var file6 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\AppRail\\AppRail.svelte";
var get_trail_slot_changes3 = (dirty) => ({});
var get_trail_slot_context3 = (ctx) => ({});
var get_lead_slot_changes4 = (dirty) => ({});
var get_lead_slot_context4 = (ctx) => ({});
function create_fragment6(ctx) {
  let div3;
  let div0;
  let div0_class_value;
  let t0;
  let div1;
  let div1_class_value;
  let t1;
  let div2;
  let div2_class_value;
  let div3_class_value;
  let current;
  const lead_slot_template = ctx[12].lead;
  const lead_slot = create_slot(lead_slot_template, ctx, ctx[11], get_lead_slot_context4);
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  const trail_slot_template = ctx[12].trail;
  const trail_slot = create_slot(trail_slot_template, ctx, ctx[11], get_trail_slot_context3);
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      if (lead_slot)
        lead_slot.c();
      t0 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      div2 = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (lead_slot)
        lead_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (trail_slot)
        trail_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-bar-lead " + ctx[0]);
      add_location(div0, file6, 45, 1, 1619);
      attr_dev(div1, "class", div1_class_value = "app-bar-default " + ctx[1]);
      add_location(div1, file6, 47, 1, 1710);
      attr_dev(div2, "class", div2_class_value = "app-bar-trail " + ctx[2]);
      add_location(div2, file6, 49, 1, 1792);
      attr_dev(div3, "class", div3_class_value = "app-rail " + ctx[3]);
      add_location(div3, file6, 43, 0, 1560);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      if (lead_slot) {
        lead_slot.m(div0, null);
      }
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      if (trail_slot) {
        trail_slot.m(div2, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(lead_slot_template, ctx2[11], dirty, get_lead_slot_changes4),
            get_lead_slot_context4
          );
        }
      }
      if (!current || dirty & 1 && div0_class_value !== (div0_class_value = "app-bar-lead " + ctx2[0])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && div1_class_value !== (div1_class_value = "app-bar-default " + ctx2[1])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(trail_slot_template, ctx2[11], dirty, get_trail_slot_changes3),
            get_trail_slot_context3
          );
        }
      }
      if (!current || dirty & 4 && div2_class_value !== (div2_class_value = "app-bar-trail " + ctx2[2])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & 8 && div3_class_value !== (div3_class_value = "app-rail " + ctx2[3])) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      transition_in(default_slot, local);
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      transition_out(default_slot, local);
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (lead_slot)
        lead_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase4 = "grid grid-rows-[auto_1fr_auto] overflow-y-auto";
function instance6($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRail", slots, ["lead", "default", "trail"]);
  let { selected = writable(void 0) } = $$props;
  let { background = "bg-surface-100-800-token" } = $$props;
  let { active = "bg-primary-active-token" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { width = "w-[70px] sm:w-20" } = $$props;
  let { height = "h-full" } = $$props;
  let { gap = "gap-0" } = $$props;
  let { regionLead = "" } = $$props;
  let { regionDefault = "" } = $$props;
  let { regionTrail = "" } = $$props;
  setContext("selected", selected);
  setContext("active", active);
  setContext("hover", hover);
  $$self.$$set = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("background" in $$new_props)
      $$invalidate(5, background = $$new_props.background);
    if ("active" in $$new_props)
      $$invalidate(6, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(7, hover = $$new_props.hover);
    if ("width" in $$new_props)
      $$invalidate(8, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(9, height = $$new_props.height);
    if ("gap" in $$new_props)
      $$invalidate(10, gap = $$new_props.gap);
    if ("regionLead" in $$new_props)
      $$invalidate(0, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$new_props)
      $$invalidate(1, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$new_props)
      $$invalidate(2, regionTrail = $$new_props.regionTrail);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    writable,
    selected,
    background,
    active,
    hover,
    width,
    height,
    gap,
    regionLead,
    regionDefault,
    regionTrail,
    cBase: cBase4,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(4, selected = $$new_props.selected);
    if ("background" in $$props)
      $$invalidate(5, background = $$new_props.background);
    if ("active" in $$props)
      $$invalidate(6, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(7, hover = $$new_props.hover);
    if ("width" in $$props)
      $$invalidate(8, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(9, height = $$new_props.height);
    if ("gap" in $$props)
      $$invalidate(10, gap = $$new_props.gap);
    if ("regionLead" in $$props)
      $$invalidate(0, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$props)
      $$invalidate(1, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$props)
      $$invalidate(2, regionTrail = $$new_props.regionTrail);
    if ("classesBase" in $$props)
      $$invalidate(3, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classesBase = `${cBase4} ${background} ${width} ${height} ${gap} ${$$props.class || ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    regionLead,
    regionDefault,
    regionTrail,
    classesBase,
    selected,
    background,
    active,
    hover,
    width,
    height,
    gap,
    $$scope,
    slots
  ];
}
var AppRail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      selected: 4,
      background: 5,
      active: 6,
      hover: 7,
      width: 8,
      height: 9,
      gap: 10,
      regionLead: 0,
      regionDefault: 1,
      regionTrail: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRail",
      options,
      id: create_fragment6.name
    });
  }
  get selected() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionDefault() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionDefault(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionTrail() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionTrail(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRail_default = AppRail;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/AppRail/AppRailTile.svelte
var file7 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\AppRail\\AppRailTile.svelte";
function create_if_block5(ctx) {
  let div;
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, ctx[1]);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-rail-tile-label " + ctx[3]);
      add_location(div, file7, 56, 12, 1687);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
      if (dirty & 8 && div_class_value !== (div_class_value = "app-rail-tile-label " + ctx2[3])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(57:1) {#if label}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let div;
  let div_class_value;
  let t;
  let svelte_element_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  let if_block = ctx[1] && create_if_block5(ctx);
  let svelte_element_levels = [
    ctx[7](),
    {
      class: svelte_element_class_value = "app-rail-tile " + ctx[5]
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(ctx[0]);
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(nodes, (ctx[0] || "null").toUpperCase(), { class: true });
      var svelte_element_nodes = children(svelte_element);
      div = claim_element(svelte_element_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t = claim_space(svelte_element_nodes);
      if (if_block)
        if_block.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-rail-tile-icon " + ctx[2]);
      add_location(div, file7, 54, 1, 1599);
      if (/-/.test(ctx[0])) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file7, 44, 0, 1414);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(svelte_element, t);
      if (if_block)
        if_block.m(svelte_element, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(svelte_element, "click", ctx[6], false, false, false),
          listen_dev(svelte_element, "keydown", ctx[15], false, false, false),
          listen_dev(svelte_element, "keyup", ctx[16], false, false, false),
          listen_dev(svelte_element, "keypress", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "app-rail-tile-icon " + ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          if_block.m(svelte_element, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        ctx2[7](),
        (!current || dirty & 32 && svelte_element_class_value !== (svelte_element_class_value = "app-rail-tile " + ctx2[5])) && { class: svelte_element_class_value }
      ]);
      if (/-/.test(ctx2[0])) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: '(45:0) <svelte:element  this={tag}  {...prunedRestProps()}  class=\\"app-rail-tile {classesBase}\\"  on:click={onClickHandler}  on:keydown  on:keyup  on:keypress >',
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let previous_tag = ctx[0];
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(ctx[0]);
  validate_void_dynamic_element(ctx[0]);
  let svelte_element = ctx[0] && create_dynamic_element(ctx);
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(previous_tag, ctx2[0])) {
          svelte_element.d(1);
          validate_dynamic_element(ctx2[0]);
          validate_void_dynamic_element(ctx2[0]);
          svelte_element = create_dynamic_element(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = ctx2[0];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase5 = "grid place-content-center place-items-center w-full aspect-square space-y-1.5";
function instance7($$self, $$props, $$invalidate) {
  let classesActive;
  let classesBase;
  const omit_props_names = ["value", "tag", "label", "regionIcon", "regionLabel", "selected", "active", "hover"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selected, $$unsubscribe_selected = noop, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(12, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRailTile", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { value = void 0 } = $$props;
  let { tag = "button" } = $$props;
  let { label = "" } = $$props;
  let { regionIcon = "" } = $$props;
  let { regionLabel = "text-xs" } = $$props;
  let { selected = getContext("selected") } = $$props;
  validate_store(selected, "selected");
  $$subscribe_selected();
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  function onClickHandler(event) {
    dispatch("click", event);
    if (!$selected || !value)
      return;
    set_store_value(selected, $selected = value, $selected);
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(8, value = $$new_props.value);
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("regionIcon" in $$new_props)
      $$invalidate(2, regionIcon = $$new_props.regionIcon);
    if ("regionLabel" in $$new_props)
      $$invalidate(3, regionLabel = $$new_props.regionLabel);
    if ("selected" in $$new_props)
      $$subscribe_selected($$invalidate(4, selected = $$new_props.selected));
    if ("active" in $$new_props)
      $$invalidate(9, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    dispatch,
    value,
    tag,
    label,
    regionIcon,
    regionLabel,
    selected,
    active,
    hover,
    cBase: cBase5,
    onClickHandler,
    prunedRestProps,
    classesActive,
    classesBase,
    $selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(8, value = $$new_props.value);
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("regionIcon" in $$props)
      $$invalidate(2, regionIcon = $$new_props.regionIcon);
    if ("regionLabel" in $$props)
      $$invalidate(3, regionLabel = $$new_props.regionLabel);
    if ("selected" in $$props)
      $$subscribe_selected($$invalidate(4, selected = $$new_props.selected));
    if ("active" in $$props)
      $$invalidate(9, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("classesActive" in $$props)
      $$invalidate(11, classesActive = $$new_props.classesActive);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4864) {
      $:
        $$invalidate(11, classesActive = $selected && value && $selected === value ? `${active}` : "");
    }
    $:
      $$invalidate(5, classesBase = `${cBase5} ${hover} ${classesActive} ${$$props.class || ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    tag,
    label,
    regionIcon,
    regionLabel,
    selected,
    classesBase,
    onClickHandler,
    prunedRestProps,
    value,
    active,
    hover,
    classesActive,
    $selected,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var AppRailTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      value: 8,
      tag: 0,
      label: 1,
      regionIcon: 2,
      regionLabel: 3,
      selected: 4,
      active: 9,
      hover: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRailTile",
      options,
      id: create_fragment7.name
    });
  }
  get value() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionIcon() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionIcon(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRailTile_default = AppRailTile;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/AppShell/AppShell.svelte
var file8 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\AppShell\\AppShell.svelte";
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
var get_sidebarRight_slot_changes = (dirty) => ({});
var get_sidebarRight_slot_context = (ctx) => ({});
var get_pageFooter_slot_changes = (dirty) => ({});
var get_pageFooter_slot_context = (ctx) => ({});
var get_pageHeader_slot_changes = (dirty) => ({});
var get_pageHeader_slot_context = (ctx) => ({});
var get_sidebarLeft_slot_changes = (dirty) => ({});
var get_sidebarLeft_slot_context = (ctx) => ({});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_if_block_5(ctx) {
  let header;
  let header_class_value;
  let current;
  const header_slot_template = ctx[17].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[16], get_header_slot_context);
  const block = {
    c: function create() {
      header = element("header");
      if (header_slot)
        header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { id: true, class: true });
      var header_nodes = children(header);
      if (header_slot)
        header_slot.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "id", "shell-header");
      attr_dev(header, "class", header_class_value = "flex-none " + ctx[6]);
      add_location(header, file8, 43, 2, 2307);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (header_slot) {
        header_slot.m(header, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(header_slot_template, ctx2[16], dirty, get_header_slot_changes),
            get_header_slot_context
          );
        }
      }
      if (!current || dirty & 64 && header_class_value !== (header_class_value = "flex-none " + ctx2[6])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(43:1) {#if $$slots.header}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let aside;
  let current;
  const sidebarLeft_slot_template = ctx[17].sidebarLeft;
  const sidebarLeft_slot = create_slot(sidebarLeft_slot_template, ctx, ctx[16], get_sidebarLeft_slot_context);
  const block = {
    c: function create() {
      aside = element("aside");
      if (sidebarLeft_slot)
        sidebarLeft_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { id: true, class: true });
      var aside_nodes = children(aside);
      if (sidebarLeft_slot)
        sidebarLeft_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "id", "sidebar-left");
      attr_dev(aside, "class", ctx[5]);
      add_location(aside, file8, 50, 3, 2533);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (sidebarLeft_slot) {
        sidebarLeft_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (sidebarLeft_slot) {
        if (sidebarLeft_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            sidebarLeft_slot,
            sidebarLeft_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(sidebarLeft_slot_template, ctx2[16], dirty, get_sidebarLeft_slot_changes),
            get_sidebarLeft_slot_context
          );
        }
      }
      if (!current || dirty & 32) {
        attr_dev(aside, "class", ctx2[5]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarLeft_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarLeft_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      if (sidebarLeft_slot)
        sidebarLeft_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(50:2) {#if $$slots.sidebarLeft}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let header;
  let header_class_value;
  let current;
  const pageHeader_slot_template = ctx[17].pageHeader;
  const pageHeader_slot = create_slot(pageHeader_slot_template, ctx, ctx[16], get_pageHeader_slot_context);
  const pageHeader_slot_or_fallback = pageHeader_slot || fallback_block_12(ctx);
  const block = {
    c: function create() {
      header = element("header");
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { id: true, class: true });
      var header_nodes = children(header);
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "id", "page-header");
      attr_dev(header, "class", header_class_value = "flex-none " + ctx[3]);
      add_location(header, file8, 57, 4, 2740);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (pageHeader_slot_or_fallback) {
        pageHeader_slot_or_fallback.m(header, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (pageHeader_slot) {
        if (pageHeader_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            pageHeader_slot,
            pageHeader_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(pageHeader_slot_template, ctx2[16], dirty, get_pageHeader_slot_changes),
            get_pageHeader_slot_context
          );
        }
      }
      if (!current || dirty & 8 && header_class_value !== (header_class_value = "flex-none " + ctx2[3])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pageHeader_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pageHeader_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(57:3) {#if $$slots.pageHeader}",
    ctx
  });
  return block;
}
function fallback_block_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(slot:header)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(slot:header)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_12.name,
    type: "fallback",
    source: "(58:91) (slot:header)",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let footer;
  let footer_class_value;
  let current;
  const pageFooter_slot_template = ctx[17].pageFooter;
  const pageFooter_slot = create_slot(pageFooter_slot_template, ctx, ctx[16], get_pageFooter_slot_context);
  const pageFooter_slot_or_fallback = pageFooter_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      footer = element("footer");
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { id: true, class: true });
      var footer_nodes = children(footer);
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "id", "page-footer");
      attr_dev(footer, "class", footer_class_value = "flex-none " + ctx[1]);
      add_location(footer, file8, 65, 4, 3051);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      if (pageFooter_slot_or_fallback) {
        pageFooter_slot_or_fallback.m(footer, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (pageFooter_slot) {
        if (pageFooter_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            pageFooter_slot,
            pageFooter_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(pageFooter_slot_template, ctx2[16], dirty, get_pageFooter_slot_changes),
            get_pageFooter_slot_context
          );
        }
      }
      if (!current || dirty & 2 && footer_class_value !== (footer_class_value = "flex-none " + ctx2[1])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pageFooter_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pageFooter_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(65:3) {#if $$slots.pageFooter}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(slot:footer)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(slot:footer)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(66:91) (slot:footer)",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let aside;
  let current;
  const sidebarRight_slot_template = ctx[17].sidebarRight;
  const sidebarRight_slot = create_slot(sidebarRight_slot_template, ctx, ctx[16], get_sidebarRight_slot_context);
  const block = {
    c: function create() {
      aside = element("aside");
      if (sidebarRight_slot)
        sidebarRight_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { id: true, class: true });
      var aside_nodes = children(aside);
      if (sidebarRight_slot)
        sidebarRight_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "id", "sidebar-right");
      attr_dev(aside, "class", ctx[4]);
      add_location(aside, file8, 71, 3, 3252);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (sidebarRight_slot) {
        sidebarRight_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (sidebarRight_slot) {
        if (sidebarRight_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            sidebarRight_slot,
            sidebarRight_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(sidebarRight_slot_template, ctx2[16], dirty, get_sidebarRight_slot_changes),
            get_sidebarRight_slot_context
          );
        }
      }
      if (!current || dirty & 16) {
        attr_dev(aside, "class", ctx2[4]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarRight_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarRight_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(aside);
      if (sidebarRight_slot)
        sidebarRight_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(71:2) {#if $$slots.sidebarRight}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let footer;
  let footer_class_value;
  let current;
  const footer_slot_template = ctx[17].footer;
  const footer_slot = create_slot(footer_slot_template, ctx, ctx[16], get_footer_slot_context);
  const block = {
    c: function create() {
      footer = element("footer");
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { id: true, class: true });
      var footer_nodes = children(footer);
      if (footer_slot)
        footer_slot.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "id", "shell-footer");
      attr_dev(footer, "class", footer_class_value = "flex-none " + ctx[0]);
      add_location(footer, file8, 77, 2, 3407);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      if (footer_slot) {
        footer_slot.m(footer, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(footer_slot_template, ctx2[16], dirty, get_footer_slot_changes),
            get_footer_slot_context
          );
        }
      }
      if (!current || dirty & 1 && footer_class_value !== (footer_class_value = "flex-none " + ctx2[0])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(77:1) {#if $$slots.footer}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let main;
  let t0;
  let div2;
  let t1;
  let div1;
  let t2;
  let div0;
  let div0_class_value;
  let t3;
  let t4;
  let div2_class_value;
  let t5;
  let current;
  let if_block0 = ctx[8].header && create_if_block_5(ctx);
  let if_block1 = ctx[8].sidebarLeft && create_if_block_42(ctx);
  let if_block2 = ctx[8].pageHeader && create_if_block_32(ctx);
  const default_slot_template = ctx[17].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[16], null);
  let if_block3 = ctx[8].pageFooter && create_if_block_22(ctx);
  let if_block4 = ctx[8].sidebarRight && create_if_block_14(ctx);
  let if_block5 = ctx[8].footer && create_if_block6(ctx);
  const block = {
    c: function create() {
      main = element("main");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      if (if_block2)
        if_block2.c();
      t2 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      this.h();
    },
    l: function claim(nodes) {
      main = claim_element(nodes, "MAIN", {
        id: true,
        class: true,
        "data-testid": true
      });
      var main_nodes = children(main);
      if (if_block0)
        if_block0.l(main_nodes);
      t0 = claim_space(main_nodes);
      div2 = claim_element(main_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block1)
        if_block1.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { id: true, class: true });
      var div1_nodes = children(div1);
      if (if_block2)
        if_block2.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t3 = claim_space(div1_nodes);
      if (if_block3)
        if_block3.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t4 = claim_space(div2_nodes);
      if (if_block4)
        if_block4.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      t5 = claim_space(main_nodes);
      if (if_block5)
        if_block5.l(main_nodes);
      main_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "id", "page-content");
      attr_dev(div0, "class", div0_class_value = "flex-auto " + ctx[2]);
      add_location(div0, file8, 61, 3, 2911);
      attr_dev(div1, "id", "page");
      attr_dev(div1, "class", cPage);
      add_location(div1, file8, 54, 2, 2648);
      attr_dev(div2, "class", div2_class_value = "flex-auto " + cContentArea);
      add_location(div2, file8, 47, 1, 2431);
      attr_dev(main, "id", "appShell");
      attr_dev(main, "class", ctx[7]);
      attr_dev(main, "data-testid", "app-shell");
      add_location(main, file8, 40, 0, 2195);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, main, anchor);
      if (if_block0)
        if_block0.m(main, null);
      append_hydration_dev(main, t0);
      append_hydration_dev(main, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (if_block2)
        if_block2.m(div1, null);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div1, t3);
      if (if_block3)
        if_block3.m(div1, null);
      append_hydration_dev(div2, t4);
      if (if_block4)
        if_block4.m(div2, null);
      append_hydration_dev(main, t5);
      if (if_block5)
        if_block5.m(main, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[8].header) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(main, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[8].sidebarLeft) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_42(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[8].pageHeader) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_32(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(default_slot_template, ctx2[16], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4 && div0_class_value !== (div0_class_value = "flex-auto " + ctx2[2])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (ctx2[8].pageFooter) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_22(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[8].sidebarRight) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_14(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (ctx2[8].footer) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block6(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(main, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (!current || dirty & 128) {
        attr_dev(main, "class", ctx2[7]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(default_slot, local);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(default_slot, local);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(main);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBaseAppShell = "w-full h-full flex flex-col overflow-hidden";
var cContentArea = "w-full h-full flex overflow-hidden";
var cPage = "flex-1 overflow-x-hidden overflow-y-auto flex flex-col";
var cSidebarLeft = "flex-none overflow-x-hidden overflow-y-auto";
var cSidebarRight = "flex-none overflow-x-hidden overflow-y-auto";
function instance8($$self, $$props, $$invalidate) {
  let classesBase;
  let classesheader;
  let classesSidebarLeft;
  let classesSidebarRight;
  let classesPageHeader;
  let classesPageContent;
  let classesPageFooter;
  let classesFooter;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppShell", slots, [
    "header",
    "sidebarLeft",
    "pageHeader",
    "default",
    "pageFooter",
    "sidebarRight",
    "footer"
  ]);
  const $$slots = compute_slots(slots);
  let { slotHeader = "z-10" } = $$props;
  let { slotSidebarLeft = "w-auto" } = $$props;
  let { slotSidebarRight = "w-auto" } = $$props;
  let { slotPageHeader = "" } = $$props;
  let { slotPageContent = "" } = $$props;
  let { slotPageFooter = "" } = $$props;
  let { slotFooter = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("slotHeader" in $$new_props)
      $$invalidate(9, slotHeader = $$new_props.slotHeader);
    if ("slotSidebarLeft" in $$new_props)
      $$invalidate(10, slotSidebarLeft = $$new_props.slotSidebarLeft);
    if ("slotSidebarRight" in $$new_props)
      $$invalidate(11, slotSidebarRight = $$new_props.slotSidebarRight);
    if ("slotPageHeader" in $$new_props)
      $$invalidate(12, slotPageHeader = $$new_props.slotPageHeader);
    if ("slotPageContent" in $$new_props)
      $$invalidate(13, slotPageContent = $$new_props.slotPageContent);
    if ("slotPageFooter" in $$new_props)
      $$invalidate(14, slotPageFooter = $$new_props.slotPageFooter);
    if ("slotFooter" in $$new_props)
      $$invalidate(15, slotFooter = $$new_props.slotFooter);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    slotHeader,
    slotSidebarLeft,
    slotSidebarRight,
    slotPageHeader,
    slotPageContent,
    slotPageFooter,
    slotFooter,
    cBaseAppShell,
    cContentArea,
    cPage,
    cSidebarLeft,
    cSidebarRight,
    classesFooter,
    classesPageFooter,
    classesPageContent,
    classesPageHeader,
    classesSidebarRight,
    classesSidebarLeft,
    classesheader,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("slotHeader" in $$props)
      $$invalidate(9, slotHeader = $$new_props.slotHeader);
    if ("slotSidebarLeft" in $$props)
      $$invalidate(10, slotSidebarLeft = $$new_props.slotSidebarLeft);
    if ("slotSidebarRight" in $$props)
      $$invalidate(11, slotSidebarRight = $$new_props.slotSidebarRight);
    if ("slotPageHeader" in $$props)
      $$invalidate(12, slotPageHeader = $$new_props.slotPageHeader);
    if ("slotPageContent" in $$props)
      $$invalidate(13, slotPageContent = $$new_props.slotPageContent);
    if ("slotPageFooter" in $$props)
      $$invalidate(14, slotPageFooter = $$new_props.slotPageFooter);
    if ("slotFooter" in $$props)
      $$invalidate(15, slotFooter = $$new_props.slotFooter);
    if ("classesFooter" in $$props)
      $$invalidate(0, classesFooter = $$new_props.classesFooter);
    if ("classesPageFooter" in $$props)
      $$invalidate(1, classesPageFooter = $$new_props.classesPageFooter);
    if ("classesPageContent" in $$props)
      $$invalidate(2, classesPageContent = $$new_props.classesPageContent);
    if ("classesPageHeader" in $$props)
      $$invalidate(3, classesPageHeader = $$new_props.classesPageHeader);
    if ("classesSidebarRight" in $$props)
      $$invalidate(4, classesSidebarRight = $$new_props.classesSidebarRight);
    if ("classesSidebarLeft" in $$props)
      $$invalidate(5, classesSidebarLeft = $$new_props.classesSidebarLeft);
    if ("classesheader" in $$props)
      $$invalidate(6, classesheader = $$new_props.classesheader);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesBase = `${cBaseAppShell} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(6, classesheader = `${slotHeader}`);
    }
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(5, classesSidebarLeft = `${cSidebarLeft} ${slotSidebarLeft}`);
    }
    if ($$self.$$.dirty & 2048) {
      $:
        $$invalidate(4, classesSidebarRight = `${cSidebarRight} ${slotSidebarRight}`);
    }
    if ($$self.$$.dirty & 4096) {
      $:
        $$invalidate(3, classesPageHeader = `${slotPageHeader}`);
    }
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(2, classesPageContent = `${slotPageContent}`);
    }
    if ($$self.$$.dirty & 16384) {
      $:
        $$invalidate(1, classesPageFooter = `${slotPageFooter}`);
    }
    if ($$self.$$.dirty & 32768) {
      $:
        $$invalidate(0, classesFooter = `${slotFooter}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    classesFooter,
    classesPageFooter,
    classesPageContent,
    classesPageHeader,
    classesSidebarRight,
    classesSidebarLeft,
    classesheader,
    classesBase,
    $$slots,
    slotHeader,
    slotSidebarLeft,
    slotSidebarRight,
    slotPageHeader,
    slotPageContent,
    slotPageFooter,
    slotFooter,
    $$scope,
    slots
  ];
}
var AppShell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      slotHeader: 9,
      slotSidebarLeft: 10,
      slotSidebarRight: 11,
      slotPageHeader: 12,
      slotPageContent: 13,
      slotPageFooter: 14,
      slotFooter: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppShell",
      options,
      id: create_fragment8.name
    });
  }
  get slotHeader() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotHeader(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotSidebarLeft() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotSidebarLeft(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotSidebarRight() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotSidebarRight(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageHeader() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageHeader(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageContent() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageContent(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageFooter() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageFooter(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotFooter() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotFooter(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppShell_default = AppShell;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Avatar/Avatar.svelte
var file9 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Avatar\\Avatar.svelte";
function create_else_block2(ctx) {
  let svg;
  let text_1;
  let t_value = String(ctx[0]).substring(0, 2).toUpperCase() + "";
  let t;
  let text_1_font_size_value;
  let text_1_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      text_1 = svg_element("text");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, viewBox: true });
      var svg_nodes = children(svg);
      text_1 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        "dominant-baseline": true,
        "font-weight": true,
        "font-size": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      t = claim_text(text_1_nodes, t_value);
      text_1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", "50%");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "font-weight", "bold");
      attr_dev(text_1, "font-size", text_1_font_size_value = 150);
      attr_dev(text_1, "class", text_1_class_value = "avatar-text " + ctx[1]);
      add_location(text_1, file9, 40, 3, 1607);
      attr_dev(svg, "class", "avatar-initials w-full h-full");
      attr_dev(svg, "viewBox", "0 0 512 512");
      add_location(svg, file9, 39, 2, 1538);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, text_1);
      append_hydration_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = String(ctx2[0]).substring(0, 2).toUpperCase() + ""))
        set_data_dev(t, t_value);
      if (dirty & 2 && text_1_class_value !== (text_1_class_value = "avatar-text " + ctx2[1])) {
        attr_dev(text_1, "class", text_1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(39:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let img;
  let img_class_value;
  let img_src_value;
  let img_alt_value;
  let action_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(img, "class", img_class_value = "avatar-image " + ctx[6]);
      if (!src_url_equal(img.src, img_src_value = ctx[2]))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", img_alt_value = ctx[7].alt || "");
      add_location(img, file9, 37, 2, 1433);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      if (!mounted) {
        dispose = action_destroyer(action_action = ctx[3].call(null, img, ctx[4]));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && !src_url_equal(img.src, img_src_value = ctx2[2])) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty & 128 && img_alt_value !== (img_alt_value = ctx2[7].alt || "")) {
        attr_dev(img, "alt", img_alt_value);
      }
      if (action_action && is_function(action_action.update) && dirty & 16)
        action_action.update.call(null, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(37:1) {#if src}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let figure;
  let figure_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block7;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      figure = element("figure");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", { class: true, "data-testid": true });
      var figure_nodes = children(figure);
      if_block.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figure, "class", figure_class_value = "avatar " + ctx[5]);
      attr_dev(figure, "data-testid", "avatar");
      add_location(figure, file9, 35, 0, 1320);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      if_block.m(figure, null);
      if (!mounted) {
        dispose = [
          listen_dev(figure, "click", ctx[14], false, false, false),
          listen_dev(figure, "keydown", ctx[15], false, false, false),
          listen_dev(figure, "keyup", ctx[16], false, false, false),
          listen_dev(figure, "keypress", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(figure, null);
        }
      }
      if (dirty & 32 && figure_class_value !== (figure_class_value = "avatar " + ctx2[5])) {
        attr_dev(figure, "class", figure_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figure);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Avatar", slots, []);
  let { background = "bg-surface-400-500-token" } = $$props;
  let { width = "w-12" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "rounded-full" } = $$props;
  let { shadow = "" } = $$props;
  let { cursor = "" } = $$props;
  let { initials = "AB" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { src = "" } = $$props;
  let { action = () => {
  } } = $$props;
  let { actionParams = "" } = $$props;
  let cBase22 = "flex aspect-square text-surface-50 font-semibold justify-center items-center overflow-hidden isolate";
  let cImage = "w-full h-full object-cover";
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("background" in $$new_props)
      $$invalidate(8, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(9, width = $$new_props.width);
    if ("border" in $$new_props)
      $$invalidate(10, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(12, shadow = $$new_props.shadow);
    if ("cursor" in $$new_props)
      $$invalidate(13, cursor = $$new_props.cursor);
    if ("initials" in $$new_props)
      $$invalidate(0, initials = $$new_props.initials);
    if ("fill" in $$new_props)
      $$invalidate(1, fill = $$new_props.fill);
    if ("src" in $$new_props)
      $$invalidate(2, src = $$new_props.src);
    if ("action" in $$new_props)
      $$invalidate(3, action = $$new_props.action);
    if ("actionParams" in $$new_props)
      $$invalidate(4, actionParams = $$new_props.actionParams);
  };
  $$self.$capture_state = () => ({
    background,
    width,
    border,
    rounded,
    shadow,
    cursor,
    initials,
    fill,
    src,
    action,
    actionParams,
    cBase: cBase22,
    cImage,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("background" in $$props)
      $$invalidate(8, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(9, width = $$new_props.width);
    if ("border" in $$props)
      $$invalidate(10, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(12, shadow = $$new_props.shadow);
    if ("cursor" in $$props)
      $$invalidate(13, cursor = $$new_props.cursor);
    if ("initials" in $$props)
      $$invalidate(0, initials = $$new_props.initials);
    if ("fill" in $$props)
      $$invalidate(1, fill = $$new_props.fill);
    if ("src" in $$props)
      $$invalidate(2, src = $$new_props.src);
    if ("action" in $$props)
      $$invalidate(3, action = $$new_props.action);
    if ("actionParams" in $$props)
      $$invalidate(4, actionParams = $$new_props.actionParams);
    if ("cBase" in $$props)
      $$invalidate(18, cBase22 = $$new_props.cBase);
    if ("cImage" in $$props)
      $$invalidate(6, cImage = $$new_props.cImage);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classesBase = `${cBase22} ${background} ${width} ${border} ${rounded} ${shadow} ${cursor} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    initials,
    fill,
    src,
    action,
    actionParams,
    classesBase,
    cImage,
    $$props,
    background,
    width,
    border,
    rounded,
    shadow,
    cursor,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var Avatar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      background: 8,
      width: 9,
      border: 10,
      rounded: 11,
      shadow: 12,
      cursor: 13,
      initials: 0,
      fill: 1,
      src: 2,
      action: 3,
      actionParams: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Avatar",
      options,
      id: create_fragment9.name
    });
  }
  get background() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cursor() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cursor(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initials() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initials(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set action(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actionParams() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actionParams(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Avatar_default = Avatar;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Breadcrumb/Breadcrumb.svelte
var file10 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Breadcrumb\\Breadcrumb.svelte";
function create_fragment10(ctx) {
  let nav;
  let ol;
  let ol_class_value;
  let nav_class_value;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      nav = element("nav");
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", {
        class: true,
        "data-testid": true,
        "aria-label": true
      });
      var nav_nodes = children(nav);
      ol = claim_element(nav_nodes, "OL", { class: true });
      var ol_nodes = children(ol);
      if (default_slot)
        default_slot.l(ol_nodes);
      ol_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ol, "class", ol_class_value = "breadcrumb-list " + ctx[1]);
      add_location(ol, file10, 20, 1, 622);
      attr_dev(nav, "class", nav_class_value = "breadcrumb " + ctx[2]);
      attr_dev(nav, "data-testid", "breadcrumb");
      attr_dev(nav, "aria-label", ctx[0]);
      add_location(nav, file10, 19, 0, 538);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ol);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && ol_class_value !== (ol_class_value = "breadcrumb-list " + ctx2[1])) {
        attr_dev(ol, "class", ol_class_value);
      }
      if (!current || dirty & 4 && nav_class_value !== (nav_class_value = "breadcrumb " + ctx2[2])) {
        attr_dev(nav, "class", nav_class_value);
      }
      if (!current || dirty & 1) {
        attr_dev(nav, "aria-label", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase6 = "";
var cList = "flex align-center space-x-4";
function instance10($$self, $$props, $$invalidate) {
  let classesBase;
  let classesList;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumb", slots, ["default"]);
  let { separator = "&rsaquo;" } = $$props;
  let { text: text2 = "" } = $$props;
  let { label = "breadcrumb" } = $$props;
  setContext("separator", separator);
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("separator" in $$new_props)
      $$invalidate(3, separator = $$new_props.separator);
    if ("text" in $$new_props)
      $$invalidate(4, text2 = $$new_props.text);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    separator,
    text: text2,
    label,
    cBase: cBase6,
    cList,
    classesList,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("separator" in $$props)
      $$invalidate(3, separator = $$new_props.separator);
    if ("text" in $$props)
      $$invalidate(4, text2 = $$new_props.text);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("classesList" in $$props)
      $$invalidate(1, classesList = $$new_props.classesList);
    if ("classesBase" in $$props)
      $$invalidate(2, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(2, classesBase = `${cBase6} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(1, classesList = `${cList} ${text2}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [label, classesList, classesBase, separator, text2, $$scope, slots];
}
var Breadcrumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { separator: 3, text: 4, label: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumb",
      options,
      id: create_fragment10.name
    });
  }
  get separator() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set separator(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumb_default = Breadcrumb;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Breadcrumb/Crumb.svelte
var file11 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Breadcrumb\\Crumb.svelte";
var get_lead_slot_changes5 = (dirty) => ({});
var get_lead_slot_context5 = (ctx) => ({});
function create_if_block_15(ctx) {
  let span;
  let current;
  const lead_slot_template = ctx[7].lead;
  const lead_slot = create_slot(lead_slot_template, ctx, ctx[6], get_lead_slot_context5);
  const block = {
    c: function create() {
      span = element("span");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (lead_slot)
        lead_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "crumb-lead");
      add_location(span, file11, 27, 20, 855);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (lead_slot) {
        lead_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(lead_slot_template, ctx2[6], dirty, get_lead_slot_changes5),
            get_lead_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(28:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_dynamic_element2(ctx) {
  let svelte_element;
  let t;
  let span;
  let svelte_element_href_value;
  let svelte_element_class_value;
  let svelte_element_aria_current_value;
  let current;
  let if_block = ctx[4].lead && create_if_block_15(ctx);
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let svelte_element_levels = [
    {
      href: svelte_element_href_value = ctx[3].href
    },
    {
      class: svelte_element_class_value = "crumb-anchor " + cAnchor
    },
    { "data-testid": "crumb-anchor" },
    {
      "aria-current": svelte_element_aria_current_value = !ctx[3].href ? "page" : void 0
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(ctx[2]);
      if (if_block)
        if_block.c();
      t = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(nodes, (ctx[2] || "null").toUpperCase(), {
        href: true,
        class: true,
        "data-testid": true,
        "aria-current": true
      });
      var svelte_element_nodes = children(svelte_element);
      if (if_block)
        if_block.l(svelte_element_nodes);
      t = claim_space(svelte_element_nodes);
      span = claim_element(svelte_element_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "crumb-text");
      add_location(span, file11, 28, 2, 915);
      if (/-/.test(ctx[2])) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file11, 20, 1, 667);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (if_block)
        if_block.m(svelte_element, null);
      append_hydration_dev(svelte_element, t);
      append_hydration_dev(svelte_element, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[4].lead) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(svelte_element, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & 8 && svelte_element_href_value !== (svelte_element_href_value = ctx2[3].href)) && { href: svelte_element_href_value },
        { class: svelte_element_class_value },
        { "data-testid": "crumb-anchor" },
        (!current || dirty & 8 && svelte_element_aria_current_value !== (svelte_element_aria_current_value = !ctx2[3].href ? "page" : void 0)) && {
          "aria-current": svelte_element_aria_current_value
        }
      ]);
      if (/-/.test(ctx2[2])) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element2.name,
    type: "child_dynamic_element",
    source: `(21:1) <svelte:element   this={tag}   href={$$props.href}   class=\\"crumb-anchor {cAnchor}\\"   data-testid=\\"crumb-anchor\\"   aria-current={!$$props.href ? 'page' : undefined}  >`,
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "crumb-seperator " + cSeperator);
      add_location(div, file11, 32, 2, 1017);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      div.innerHTML = ctx[0];
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        div.innerHTML = ctx2[0];
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(32:1) {#if $$props.href}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let li;
  let previous_tag = ctx[2];
  let t1;
  let li_class_value;
  let current;
  validate_dynamic_element(ctx[2]);
  validate_void_dynamic_element(ctx[2]);
  let svelte_element = ctx[2] && create_dynamic_element2(ctx);
  let if_block1 = ctx[3].href && create_if_block8(ctx);
  const block = {
    c: function create() {
      li = element("li");
      if (svelte_element)
        svelte_element.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true, "data-testid": true });
      var li_nodes = children(li);
      if (svelte_element)
        svelte_element.l(li_nodes);
      t1 = claim_space(li_nodes);
      if (if_block1)
        if_block1.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", li_class_value = "crumb " + ctx[1]);
      attr_dev(li, "data-testid", "crumb");
      add_location(li, file11, 18, 0, 596);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (svelte_element)
        svelte_element.m(li, null);
      append_hydration_dev(li, t1);
      if (if_block1)
        if_block1.m(li, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[2]) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element2(ctx2);
          svelte_element.c();
          svelte_element.m(li, t1);
        } else if (safe_not_equal(previous_tag, ctx2[2])) {
          svelte_element.d(1);
          validate_dynamic_element(ctx2[2]);
          validate_void_dynamic_element(ctx2[2]);
          svelte_element = create_dynamic_element2(ctx2);
          svelte_element.c();
          svelte_element.m(li, t1);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = ctx2[2];
      if (ctx2[3].href) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block8(ctx2);
          if_block1.c();
          if_block1.m(li, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 2 && li_class_value !== (li_class_value = "crumb " + ctx2[1])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (svelte_element)
        svelte_element.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase7 = "flex items-center space-x-4";
var cAnchor = "flex justify-center items-center space-x-2";
var cSeperator = "font-bold flex fill-surface-500 text-surface-500 w-2";
function instance11($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Crumb", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { color = "" } = $$props;
  let { separator = getContext("separator") } = $$props;
  const tag = $$props.href ? "a" : "span";
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("separator" in $$new_props)
      $$invalidate(0, separator = $$new_props.separator);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    color,
    separator,
    tag,
    cBase: cBase7,
    cAnchor,
    cSeperator,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("separator" in $$props)
      $$invalidate(0, separator = $$new_props.separator);
    if ("classesBase" in $$props)
      $$invalidate(1, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classesBase = `${cBase7} ${color} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [separator, classesBase, tag, $$props, $$slots, color, $$scope, slots];
}
var Crumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { color: 5, separator: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Crumb",
      options,
      id: create_fragment11.name
    });
  }
  get color() {
    throw new Error("<Crumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Crumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get separator() {
    throw new Error("<Crumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set separator(value) {
    throw new Error("<Crumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Crumb_default = Crumb;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/tailwind/colors.js
var tailwindDefaultColors = [
  {
    label: "slate",
    shades: {
      "50": { hex: "#f8fafc", rgb: "248 250 252" },
      "100": { hex: "#f1f5f9", rgb: "241 245 249" },
      "200": { hex: "#e2e8f0", rgb: "226 232 240" },
      "300": { hex: "#cbd5e1", rgb: "203 213 225" },
      "400": { hex: "#94a3b8", rgb: "148 163 184" },
      "500": { hex: "#64748b", rgb: "100 116 139" },
      "600": { hex: "#475569", rgb: "71 85 105" },
      "700": { hex: "#334155", rgb: "51 65 85" },
      "800": { hex: "#1e293b", rgb: "30 41 59" },
      "900": { hex: "#0f172a", rgb: "15 23 42" }
    }
  },
  {
    label: "gray",
    shades: {
      "50": { hex: "#f9fafb", rgb: "249 250 251" },
      "100": { hex: "#f3f4f6", rgb: "243 244 246" },
      "200": { hex: "#e5e7eb", rgb: "229 231 235" },
      "300": { hex: "#d1d5db", rgb: "209 213 219" },
      "400": { hex: "#9ca3af", rgb: "156 163 175" },
      "500": { hex: "#6b7280", rgb: "107 114 128" },
      "600": { hex: "#4b5563", rgb: "75 85 99" },
      "700": { hex: "#374151", rgb: "55 65 81" },
      "800": { hex: "#1f2937", rgb: "31 41 55" },
      "900": { hex: "#111827", rgb: "17 24 39" }
    }
  },
  {
    label: "zinc",
    shades: {
      "50": { hex: "#fafafa", rgb: "250 250 250" },
      "100": { hex: "#f4f4f5", rgb: "244 244 245" },
      "200": { hex: "#e4e4e7", rgb: "228 228 231" },
      "300": { hex: "#d4d4d8", rgb: "212 212 216" },
      "400": { hex: "#a1a1aa", rgb: "161 161 170" },
      "500": { hex: "#71717a", rgb: "113 113 122" },
      "600": { hex: "#52525b", rgb: "82 82 91" },
      "700": { hex: "#3f3f46", rgb: "63 63 70" },
      "800": { hex: "#27272a", rgb: "39 39 42" },
      "900": { hex: "#18181b", rgb: "24 24 27" }
    }
  },
  {
    label: "neutral",
    shades: {
      "50": { hex: "#fafafa", rgb: "250 250 250" },
      "100": { hex: "#f5f5f5", rgb: "245 245 245" },
      "200": { hex: "#e5e5e5", rgb: "229 229 229" },
      "300": { hex: "#d4d4d4", rgb: "212 212 212" },
      "400": { hex: "#a3a3a3", rgb: "163 163 163" },
      "500": { hex: "#737373", rgb: "115 115 115" },
      "600": { hex: "#525252", rgb: "82 82 82" },
      "700": { hex: "#404040", rgb: "64 64 64" },
      "800": { hex: "#262626", rgb: "38 38 38" },
      "900": { hex: "#171717", rgb: "23 23 23" }
    }
  },
  {
    label: "stone",
    shades: {
      "50": { hex: "#fafaf9", rgb: "250 250 249" },
      "100": { hex: "#f5f5f4", rgb: "245 245 244" },
      "200": { hex: "#e7e5e4", rgb: "231 229 228" },
      "300": { hex: "#d6d3d1", rgb: "214 211 209" },
      "400": { hex: "#a8a29e", rgb: "168 162 158" },
      "500": { hex: "#78716c", rgb: "120 113 108" },
      "600": { hex: "#57534e", rgb: "87 83 78" },
      "700": { hex: "#44403c", rgb: "68 64 60" },
      "800": { hex: "#292524", rgb: "41 37 36" },
      "900": { hex: "#1c1917", rgb: "28 25 23" }
    }
  },
  {
    label: "red",
    shades: {
      "50": { hex: "#fef2f2", rgb: "254 242 242" },
      "100": { hex: "#fee2e2", rgb: "254 226 226" },
      "200": { hex: "#fecaca", rgb: "254 202 202" },
      "300": { hex: "#fca5a5", rgb: "252 165 165" },
      "400": { hex: "#f87171", rgb: "248 113 113" },
      "500": { hex: "#ef4444", rgb: "239 68 68" },
      "600": { hex: "#dc2626", rgb: "220 38 38" },
      "700": { hex: "#b91c1c", rgb: "185 28 28" },
      "800": { hex: "#991b1b", rgb: "153 27 27" },
      "900": { hex: "#7f1d1d", rgb: "127 29 29" }
    }
  },
  {
    label: "orange",
    shades: {
      "50": { hex: "#fff7ed", rgb: "255 247 237" },
      "100": { hex: "#ffedd5", rgb: "255 237 213" },
      "200": { hex: "#fed7aa", rgb: "254 215 170" },
      "300": { hex: "#fdba74", rgb: "253 186 116" },
      "400": { hex: "#fb923c", rgb: "251 146 60" },
      "500": { hex: "#f97316", rgb: "249 115 22" },
      "600": { hex: "#ea580c", rgb: "234 88 12" },
      "700": { hex: "#c2410c", rgb: "194 65 12" },
      "800": { hex: "#9a3412", rgb: "154 52 18" },
      "900": { hex: "#7c2d12", rgb: "124 45 18" }
    }
  },
  {
    label: "amber",
    shades: {
      "50": { hex: "#fffbeb", rgb: "255 251 235" },
      "100": { hex: "#fef3c7", rgb: "254 243 199" },
      "200": { hex: "#fde68a", rgb: "253 230 138" },
      "300": { hex: "#fcd34d", rgb: "252 211 77" },
      "400": { hex: "#fbbf24", rgb: "251 191 36" },
      "500": { hex: "#f59e0b", rgb: "245 158 11" },
      "600": { hex: "#d97706", rgb: "217 119 6" },
      "700": { hex: "#b45309", rgb: "180 83 9" },
      "800": { hex: "#92400e", rgb: "146 64 14" },
      "900": { hex: "#78350f", rgb: "120 53 15" }
    }
  },
  {
    label: "yellow",
    shades: {
      "50": { hex: "#fefce8", rgb: "254 252 232" },
      "100": { hex: "#fef9c3", rgb: "254 249 195" },
      "200": { hex: "#fef08a", rgb: "254 240 138" },
      "300": { hex: "#fde047", rgb: "253 224 71" },
      "400": { hex: "#facc15", rgb: "250 204 21" },
      "500": { hex: "#eab308", rgb: "234 179 8" },
      "600": { hex: "#ca8a04", rgb: "202 138 4" },
      "700": { hex: "#a16207", rgb: "161 98 7" },
      "800": { hex: "#854d0e", rgb: "133 77 14" },
      "900": { hex: "#713f12", rgb: "113 63 18" }
    }
  },
  {
    label: "lime",
    shades: {
      "50": { hex: "#f7fee7", rgb: "247 254 231" },
      "100": { hex: "#ecfccb", rgb: "236 252 203" },
      "200": { hex: "#d9f99d", rgb: "217 249 157" },
      "300": { hex: "#bef264", rgb: "190 242 100" },
      "400": { hex: "#a3e635", rgb: "163 230 53" },
      "500": { hex: "#84cc16", rgb: "132 204 22" },
      "600": { hex: "#65a30d", rgb: "101 163 13" },
      "700": { hex: "#4d7c0f", rgb: "77 124 15" },
      "800": { hex: "#3f6212", rgb: "63 98 18" },
      "900": { hex: "#365314", rgb: "54 83 20" }
    }
  },
  {
    label: "green",
    shades: {
      "50": { hex: "#f0fdf4", rgb: "240 253 244" },
      "100": { hex: "#dcfce7", rgb: "220 252 231" },
      "200": { hex: "#bbf7d0", rgb: "187 247 208" },
      "300": { hex: "#86efac", rgb: "134 239 172" },
      "400": { hex: "#4ade80", rgb: "74 222 128" },
      "500": { hex: "#22c55e", rgb: "34 197 94" },
      "600": { hex: "#16a34a", rgb: "22 163 74" },
      "700": { hex: "#15803d", rgb: "21 128 61" },
      "800": { hex: "#166534", rgb: "22 101 52" },
      "900": { hex: "#14532d", rgb: "20 83 45" }
    }
  },
  {
    label: "emerald",
    shades: {
      "50": { hex: "#ecfdf5", rgb: "236 253 245" },
      "100": { hex: "#d1fae5", rgb: "209 250 229" },
      "200": { hex: "#a7f3d0", rgb: "167 243 208" },
      "300": { hex: "#6ee7b7", rgb: "110 231 183" },
      "400": { hex: "#34d399", rgb: "52 211 153" },
      "500": { hex: "#10b981", rgb: "16 185 129" },
      "600": { hex: "#059669", rgb: "5 150 105" },
      "700": { hex: "#047857", rgb: "4 120 87" },
      "800": { hex: "#065f46", rgb: "6 95 70" },
      "900": { hex: "#064e3b", rgb: "6 78 59" }
    }
  },
  {
    label: "teal",
    shades: {
      "50": { hex: "#f0fdfa", rgb: "240 253 250" },
      "100": { hex: "#ccfbf1", rgb: "204 251 241" },
      "200": { hex: "#99f6e4", rgb: "153 246 228" },
      "300": { hex: "#5eead4", rgb: "94 234 212" },
      "400": { hex: "#2dd4bf", rgb: "45 212 191" },
      "500": { hex: "#14b8a6", rgb: "20 184 166" },
      "600": { hex: "#0d9488", rgb: "13 148 136" },
      "700": { hex: "#0f766e", rgb: "15 118 110" },
      "800": { hex: "#115e59", rgb: "17 94 89" },
      "900": { hex: "#134e4a", rgb: "19 78 74" }
    }
  },
  {
    label: "cyan",
    shades: {
      "50": { hex: "#ecfeff", rgb: "236 254 255" },
      "100": { hex: "#cffafe", rgb: "207 250 254" },
      "200": { hex: "#a5f3fc", rgb: "165 243 252" },
      "300": { hex: "#67e8f9", rgb: "103 232 249" },
      "400": { hex: "#22d3ee", rgb: "34 211 238" },
      "500": { hex: "#06b6d4", rgb: "6 182 212" },
      "600": { hex: "#0891b2", rgb: "8 145 178" },
      "700": { hex: "#0e7490", rgb: "14 116 144" },
      "800": { hex: "#155e75", rgb: "21 94 117" },
      "900": { hex: "#164e63", rgb: "22 78 99" }
    }
  },
  {
    label: "sky",
    shades: {
      "50": { hex: "#f0f9ff", rgb: "240 249 255" },
      "100": { hex: "#e0f2fe", rgb: "224 242 254" },
      "200": { hex: "#bae6fd", rgb: "186 230 253" },
      "300": { hex: "#7dd3fc", rgb: "125 211 252" },
      "400": { hex: "#38bdf8", rgb: "56 189 248" },
      "500": { hex: "#0ea5e9", rgb: "14 165 233" },
      "600": { hex: "#0284c7", rgb: "2 132 199" },
      "700": { hex: "#0369a1", rgb: "3 105 161" },
      "800": { hex: "#075985", rgb: "7 89 133" },
      "900": { hex: "#0c4a6e", rgb: "12 74 110" }
    }
  },
  {
    label: "blue",
    shades: {
      "50": { hex: "#eff6ff", rgb: "239 246 255" },
      "100": { hex: "#dbeafe", rgb: "219 234 254" },
      "200": { hex: "#bfdbfe", rgb: "191 219 254" },
      "300": { hex: "#93c5fd", rgb: "147 197 253" },
      "400": { hex: "#60a5fa", rgb: "96 165 250" },
      "500": { hex: "#3b82f6", rgb: "59 130 246" },
      "600": { hex: "#2563eb", rgb: "37 99 235" },
      "700": { hex: "#1d4ed8", rgb: "29 78 216" },
      "800": { hex: "#1e40af", rgb: "30 64 175" },
      "900": { hex: "#1e3a8a", rgb: "30 58 138" }
    }
  },
  {
    label: "indigo",
    shades: {
      "50": { hex: "#eef2ff", rgb: "238 242 255" },
      "100": { hex: "#e0e7ff", rgb: "224 231 255" },
      "200": { hex: "#c7d2fe", rgb: "199 210 254" },
      "300": { hex: "#a5b4fc", rgb: "165 180 252" },
      "400": { hex: "#818cf8", rgb: "129 140 248" },
      "500": { hex: "#6366f1", rgb: "99 102 241" },
      "600": { hex: "#4f46e5", rgb: "79 70 229" },
      "700": { hex: "#4338ca", rgb: "67 56 202" },
      "800": { hex: "#3730a3", rgb: "55 48 163" },
      "900": { hex: "#312e81", rgb: "49 46 129" }
    }
  },
  {
    label: "violet",
    shades: {
      "50": { hex: "#f5f3ff", rgb: "245 243 255" },
      "100": { hex: "#ede9fe", rgb: "237 233 254" },
      "200": { hex: "#ddd6fe", rgb: "221 214 254" },
      "300": { hex: "#c4b5fd", rgb: "196 181 253" },
      "400": { hex: "#a78bfa", rgb: "167 139 250" },
      "500": { hex: "#8b5cf6", rgb: "139 92 246" },
      "600": { hex: "#7c3aed", rgb: "124 58 237" },
      "700": { hex: "#6d28d9", rgb: "109 40 217" },
      "800": { hex: "#5b21b6", rgb: "91 33 182" },
      "900": { hex: "#4c1d95", rgb: "76 29 149" }
    }
  },
  {
    label: "purple",
    shades: {
      "50": { hex: "#faf5ff", rgb: "250 245 255" },
      "100": { hex: "#f3e8ff", rgb: "243 232 255" },
      "200": { hex: "#e9d5ff", rgb: "233 213 255" },
      "300": { hex: "#d8b4fe", rgb: "216 180 254" },
      "400": { hex: "#c084fc", rgb: "192 132 252" },
      "500": { hex: "#a855f7", rgb: "168 85 247" },
      "600": { hex: "#9333ea", rgb: "147 51 234" },
      "700": { hex: "#7e22ce", rgb: "126 34 206" },
      "800": { hex: "#6b21a8", rgb: "107 33 168" },
      "900": { hex: "#581c87", rgb: "88 28 135" }
    }
  },
  {
    label: "fuchsia",
    shades: {
      "50": { hex: "#fdf4ff", rgb: "253 244 255" },
      "100": { hex: "#fae8ff", rgb: "250 232 255" },
      "200": { hex: "#f5d0fe", rgb: "245 208 254" },
      "300": { hex: "#f0abfc", rgb: "240 171 252" },
      "400": { hex: "#e879f9", rgb: "232 121 249" },
      "500": { hex: "#d946ef", rgb: "217 70 239" },
      "600": { hex: "#c026d3", rgb: "192 38 211" },
      "700": { hex: "#a21caf", rgb: "162 28 175" },
      "800": { hex: "#86198f", rgb: "134 25 143" },
      "900": { hex: "#701a75", rgb: "112 26 117" }
    }
  },
  {
    label: "pink",
    shades: {
      "50": { hex: "#fdf2f8", rgb: "253 242 248" },
      "100": { hex: "#fce7f3", rgb: "252 231 243" },
      "200": { hex: "#fbcfe8", rgb: "251 207 232" },
      "300": { hex: "#f9a8d4", rgb: "249 168 212" },
      "400": { hex: "#f472b6", rgb: "244 114 182" },
      "500": { hex: "#ec4899", rgb: "236 72 153" },
      "600": { hex: "#db2777", rgb: "219 39 119" },
      "700": { hex: "#be185d", rgb: "190 24 93" },
      "800": { hex: "#9d174d", rgb: "157 23 77" },
      "900": { hex: "#831843", rgb: "131 24 67" }
    }
  },
  {
    label: "rose",
    shades: {
      "50": { hex: "#fff1f2", rgb: "255 241 242" },
      "100": { hex: "#ffe4e6", rgb: "255 228 230" },
      "200": { hex: "#fecdd3", rgb: "254 205 211" },
      "300": { hex: "#fda4af", rgb: "253 164 175" },
      "400": { hex: "#fb7185", rgb: "251 113 133" },
      "500": { hex: "#f43f5e", rgb: "244 63 94" },
      "600": { hex: "#e11d48", rgb: "225 29 72" },
      "700": { hex: "#be123c", rgb: "190 18 60" },
      "800": { hex: "#9f1239", rgb: "159 18 57" },
      "900": { hex: "#881337", rgb: "136 19 55" }
    }
  }
];

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/ConicGradient/ConicGradient.svelte
var file12 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\ConicGradient\\ConicGradient.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i].color;
  child_ctx[17] = list[i].label;
  child_ctx[18] = list[i].value;
  return child_ctx;
}
function create_if_block_23(ctx) {
  let figcaption;
  let figcaption_class_value;
  let current;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  const block = {
    c: function create() {
      figcaption = element("figcaption");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      figcaption = claim_element(nodes, "FIGCAPTION", { class: true });
      var figcaption_nodes = children(figcaption);
      if (default_slot)
        default_slot.l(figcaption_nodes);
      figcaption_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figcaption, "class", figcaption_class_value = "conic-caption " + cCaption);
      add_location(figcaption, file12, 61, 2, 1938);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figcaption, anchor);
      if (default_slot) {
        default_slot.m(figcaption, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figcaption);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(61:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "concic-cone " + ctx[5]);
      toggle_class(div, "animate-spin", ctx[1]);
      set_style(div, "background", ctx[3]);
      add_location(div, file12, 65, 2, 2051);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32 && div_class_value !== (div_class_value = "concic-cone " + ctx2[5])) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & 34) {
        toggle_class(div, "animate-spin", ctx2[1]);
      }
      if (dirty & 8) {
        set_style(div, "background", ctx2[3]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(65:1) {#if cone}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let ul;
  let ul_class_value;
  let each_value = ctx[4];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "conic-list list " + cLabel);
      add_location(ul, file12, 69, 2, 2206);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 20) {
        each_value = ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(69:1) {#if legend && generatedLegendList}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let li;
  let span0;
  let span0_class_value;
  let t0;
  let span1;
  let t1_value = ctx[17] + "";
  let t1;
  let t2;
  let strong;
  let t3_value = ctx[18] + "";
  let t3;
  let t4;
  let t5;
  let li_class_value;
  const block = {
    c: function create() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      strong = element("strong");
      t3 = text(t3_value);
      t4 = text("%");
      t5 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      span0 = claim_element(li_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t0 = claim_space(li_nodes);
      span1 = claim_element(li_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach_dev);
      t2 = claim_space(li_nodes);
      strong = claim_element(li_nodes, "STRONG", { class: true });
      var strong_nodes = children(strong);
      t3 = claim_text(strong_nodes, t3_value);
      t4 = claim_text(strong_nodes, "%");
      strong_nodes.forEach(detach_dev);
      t5 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = "conic-swatch " + cSwatch);
      set_style(span0, "background", ctx[16]);
      add_location(span0, file12, 72, 5, 2343);
      attr_dev(span1, "class", "conic-label flex-auto");
      add_location(span1, file12, 73, 5, 2413);
      attr_dev(strong, "class", "conic-value");
      add_location(strong, file12, 74, 5, 2469);
      attr_dev(li, "class", li_class_value = "conic-item " + ctx[2]);
      add_location(li, file12, 71, 4, 2306);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span0);
      append_hydration_dev(li, t0);
      append_hydration_dev(li, span1);
      append_hydration_dev(span1, t1);
      append_hydration_dev(li, t2);
      append_hydration_dev(li, strong);
      append_hydration_dev(strong, t3);
      append_hydration_dev(strong, t4);
      append_hydration_dev(li, t5);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16) {
        set_style(span0, "background", ctx2[16]);
      }
      if (dirty & 16 && t1_value !== (t1_value = ctx2[17] + ""))
        set_data_dev(t1, t1_value);
      if (dirty & 16 && t3_value !== (t3_value = ctx2[18] + ""))
        set_data_dev(t3, t3_value);
      if (dirty & 4 && li_class_value !== (li_class_value = "conic-item " + ctx2[2])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(71:3) {#each generatedLegendList as { color, label, value }}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let figure;
  let t0;
  let t1;
  let figure_class_value;
  let current;
  let if_block0 = ctx[7].default && create_if_block_23(ctx);
  let if_block1 = ctx[3] && create_if_block_16(ctx);
  let if_block2 = ctx[0] && ctx[4] && create_if_block9(ctx);
  const block = {
    c: function create() {
      figure = element("figure");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", { class: true, "data-testid": true });
      var figure_nodes = children(figure);
      if (if_block0)
        if_block0.l(figure_nodes);
      t0 = claim_space(figure_nodes);
      if (if_block1)
        if_block1.l(figure_nodes);
      t1 = claim_space(figure_nodes);
      if (if_block2)
        if_block2.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figure, "class", figure_class_value = "conic-gradient " + ctx[6]);
      attr_dev(figure, "data-testid", "conic-gradient");
      add_location(figure, file12, 58, 0, 1822);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      if (if_block0)
        if_block0.m(figure, null);
      append_hydration_dev(figure, t0);
      if (if_block1)
        if_block1.m(figure, null);
      append_hydration_dev(figure, t1);
      if (if_block2)
        if_block2.m(figure, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[7].default) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_23(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(figure, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_16(ctx2);
          if_block1.c();
          if_block1.m(figure, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[0] && ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block9(ctx2);
          if_block2.c();
          if_block2.m(figure, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & 64 && figure_class_value !== (figure_class_value = "conic-gradient " + ctx2[6])) {
        attr_dev(figure, "class", figure_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figure);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase8 = "flex flex-col items-center space-y-4";
var cCaption = "text-center";
var cCone = "block aspect-square rounded-full";
var cLabel = "text-sm w-full";
var cSwatch = "block aspect-square bg-black w-5 rounded-full mr-2";
function instance12($$self, $$props, $$invalidate) {
  let classesBase;
  let classesCone;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ConicGradient", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { stops = [
    {
      color: ["neutral", 500],
      start: 0,
      end: 100
    }
  ] } = $$props;
  let { legend = false } = $$props;
  let { spin = false } = $$props;
  let { width = "w-full" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let cone;
  let generatedLegendList;
  function setColorValue(color) {
    if (typeof color === "string")
      return color;
    const colorSet = tailwindDefaultColors.find((c) => c.label === color[0]);
    return colorSet == null ? void 0 : colorSet.shades[color[1]].hex;
  }
  function genConicGradient() {
    let d = stops.map((v) => `${setColorValue(v.color)} ${v.start}% ${v.end}%`);
    $$invalidate(3, cone = `conic-gradient(${d.join(", ")})`);
  }
  function genLegend() {
    if (!legend)
      return;
    $$invalidate(4, generatedLegendList = stops.map((v) => {
      return {
        label: v.label,
        color: setColorValue(v.color),
        value: v.end - v.start
      };
    }));
  }
  genConicGradient();
  genLegend();
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("stops" in $$new_props)
      $$invalidate(8, stops = $$new_props.stops);
    if ("legend" in $$new_props)
      $$invalidate(0, legend = $$new_props.legend);
    if ("spin" in $$new_props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("width" in $$new_props)
      $$invalidate(9, width = $$new_props.width);
    if ("hover" in $$new_props)
      $$invalidate(2, hover = $$new_props.hover);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tailwindDefaultColors,
    stops,
    legend,
    spin,
    width,
    hover,
    cone,
    generatedLegendList,
    cBase: cBase8,
    cCaption,
    cCone,
    cLabel,
    cSwatch,
    setColorValue,
    genConicGradient,
    genLegend,
    classesCone,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("stops" in $$props)
      $$invalidate(8, stops = $$new_props.stops);
    if ("legend" in $$props)
      $$invalidate(0, legend = $$new_props.legend);
    if ("spin" in $$props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("width" in $$props)
      $$invalidate(9, width = $$new_props.width);
    if ("hover" in $$props)
      $$invalidate(2, hover = $$new_props.hover);
    if ("cone" in $$props)
      $$invalidate(3, cone = $$new_props.cone);
    if ("generatedLegendList" in $$props)
      $$invalidate(4, generatedLegendList = $$new_props.generatedLegendList);
    if ("classesCone" in $$props)
      $$invalidate(5, classesCone = $$new_props.classesCone);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesBase = `${cBase8} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(5, classesCone = `${cCone} ${width}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    legend,
    spin,
    hover,
    cone,
    generatedLegendList,
    classesCone,
    classesBase,
    $$slots,
    stops,
    width,
    $$scope,
    slots
  ];
}
var ConicGradient = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      stops: 8,
      legend: 0,
      spin: 1,
      width: 9,
      hover: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ConicGradient",
      options,
      id: create_fragment12.name
    });
  }
  get stops() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stops(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ConicGradient_default = ConicGradient;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Divider/Divider.svelte
var file13 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Divider\\Divider.svelte";
function create_fragment13(ctx) {
  let hr;
  let hr_class_value;
  const block = {
    c: function create() {
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      hr = claim_element(nodes, "HR", { class: true, "data-testid": true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(hr, "class", hr_class_value = "divider " + ctx[0]);
      attr_dev(hr, "data-testid", "divider");
      add_location(hr, file13, 20, 0, 847);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, hr, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1 && hr_class_value !== (hr_class_value = "divider " + ctx2[0])) {
        attr_dev(hr, "class", hr_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(hr);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let classesOrientation;
  let classesDivider;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Divider", slots, []);
  let { vertical = false } = $$props;
  let { borderWidth = "border-t" } = $$props;
  let { borderStyle = "border-solid" } = $$props;
  let { borderColor = "border-surface-300-600-token" } = $$props;
  let { margin = "m-0" } = $$props;
  let { opacity = "opacity-full" } = $$props;
  const cBaseDivider = `block`;
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("vertical" in $$new_props)
      $$invalidate(1, vertical = $$new_props.vertical);
    if ("borderWidth" in $$new_props)
      $$invalidate(2, borderWidth = $$new_props.borderWidth);
    if ("borderStyle" in $$new_props)
      $$invalidate(3, borderStyle = $$new_props.borderStyle);
    if ("borderColor" in $$new_props)
      $$invalidate(4, borderColor = $$new_props.borderColor);
    if ("margin" in $$new_props)
      $$invalidate(5, margin = $$new_props.margin);
    if ("opacity" in $$new_props)
      $$invalidate(6, opacity = $$new_props.opacity);
  };
  $$self.$capture_state = () => ({
    vertical,
    borderWidth,
    borderStyle,
    borderColor,
    margin,
    opacity,
    cBaseDivider,
    classesOrientation,
    classesDivider
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("vertical" in $$props)
      $$invalidate(1, vertical = $$new_props.vertical);
    if ("borderWidth" in $$props)
      $$invalidate(2, borderWidth = $$new_props.borderWidth);
    if ("borderStyle" in $$props)
      $$invalidate(3, borderStyle = $$new_props.borderStyle);
    if ("borderColor" in $$props)
      $$invalidate(4, borderColor = $$new_props.borderColor);
    if ("margin" in $$props)
      $$invalidate(5, margin = $$new_props.margin);
    if ("opacity" in $$props)
      $$invalidate(6, opacity = $$new_props.opacity);
    if ("classesOrientation" in $$props)
      $$invalidate(7, classesOrientation = $$new_props.classesOrientation);
    if ("classesDivider" in $$props)
      $$invalidate(0, classesDivider = $$new_props.classesDivider);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(7, classesOrientation = vertical === true ? "w-0 h-full min-h-[24px]" : "w-full h-0");
    }
    $:
      $$invalidate(0, classesDivider = `${cBaseDivider} ${classesOrientation} ${borderWidth} ${borderStyle} ${borderColor} ${margin} ${opacity} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    classesDivider,
    vertical,
    borderWidth,
    borderStyle,
    borderColor,
    margin,
    opacity,
    classesOrientation
  ];
}
var Divider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      vertical: 1,
      borderWidth: 2,
      borderStyle: 3,
      borderColor: 4,
      margin: 5,
      opacity: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Divider",
      options,
      id: create_fragment13.name
    });
  }
  get vertical() {
    throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderStyle() {
    throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderStyle(value) {
    throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get margin() {
    throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set margin(value) {
    throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Divider_default = Divider;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/FileButton/FileButton.svelte
var file14 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\FileButton\\FileButton.svelte";
function create_fragment14(ctx) {
  let div;
  let input;
  let t;
  let button_1;
  let button_1_class_value;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "file" },
    ctx[4](),
    { class: "file-button-input hidden" }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      button_1 = element("button");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { type: true, class: true });
      t = claim_space(div_nodes);
      button_1 = claim_element(div_nodes, "BUTTON", { class: true });
      var button_1_nodes = children(button_1);
      if (default_slot)
        default_slot.l(button_1_nodes);
      button_1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file14, 19, 1, 461);
      attr_dev(button_1, "class", button_1_class_value = "file-button-btn btn " + ctx[1]);
      add_location(button_1, file14, 21, 1, 604);
      attr_dev(div, "class", div_class_value = "file-button " + (ctx[5].class ?? ""));
      attr_dev(div, "data-testid", "file-button");
      add_location(div, file14, 17, 0, 364);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      if (input.autofocus)
        input.focus();
      ctx[9](input);
      append_hydration_dev(div, t);
      append_hydration_dev(div, button_1);
      if (default_slot) {
        default_slot.m(button_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[10]),
          listen_dev(input, "change", ctx[8], false, false, false),
          listen_dev(button_1, "click", ctx[3], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        ctx2[4](),
        { class: "file-button-input hidden" }
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && button_1_class_value !== (button_1_class_value = "file-button-btn btn " + ctx2[1])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (!current || dirty & 32 && div_class_value !== (div_class_value = "file-button " + (ctx2[5].class ?? ""))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[9](null);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  const omit_props_names = ["files", "button"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileButton", slots, ["default"]);
  let { files } = $$props;
  let { button = "btn-filled-accent" } = $$props;
  let elemFileInput;
  function onButtonClick() {
    elemFileInput.click();
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (files === void 0 && !("files" in $$props || $$self.$$.bound[$$self.$$.props["files"]])) {
      console.warn("<FileButton> was created without expected prop 'files'");
    }
  });
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemFileInput = $$value;
      $$invalidate(2, elemFileInput);
    });
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(0, files);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("button" in $$new_props)
      $$invalidate(1, button = $$new_props.button);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    files,
    button,
    elemFileInput,
    onButtonClick,
    prunedRestProps
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("button" in $$props)
      $$invalidate(1, button = $$new_props.button);
    if ("elemFileInput" in $$props)
      $$invalidate(2, elemFileInput = $$new_props.elemFileInput);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    files,
    button,
    elemFileInput,
    onButtonClick,
    prunedRestProps,
    $$props,
    $$scope,
    slots,
    change_handler,
    input_binding,
    input_change_handler
  ];
}
var FileButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { files: 0, button: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileButton",
      options,
      id: create_fragment14.name
    });
  }
  get files() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get button() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set button(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileButton_default = FileButton;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/FileDropzone/FileDropzone.svelte
var file15 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\FileDropzone\\FileDropzone.svelte";
function add_css2(target) {
  append_styles(target, "svelte-wxjjdg", "input[type='file'].svelte-wxjjdg{color:transparent\n}.svelte-wxjjdg::file-selector-button{display:none\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmlsZURyb3B6b25lLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF3RkMsS0FBQSxDQUFBLElBQUEsQ0FBQSxNQUFBLENBQUEsY0FBQSxDQUFBLEFBQ0csS0FBQSxDQUFBLFdBQUE7QUFDSixDQUFBLGNBQ0Msc0JBQUEsQUFBQSxDQUFBLEFBQ0csT0FBQSxDQUFBLElBQUE7QUFDSixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkZpbGVEcm9wem9uZS5zdmVsdGUiXX0= */");
}
function create_if_block10(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "text-sm opacity-70 svelte-wxjjdg");
      add_location(div, file15, 77, 16, 2672);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      div.innerHTML = ctx[2];
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        div.innerHTML = ctx2[2];
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(78:5) {#if notes}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let div3;
  let div0;
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  let if_block = ctx[2] && create_if_block10(ctx);
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      t0 = text("↓");
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, "↓");
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "text-4xl flex justify-center items-center svelte-wxjjdg");
      add_location(div0, file15, 73, 4, 2422);
      attr_dev(div1, "class", "text-base font-bold svelte-wxjjdg");
      add_location(div1, file15, 76, 5, 2603);
      attr_dev(div2, "class", "flex flex-col justify-center items-start space-y-0 svelte-wxjjdg");
      add_location(div2, file15, 75, 4, 2533);
      attr_dev(div3, "class", "grid grid-cols-[auto_1fr] gap-4 svelte-wxjjdg");
      add_location(div3, file15, 71, 3, 2354);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, t0);
      ctx[19](div0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      div1.innerHTML = ctx[1];
      append_hydration_dev(div2, t2);
      if (if_block)
        if_block.m(div2, null);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        div1.innerHTML = ctx2[1];
      ;
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      ctx[19](null);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(70:8)     ",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t;
  let input;
  let input_class_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  const default_slot_or_fallback = default_slot || fallback_block3(ctx);
  let input_levels = [
    { type: "file" },
    ctx[10](),
    {
      class: input_class_value = "file-dropzone-input " + ctx[4]
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      input = claim_element(div1_nodes, "INPUT", { type: true, class: true });
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "file-dropzone-message " + ctx[5] + " svelte-wxjjdg");
      add_location(div0, file15, 67, 1, 2236);
      set_attributes(input, input_data);
      toggle_class(input, "svelte-wxjjdg", true);
      add_location(input, file15, 83, 1, 2791);
      attr_dev(div1, "class", div1_class_value = "file-dropzone " + ctx[6] + " svelte-wxjjdg");
      attr_dev(div1, "data-testid", "file-dropzone");
      add_location(div1, file15, 58, 0, 2058);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, input);
      if (input.autofocus)
        input.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[20]),
          listen_dev(input, "change", ctx[18], false, false, false),
          listen_dev(div1, "dragenter", ctx[17], false, false, false),
          listen_dev(div1, "dragover", ctx[7], false, false, false),
          listen_dev(div1, "dragleave", ctx[8], false, false, false),
          listen_dev(div1, "drop", ctx[9], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 14)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 32 && div0_class_value !== (div0_class_value = "file-dropzone-message " + ctx2[5] + " svelte-wxjjdg")) {
        attr_dev(div0, "class", div0_class_value);
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        ctx2[10](),
        (!current || dirty & 16 && input_class_value !== (input_class_value = "file-dropzone-input " + ctx2[4])) && { class: input_class_value }
      ]));
      toggle_class(input, "svelte-wxjjdg", true);
      if (!current || dirty & 64 && div1_class_value !== (div1_class_value = "file-dropzone " + ctx2[6] + " svelte-wxjjdg")) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase9 = "relative";
var cMessage = "absolute top-0 left-0 right-0 bottom-0 z-[1] max-w-[480px] mx-auto flex justify-center items-center !pointer-events-none";
var cInput = "!border-2 border-dashed cursor-pointer";
function instance15($$self, $$props, $$invalidate) {
  let classesBase;
  let classesMessage;
  let classesInput;
  const omit_props_names = ["files", "title", "notes", "width", "height", "padding", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileDropzone", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { files } = $$props;
  let { title = "Drop files or click to select." } = $$props;
  let { notes = "" } = $$props;
  let { width = "w-full" } = $$props;
  let { height = "h-24" } = $$props;
  let { padding = "p-4" } = $$props;
  let { color = "" } = $$props;
  let elemIcon;
  function onDragOver(event) {
    dispatch("dragover", event);
    elemIcon == null ? void 0 : elemIcon.classList.add("animate-bounce");
  }
  function onDragLeave(event) {
    dispatch("dragleave", event);
    elemIcon == null ? void 0 : elemIcon.classList.remove("animate-bounce");
  }
  function onDrop(event) {
    dispatch("drop", event);
    elemIcon == null ? void 0 : elemIcon.classList.remove("animate-bounce");
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (files === void 0 && !("files" in $$props || $$self.$$.bound[$$self.$$.props["files"]])) {
      console.warn("<FileDropzone> was created without expected prop 'files'");
    }
  });
  function dragenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemIcon = $$value;
      $$invalidate(3, elemIcon);
    });
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(0, files);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
    if ("notes" in $$new_props)
      $$invalidate(2, notes = $$new_props.notes);
    if ("width" in $$new_props)
      $$invalidate(11, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(12, height = $$new_props.height);
    if ("padding" in $$new_props)
      $$invalidate(13, padding = $$new_props.padding);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    files,
    title,
    notes,
    width,
    height,
    padding,
    color,
    cBase: cBase9,
    cMessage,
    cInput,
    elemIcon,
    onDragOver,
    onDragLeave,
    onDrop,
    prunedRestProps,
    classesInput,
    classesMessage,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("notes" in $$props)
      $$invalidate(2, notes = $$new_props.notes);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(12, height = $$new_props.height);
    if ("padding" in $$props)
      $$invalidate(13, padding = $$new_props.padding);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("elemIcon" in $$props)
      $$invalidate(3, elemIcon = $$new_props.elemIcon);
    if ("classesInput" in $$props)
      $$invalidate(4, classesInput = $$new_props.classesInput);
    if ("classesMessage" in $$props)
      $$invalidate(5, classesMessage = $$new_props.classesMessage);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesBase = `${cBase9} ${width} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 28672) {
      $:
        $$invalidate(5, classesMessage = `${cMessage} ${color} ${height} ${padding}`);
    }
    if ($$self.$$.dirty & 12288) {
      $:
        $$invalidate(4, classesInput = `${cInput} ${height} ${padding}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    files,
    title,
    notes,
    elemIcon,
    classesInput,
    classesMessage,
    classesBase,
    onDragOver,
    onDragLeave,
    onDrop,
    prunedRestProps,
    width,
    height,
    padding,
    color,
    $$scope,
    slots,
    dragenter_handler,
    change_handler,
    div0_binding,
    input_change_handler
  ];
}
var FileDropzone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        files: 0,
        title: 1,
        notes: 2,
        width: 11,
        height: 12,
        padding: 13,
        color: 14
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileDropzone",
      options,
      id: create_fragment15.name
    });
  }
  get files() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notes() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notes(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileDropzone_default = FileDropzone;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/GradientHeading/GradientHeading.svelte
var file16 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\GradientHeading\\GradientHeading.svelte";
function create_dynamic_element3(ctx) {
  let svelte_element;
  let span;
  let span_class_value;
  let svelte_element_class_value;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = "gradient-heading " + ctx[2]
    },
    { "data-testid": "gradient-heading" },
    { role: "heading" }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(ctx[0]);
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(nodes, (ctx[0] || "null").toUpperCase(), {
        class: true,
        "data-testid": true,
        role: true
      });
      var svelte_element_nodes = children(svelte_element);
      span = claim_element(svelte_element_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = "gradient-heading-text " + ctx[1]);
      add_location(span, file16, 17, 1, 725);
      if (/-/.test(ctx[0])) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
      add_location(svelte_element, file16, 16, 0, 611);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && span_class_value !== (span_class_value = "gradient-heading-text " + ctx2[1])) {
        attr_dev(span, "class", span_class_value);
      }
      svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & 4 && svelte_element_class_value !== (svelte_element_class_value = "gradient-heading " + ctx2[2])) && { class: svelte_element_class_value },
        { "data-testid": "gradient-heading" },
        { role: "heading" }
      ]);
      if (/-/.test(ctx2[0])) {
        set_custom_element_data_map(svelte_element, svelte_element_data);
      } else {
        set_attributes(svelte_element, svelte_element_data);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element3.name,
    type: "child_dynamic_element",
    source: '(17:0) <svelte:element this={tag} class=\\"gradient-heading {classesBase}\\" data-testid=\\"gradient-heading\\" role=\\"heading\\">',
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let previous_tag = ctx[0];
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(ctx[0]);
  validate_void_dynamic_element(ctx[0]);
  let svelte_element = ctx[0] && create_dynamic_element3(ctx);
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element3(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(previous_tag, ctx2[0])) {
          svelte_element.d(1);
          validate_dynamic_element(ctx2[0]);
          validate_void_dynamic_element(ctx2[0]);
          svelte_element = create_dynamic_element3(ctx2);
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
      }
      previous_tag = ctx2[0];
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let classesBase;
  let clasesText;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GradientHeading", slots, ["default"]);
  let { tag = "h1" } = $$props;
  let { direction = "bg-gradient-to-r" } = $$props;
  let { from = "from-primary-500" } = $$props;
  let { to = "to-accent-500" } = $$props;
  let cBaseHeading = "bg-clip-text text-transparent box-decoration-clone";
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("direction" in $$new_props)
      $$invalidate(3, direction = $$new_props.direction);
    if ("from" in $$new_props)
      $$invalidate(4, from = $$new_props.from);
    if ("to" in $$new_props)
      $$invalidate(5, to = $$new_props.to);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tag,
    direction,
    from,
    to,
    cBaseHeading,
    clasesText,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("direction" in $$props)
      $$invalidate(3, direction = $$new_props.direction);
    if ("from" in $$props)
      $$invalidate(4, from = $$new_props.from);
    if ("to" in $$props)
      $$invalidate(5, to = $$new_props.to);
    if ("cBaseHeading" in $$props)
      $$invalidate(8, cBaseHeading = $$new_props.cBaseHeading);
    if ("clasesText" in $$props)
      $$invalidate(1, clasesText = $$new_props.clasesText);
    if ("classesBase" in $$props)
      $$invalidate(2, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(2, classesBase = `${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 56) {
      $:
        $$invalidate(1, clasesText = `${cBaseHeading} ${direction} ${from} ${to}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [tag, clasesText, classesBase, direction, from, to, $$scope, slots];
}
var GradientHeading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { tag: 0, direction: 3, from: 4, to: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GradientHeading",
      options,
      id: create_fragment16.name
    });
  }
  get tag() {
    throw new Error("<GradientHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<GradientHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<GradientHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<GradientHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get from() {
    throw new Error("<GradientHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set from(value) {
    throw new Error("<GradientHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get to() {
    throw new Error("<GradientHeading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set to(value) {
    throw new Error("<GradientHeading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GradientHeading_default = GradientHeading;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/ListBox/ListBox.svelte
var file17 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\ListBox\\ListBox.svelte";
function create_if_block11(ctx) {
  let span;
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(ctx[2]);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, id: true });
      var span_nodes = children(span);
      t = claim_text(span_nodes, ctx[2]);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = "listbox-label " + ctx[5] + " " + ctx[0]);
      attr_dev(span, "id", ctx[3]);
      add_location(span, file17, 51, 12, 1902);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
      if (dirty & 33 && span_class_value !== (span_class_value = "listbox-label " + ctx2[5] + " " + ctx2[0])) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty & 8) {
        attr_dev(span, "id", ctx2[3]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(52:1) {#if label}",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let div;
  let t;
  let ul;
  let ul_class_value;
  let div_class_value;
  let current;
  let if_block = ctx[2] && create_if_block11(ctx);
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      ul = claim_element(div_nodes, "UL", {
        class: true,
        role: true,
        "aria-labelledby": true
      });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "listbox-list " + ctx[4] + " " + ctx[1]);
      attr_dev(ul, "role", "listbox");
      attr_dev(ul, "aria-labelledby", ctx[3]);
      add_location(ul, file17, 53, 1, 2011);
      attr_dev(div, "class", div_class_value = "listbox " + ctx[6]);
      attr_dev(div, "data-testid", "listbox-area");
      add_location(div, file17, 49, 0, 1811);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration_dev(div, t);
      append_hydration_dev(div, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block11(ctx2);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 18 && ul_class_value !== (ul_class_value = "listbox-list " + ctx2[4] + " " + ctx2[1])) {
        attr_dev(ul, "class", ul_class_value);
      }
      if (!current || dirty & 8) {
        attr_dev(ul, "aria-labelledby", ctx2[3]);
      }
      if (!current || dirty & 64 && div_class_value !== (div_class_value = "listbox " + ctx2[6])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase10 = "space-y-4";
var cLabel2 = "font-bold text-lg";
var cListBox = "list-none overflow-y-auto";
function instance17($$self, $$props, $$invalidate) {
  let classesBase;
  let classesLabel;
  let classesListBox;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBox", slots, ["default"]);
  let { selected = writable(void 0) } = $$props;
  let { space: space2 = "space-y-1" } = $$props;
  let { height = "" } = $$props;
  let { accent = "!bg-primary-active-token" } = $$props;
  let { padding = "px-4 py-3" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { regionLabel = "" } = $$props;
  let { regionList = "" } = $$props;
  let { label = "" } = $$props;
  let { labelId = label == null ? void 0 : label.toLowerCase().replace(" ", "-") } = $$props;
  setContext("selected", selected);
  setContext("accent", accent);
  setContext("padding", padding);
  setContext("rounded", rounded);
  setContext("hover", hover);
  $$self.$$set = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$invalidate(7, selected = $$new_props.selected);
    if ("space" in $$new_props)
      $$invalidate(8, space2 = $$new_props.space);
    if ("height" in $$new_props)
      $$invalidate(9, height = $$new_props.height);
    if ("accent" in $$new_props)
      $$invalidate(10, accent = $$new_props.accent);
    if ("padding" in $$new_props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("hover" in $$new_props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("regionLabel" in $$new_props)
      $$invalidate(0, regionLabel = $$new_props.regionLabel);
    if ("regionList" in $$new_props)
      $$invalidate(1, regionList = $$new_props.regionList);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("labelId" in $$new_props)
      $$invalidate(3, labelId = $$new_props.labelId);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    writable,
    selected,
    space: space2,
    height,
    accent,
    padding,
    rounded,
    hover,
    regionLabel,
    regionList,
    label,
    labelId,
    cBase: cBase10,
    cLabel: cLabel2,
    cListBox,
    classesListBox,
    classesLabel,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(7, selected = $$new_props.selected);
    if ("space" in $$props)
      $$invalidate(8, space2 = $$new_props.space);
    if ("height" in $$props)
      $$invalidate(9, height = $$new_props.height);
    if ("accent" in $$props)
      $$invalidate(10, accent = $$new_props.accent);
    if ("padding" in $$props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("hover" in $$props)
      $$invalidate(13, hover = $$new_props.hover);
    if ("regionLabel" in $$props)
      $$invalidate(0, regionLabel = $$new_props.regionLabel);
    if ("regionList" in $$props)
      $$invalidate(1, regionList = $$new_props.regionList);
    if ("label" in $$props)
      $$invalidate(2, label = $$new_props.label);
    if ("labelId" in $$props)
      $$invalidate(3, labelId = $$new_props.labelId);
    if ("classesListBox" in $$props)
      $$invalidate(4, classesListBox = $$new_props.classesListBox);
    if ("classesLabel" in $$props)
      $$invalidate(5, classesLabel = $$new_props.classesLabel);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesBase = `${cBase10} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 768) {
      $:
        $$invalidate(4, classesListBox = `${cListBox} ${height} ${space2}`);
    }
  };
  $:
    $$invalidate(5, classesLabel = `${cLabel2}`);
  $$props = exclude_internal_props($$props);
  return [
    regionLabel,
    regionList,
    label,
    labelId,
    classesListBox,
    classesLabel,
    classesBase,
    selected,
    space2,
    height,
    accent,
    padding,
    rounded,
    hover,
    $$scope,
    slots
  ];
}
var ListBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      selected: 7,
      space: 8,
      height: 9,
      accent: 10,
      padding: 11,
      rounded: 12,
      hover: 13,
      regionLabel: 0,
      regionList: 1,
      label: 2,
      labelId: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBox",
      options,
      id: create_fragment17.name
    });
  }
  get selected() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get space() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set space(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionList() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionList(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelId() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelId(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBox_default = ListBox;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/ListBox/ListBoxItem.svelte
var file18 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\ListBox\\ListBoxItem.svelte";
var get_trail_slot_changes4 = (dirty) => ({});
var get_trail_slot_context4 = (ctx) => ({});
var get_lead_slot_changes6 = (dirty) => ({});
var get_lead_slot_context6 = (ctx) => ({});
function create_if_block_17(ctx) {
  let span;
  let current;
  const lead_slot_template = ctx[16].lead;
  const lead_slot = create_slot(lead_slot_template, ctx, ctx[15], get_lead_slot_context6);
  const block = {
    c: function create() {
      span = element("span");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (lead_slot)
        lead_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "listbox-item-lead");
      add_location(span, file18, 81, 19, 2384);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (lead_slot) {
        lead_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(lead_slot_template, ctx2[15], dirty, get_lead_slot_changes6),
            get_lead_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(82:1) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block12(ctx) {
  let span;
  let current;
  const trail_slot_template = ctx[16].trail;
  const trail_slot = create_slot(trail_slot_template, ctx, ctx[15], get_trail_slot_context4);
  const block = {
    c: function create() {
      span = element("span");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (trail_slot)
        trail_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "listbox-item-trail");
      add_location(span, file18, 85, 20, 2572);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (trail_slot) {
        trail_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(trail_slot_template, ctx2[15], dirty, get_trail_slot_changes4),
            get_trail_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(86:1) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let li;
  let t0;
  let div;
  let t1;
  let li_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[7].lead && create_if_block_17(ctx);
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  let if_block1 = ctx[7].trail && create_if_block12(ctx);
  const block = {
    c: function create() {
      li = element("li");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        id: true,
        role: true,
        "aria-selected": true,
        tabindex: true,
        "data-testid": true
      });
      var li_nodes = children(li);
      if (if_block0)
        if_block0.l(li_nodes);
      t0 = claim_space(li_nodes);
      div = claim_element(li_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      if (if_block1)
        if_block1.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "listbox-item-content flex-1");
      add_location(div, file18, 83, 1, 2474);
      attr_dev(li, "class", li_class_value = "listbox-item " + ctx[4]);
      attr_dev(li, "id", ctx[0]);
      attr_dev(li, "role", "option");
      attr_dev(li, "aria-selected", ctx[2]);
      attr_dev(li, "tabindex", "0");
      attr_dev(li, "data-testid", "listbox-item");
      add_location(li, file18, 69, 0, 2138);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (if_block0)
        if_block0.m(li, null);
      append_hydration_dev(li, t0);
      append_hydration_dev(li, div);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(li, t1);
      if (if_block1)
        if_block1.m(li, null);
      ctx[17](li);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", ctx[5], false, false, false),
          listen_dev(li, "keydown", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[7].lead) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_17(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(li, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null),
            null
          );
        }
      }
      if (ctx2[7].trail) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(li, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 16 && li_class_value !== (li_class_value = "listbox-item " + ctx2[4])) {
        attr_dev(li, "class", li_class_value);
      }
      if (!current || dirty & 1) {
        attr_dev(li, "id", ctx2[0]);
      }
      if (!current || dirty & 4) {
        attr_dev(li, "aria-selected", ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase11 = "flex items-center space-x-4 whitespace-nowrap cursor-pointer";
function instance18($$self, $$props, $$invalidate) {
  let selectionMatch;
  let isSelected;
  let classesHighlight;
  let classesBase;
  let $selected, $$unsubscribe_selected = noop, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(14, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxItem", slots, ["lead", "default", "trail"]);
  const $$slots = compute_slots(slots);
  let { id = "" } = $$props;
  const dispatch = createEventDispatcher();
  let { selected = getContext("selected") } = $$props;
  validate_store(selected, "selected");
  $$subscribe_selected();
  let { accent = getContext("accent") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let elemItem;
  function onClickHandler(event) {
    dispatch("click", event);
    if (!$selected || !$$props.value) {
      return;
    }
    typeof $selected === "object" ? handleMultiSelect() : handleSingleSelect();
  }
  function handleSingleSelect() {
    selected.set($$props.value);
  }
  function handleMultiSelect() {
    const v = $$props.value;
    const local = $selected;
    if (local.includes(v)) {
      local.splice(local.indexOf(v), 1);
      selected.set(local);
    } else {
      selected.set([...local, v]);
    }
  }
  function onKeyDown3(event) {
    dispatch("keydown", event);
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      elemItem.click();
    }
  }
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemItem = $$value;
      $$invalidate(3, elemItem);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("selected" in $$new_props)
      $$subscribe_selected($$invalidate(1, selected = $$new_props.selected));
    if ("accent" in $$new_props)
      $$invalidate(8, accent = $$new_props.accent);
    if ("padding" in $$new_props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(10, rounded = $$new_props.rounded);
    if ("hover" in $$new_props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    id,
    dispatch,
    selected,
    accent,
    padding,
    rounded,
    hover,
    cBase: cBase11,
    elemItem,
    onClickHandler,
    handleSingleSelect,
    handleMultiSelect,
    onKeyDown: onKeyDown3,
    classesHighlight,
    classesBase,
    isSelected,
    selectionMatch,
    $selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
    if ("selected" in $$props)
      $$subscribe_selected($$invalidate(1, selected = $$new_props.selected));
    if ("accent" in $$props)
      $$invalidate(8, accent = $$new_props.accent);
    if ("padding" in $$props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(10, rounded = $$new_props.rounded);
    if ("hover" in $$props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("elemItem" in $$props)
      $$invalidate(3, elemItem = $$new_props.elemItem);
    if ("classesHighlight" in $$props)
      $$invalidate(12, classesHighlight = $$new_props.classesHighlight);
    if ("classesBase" in $$props)
      $$invalidate(4, classesBase = $$new_props.classesBase);
    if ("isSelected" in $$props)
      $$invalidate(2, isSelected = $$new_props.isSelected);
    if ("selectionMatch" in $$props)
      $$invalidate(13, selectionMatch = $$new_props.selectionMatch);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(13, selectionMatch = () => {
        if ($selected && $$props.value) {
          return typeof $selected === "object" ? $selected.includes($$props.value) : $selected === $$props.value;
        }
        return false;
      });
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(2, isSelected = selectionMatch() ? true : false);
    }
    if ($$self.$$.dirty & 2308) {
      $:
        $$invalidate(12, classesHighlight = isSelected ? `${accent}` : `${hover}`);
    }
    $:
      $$invalidate(4, classesBase = `${cBase11} ${padding} ${rounded} ${classesHighlight} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    id,
    selected,
    isSelected,
    elemItem,
    classesBase,
    onClickHandler,
    onKeyDown3,
    $$slots,
    accent,
    padding,
    rounded,
    hover,
    classesHighlight,
    selectionMatch,
    $selected,
    $$scope,
    slots,
    li_binding
  ];
}
var ListBoxItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      id: 0,
      selected: 1,
      accent: 8,
      padding: 9,
      rounded: 10,
      hover: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxItem",
      options,
      id: create_fragment18.name
    });
  }
  get id() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxItem_default = ListBoxItem;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Paginator/Paginator.svelte
var file19 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Paginator\\Paginator.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let option;
  let t0;
  let t1_value = ctx[18] + "";
  let t1;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text("Show ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, "Show ");
      t1 = claim_text(option_nodes, t1_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = ctx[18];
      option.value = option.__value;
      add_location(option, file19, 49, 37, 1840);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[18] + ""))
        set_data_dev(t1, t1_value);
      if (dirty & 1 && option_value_value !== (option_value_value = ctx2[18])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(50:3) {#each settings.amounts as amount}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let div1;
  let label;
  let select_1;
  let select_1_class_value;
  let label_class_value;
  let t0;
  let span1;
  let t1_value = ctx[0].offset * ctx[0].limit + 1 + "";
  let t1;
  let t2;
  let t3_value = Math.min(ctx[0].offset * ctx[0].limit + ctx[0].limit, ctx[0].size) + "";
  let t3;
  let t4;
  let span0;
  let t5;
  let t6;
  let strong;
  let t7_value = ctx[0].size + "";
  let t7;
  let span1_class_value;
  let t8;
  let div0;
  let button0;
  let t9;
  let button0_class_value;
  let button0_disabled_value;
  let t10;
  let button1;
  let t11;
  let button1_class_value;
  let button1_disabled_value;
  let div1_class_value;
  let mounted;
  let dispose;
  let each_value = ctx[0].amounts;
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      label = element("label");
      select_1 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = text(" to ");
      t3 = text(t3_value);
      t4 = space();
      span0 = element("span");
      t5 = text("/");
      t6 = space();
      strong = element("strong");
      t7 = text(t7_value);
      t8 = space();
      div0 = element("div");
      button0 = element("button");
      t9 = text("←");
      t10 = space();
      button1 = element("button");
      t11 = text("→");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      label = claim_element(div1_nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      select_1 = claim_element(label_nodes, "SELECT", { class: true, "aria-label": true });
      var select_1_nodes = children(select_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_1_nodes);
      }
      select_1_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      span1 = claim_element(div1_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      t2 = claim_text(span1_nodes, " to ");
      t3 = claim_text(span1_nodes, t3_value);
      t4 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t5 = claim_text(span0_nodes, "/");
      span0_nodes.forEach(detach_dev);
      t6 = claim_space(span1_nodes);
      strong = claim_element(span1_nodes, "STRONG", {});
      var strong_nodes = children(strong);
      t7 = claim_text(strong_nodes, t7_value);
      strong_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      t8 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button0 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t9 = claim_text(button0_nodes, "←");
      button0_nodes.forEach(detach_dev);
      t10 = claim_space(div0_nodes);
      button1 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t11 = claim_text(button1_nodes, "→");
      button1_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(select_1, "class", select_1_class_value = "paginator-select " + ctx[3]);
      attr_dev(select_1, "aria-label", "Select Amount");
      if (ctx[0].limit === void 0)
        add_render_callback(() => ctx[12].call(select_1));
      add_location(select_1, file19, 48, 2, 1659);
      attr_dev(label, "class", label_class_value = "paginator-label " + ctx[4]);
      add_location(label, file19, 47, 1, 1610);
      attr_dev(span0, "class", "opacity-50 px-2");
      add_location(span0, file19, 54, 121, 2106);
      add_location(strong, file19, 54, 160, 2145);
      attr_dev(span1, "class", span1_class_value = "paginator-details " + ctx[2]);
      add_location(span1, file19, 53, 1, 1934);
      attr_dev(button0, "class", button0_class_value = "btn-icon " + ctx[1]);
      button0.disabled = button0_disabled_value = ctx[0].offset === 0;
      add_location(button0, file19, 58, 2, 2248);
      attr_dev(button1, "class", button1_class_value = "btn-icon " + ctx[1]);
      button1.disabled = button1_disabled_value = (ctx[0].offset + 1) * ctx[0].limit >= ctx[0].size;
      add_location(button1, file19, 59, 2, 2364);
      attr_dev(div0, "class", "paginator-arrows space-x-2");
      add_location(div0, file19, 57, 1, 2205);
      attr_dev(div1, "class", div1_class_value = "paginator " + ctx[5]);
      attr_dev(div1, "data-testid", "paginator");
      add_location(div1, file19, 45, 0, 1523);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label);
      append_hydration_dev(label, select_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select_1, null);
      }
      select_option(select_1, ctx[0].limit);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, span1);
      append_hydration_dev(span1, t1);
      append_hydration_dev(span1, t2);
      append_hydration_dev(span1, t3);
      append_hydration_dev(span1, t4);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t5);
      append_hydration_dev(span1, t6);
      append_hydration_dev(span1, strong);
      append_hydration_dev(strong, t7);
      append_hydration_dev(div1, t8);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, button0);
      append_hydration_dev(button0, t9);
      append_hydration_dev(div0, t10);
      append_hydration_dev(div0, button1);
      append_hydration_dev(button1, t11);
      if (!mounted) {
        dispose = [
          listen_dev(select_1, "change", ctx[12]),
          listen_dev(select_1, "change", ctx[13], false, false, false),
          listen_dev(button0, "click", ctx[14], false, false, false),
          listen_dev(button1, "click", ctx[15], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0].amounts;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select_1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 8 && select_1_class_value !== (select_1_class_value = "paginator-select " + ctx2[3])) {
        attr_dev(select_1, "class", select_1_class_value);
      }
      if (dirty & 1) {
        select_option(select_1, ctx2[0].limit);
      }
      if (dirty & 16 && label_class_value !== (label_class_value = "paginator-label " + ctx2[4])) {
        attr_dev(label, "class", label_class_value);
      }
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0].offset * ctx2[0].limit + 1 + ""))
        set_data_dev(t1, t1_value);
      if (dirty & 1 && t3_value !== (t3_value = Math.min(ctx2[0].offset * ctx2[0].limit + ctx2[0].limit, ctx2[0].size) + ""))
        set_data_dev(t3, t3_value);
      if (dirty & 1 && t7_value !== (t7_value = ctx2[0].size + ""))
        set_data_dev(t7, t7_value);
      if (dirty & 4 && span1_class_value !== (span1_class_value = "paginator-details " + ctx2[2])) {
        attr_dev(span1, "class", span1_class_value);
      }
      if (dirty & 2 && button0_class_value !== (button0_class_value = "btn-icon " + ctx2[1])) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty & 1 && button0_disabled_value !== (button0_disabled_value = ctx2[0].offset === 0)) {
        prop_dev(button0, "disabled", button0_disabled_value);
      }
      if (dirty & 2 && button1_class_value !== (button1_class_value = "btn-icon " + ctx2[1])) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty & 1 && button1_disabled_value !== (button1_disabled_value = (ctx2[0].offset + 1) * ctx2[0].limit >= ctx2[0].size)) {
        prop_dev(button1, "disabled", button1_disabled_value);
      }
      if (dirty & 32 && div1_class_value !== (div1_class_value = "paginator " + ctx2[5])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase12 = "flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4";
var cLabel3 = "w-full md:w-auto";
var cPageText = "whitespace-nowrap";
function instance19($$self, $$props, $$invalidate) {
  let classesBase;
  let classesLabel;
  let classesSelect;
  let classesPageText;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Paginator", slots, []);
  const dispatch = createEventDispatcher();
  let { settings = {
    offset: 0,
    limit: 5,
    size: 0,
    amounts: [1, 2, 5, 10]
  } } = $$props;
  let { justify = "justify-between" } = $$props;
  let { text: text2 = "text-xs" } = $$props;
  let { select = void 0 } = $$props;
  let { buttons = "btn-filled" } = $$props;
  function onChangeLength() {
    $$invalidate(0, settings.offset = 0, settings);
    dispatch("amount", length);
  }
  function onPrev() {
    $$invalidate(0, settings.offset--, settings);
    dispatch("page", settings.offset);
  }
  function onNext() {
    $$invalidate(0, settings.offset++, settings);
    dispatch("page", settings.offset);
  }
  function select_1_change_handler() {
    settings.limit = select_value(this);
    $$invalidate(0, settings);
  }
  const change_handler = () => {
    onChangeLength();
  };
  const click_handler = () => {
    onPrev();
  };
  const click_handler_1 = () => {
    onNext();
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("settings" in $$new_props)
      $$invalidate(0, settings = $$new_props.settings);
    if ("justify" in $$new_props)
      $$invalidate(9, justify = $$new_props.justify);
    if ("text" in $$new_props)
      $$invalidate(10, text2 = $$new_props.text);
    if ("select" in $$new_props)
      $$invalidate(11, select = $$new_props.select);
    if ("buttons" in $$new_props)
      $$invalidate(1, buttons = $$new_props.buttons);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    settings,
    justify,
    text: text2,
    select,
    buttons,
    cBase: cBase12,
    cLabel: cLabel3,
    cPageText,
    onChangeLength,
    onPrev,
    onNext,
    classesPageText,
    classesSelect,
    classesLabel,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    if ("settings" in $$props)
      $$invalidate(0, settings = $$new_props.settings);
    if ("justify" in $$props)
      $$invalidate(9, justify = $$new_props.justify);
    if ("text" in $$props)
      $$invalidate(10, text2 = $$new_props.text);
    if ("select" in $$props)
      $$invalidate(11, select = $$new_props.select);
    if ("buttons" in $$props)
      $$invalidate(1, buttons = $$new_props.buttons);
    if ("classesPageText" in $$props)
      $$invalidate(2, classesPageText = $$new_props.classesPageText);
    if ("classesSelect" in $$props)
      $$invalidate(3, classesSelect = $$new_props.classesSelect);
    if ("classesLabel" in $$props)
      $$invalidate(4, classesLabel = $$new_props.classesLabel);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, classesBase = `${cBase12} ${justify} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 2048) {
      $:
        $$invalidate(3, classesSelect = `${select}`);
    }
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(2, classesPageText = `${cPageText} ${text2}`);
    }
  };
  $:
    $$invalidate(4, classesLabel = `${cLabel3}`);
  $$props = exclude_internal_props($$props);
  return [
    settings,
    buttons,
    classesPageText,
    classesSelect,
    classesLabel,
    classesBase,
    onChangeLength,
    onPrev,
    onNext,
    justify,
    text2,
    select,
    select_1_change_handler,
    change_handler,
    click_handler,
    click_handler_1
  ];
}
var Paginator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      settings: 0,
      justify: 9,
      text: 10,
      select: 11,
      buttons: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Paginator",
      options,
      id: create_fragment19.name
    });
  }
  get settings() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get select() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set select(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttons() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttons(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Paginator_default = Paginator;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/ProgressBar/ProgressBar.svelte
var file20 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\ProgressBar\\ProgressBar.svelte";
function add_css3(target) {
  append_styles(target, "svelte-meqa4r", ".animIndeterminate.svelte-meqa4r{transform-origin:0% 50%;animation:svelte-meqa4r-animIndeterminate 2s infinite linear}@keyframes svelte-meqa4r-animIndeterminate{0%{transform:translateX(0) scaleX(0)}40%{transform:translateX(0) scaleX(0.4)}100%{transform:translateX(100%) scaleX(0.5)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZ3Jlc3NCYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXVEQyxrQkFBQSxjQUFBLENBQUEsQUFDQyxnQkFBQSxDQUFBLEVBQUEsQ0FBQSxHQUF3QixDQUN4QixTQUFBLENBQUEsK0JBQUEsQ0FBQSxFQUFBLENBQUEsUUFBQSxDQUFBLE1BQStDLEFBQ2hELENBQUEsQUFFQSxXQUFBLCtCQUFBLENBQUEsQUFDQyxFQUFBLEFBQUEsQ0FBQSxBQUFLLFNBQUEsQ0FBQSxXQUFBLENBQUEsQ0FBQSxDQUFBLE9BQUEsQ0FBQSxDQUFrQyxBQUFFLENBQUEsQUFDekMsR0FBQSxBQUFBLENBQUEsQUFBTSxTQUFBLENBQUEsV0FBQSxDQUFBLENBQUEsQ0FBQSxPQUFBLEdBQUEsQ0FBb0MsQUFBRSxDQUFBLEFBQzVDLElBQUEsQUFBQSxDQUFBLEFBQU8sU0FBQSxDQUFBLFdBQUEsSUFBQSxDQUFBLENBQUEsT0FBQSxHQUFBLENBQXVDLEFBQUUsQ0FBQSxBQUNqRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlByb2dyZXNzQmFyLnN2ZWx0ZSJdfQ== */");
}
function create_if_block_18(ctx) {
  let label_1;
  let t;
  let label_1_class_value;
  const block = {
    c: function create() {
      label_1 = element("label");
      t = text(ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_1_nodes = children(label_1);
      t = claim_text(label_1_nodes, ctx[0]);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "for", "progress");
      attr_dev(label_1, "class", label_1_class_value = "progress-bar-label " + cBaseLabel + " svelte-meqa4r");
      add_location(label_1, file20, 42, 12, 1270);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(43:1) {#if label}",
    ctx
  });
  return block;
}
function create_else_block3(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "progress-bar-meter " + cBaseMeterIndeterminate + " " + ctx[3] + " animIndeterminate svelte-meqa4r");
      add_location(div, file20, 49, 3, 1626);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8 && div_class_value !== (div_class_value = "progress-bar-meter " + cBaseMeterIndeterminate + " " + ctx2[3] + " animIndeterminate svelte-meqa4r")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(49:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block13(ctx) {
  let div;
  let div_class_value;
  let style_width = `${ctx[5]}%`;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "progress-bar-meter " + cBaseMeterDeterminate + " " + ctx[3] + " svelte-meqa4r");
      set_style(div, "width", style_width);
      add_location(div, file20, 47, 3, 1510);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8 && div_class_value !== (div_class_value = "progress-bar-meter " + cBaseMeterDeterminate + " " + ctx2[3] + " svelte-meqa4r")) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & 32 && style_width !== (style_width = `${ctx2[5]}%`)) {
        set_style(div, "width", style_width);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(47:2) {#if value !== undefined && value >= 0}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let div1;
  let t;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let div1_aria_valuemin_value;
  let if_block0 = ctx[0] && create_if_block_18(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] !== void 0 && ctx2[1] >= 0)
      return create_if_block13;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      div0 = element("div");
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-valuenow": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "progress-bar-track " + ctx[4] + " svelte-meqa4r");
      add_location(div0, file20, 44, 1, 1370);
      attr_dev(div1, "class", div1_class_value = "progress-bar " + cBase13 + " svelte-meqa4r");
      attr_dev(div1, "data-testid", "progress-bar");
      attr_dev(div1, "role", "progressbar");
      attr_dev(div1, "aria-label", ctx[0]);
      attr_dev(div1, "aria-valuenow", ctx[1]);
      attr_dev(div1, "aria-valuemin", div1_aria_valuemin_value = 0);
      attr_dev(div1, "aria-valuemax", ctx[2]);
      add_location(div1, file20, 32, 0, 1074);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if_block1.m(div0, null);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_18(ctx2);
          if_block0.c();
          if_block0.m(div1, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div0, null);
        }
      }
      if (dirty & 16 && div0_class_value !== (div0_class_value = "progress-bar-track " + ctx2[4] + " svelte-meqa4r")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & 1) {
        attr_dev(div1, "aria-label", ctx2[0]);
      }
      if (dirty & 2) {
        attr_dev(div1, "aria-valuenow", ctx2[1]);
      }
      if (dirty & 4) {
        attr_dev(div1, "aria-valuemax", ctx2[2]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase13 = "w-full";
var cBaseLabel = "block text-sm mb-2";
var cBaseMeterDeterminate = "h-full";
var cBaseMeterIndeterminate = "h-full w-full";
function instance20($$self, $$props, $$invalidate) {
  let fillPercent;
  let classesTrack;
  let classesMeter;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressBar", slots, []);
  let { label = "" } = $$props;
  let { value = void 0 } = $$props;
  let { max = 100 } = $$props;
  let { height = "h-2" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { meter = "bg-accent-500" } = $$props;
  let { track = "bg-surface-200-700-token" } = $$props;
  const cBaseTrack2 = `w-full overflow-hidden`;
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("max" in $$new_props)
      $$invalidate(2, max = $$new_props.max);
    if ("height" in $$new_props)
      $$invalidate(6, height = $$new_props.height);
    if ("rounded" in $$new_props)
      $$invalidate(7, rounded = $$new_props.rounded);
    if ("meter" in $$new_props)
      $$invalidate(8, meter = $$new_props.meter);
    if ("track" in $$new_props)
      $$invalidate(9, track = $$new_props.track);
  };
  $$self.$capture_state = () => ({
    label,
    value,
    max,
    height,
    rounded,
    meter,
    track,
    cBase: cBase13,
    cBaseLabel,
    cBaseTrack: cBaseTrack2,
    cBaseMeterDeterminate,
    cBaseMeterIndeterminate,
    classesMeter,
    classesTrack,
    fillPercent
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("max" in $$props)
      $$invalidate(2, max = $$new_props.max);
    if ("height" in $$props)
      $$invalidate(6, height = $$new_props.height);
    if ("rounded" in $$props)
      $$invalidate(7, rounded = $$new_props.rounded);
    if ("meter" in $$props)
      $$invalidate(8, meter = $$new_props.meter);
    if ("track" in $$props)
      $$invalidate(9, track = $$new_props.track);
    if ("classesMeter" in $$props)
      $$invalidate(3, classesMeter = $$new_props.classesMeter);
    if ("classesTrack" in $$props)
      $$invalidate(4, classesTrack = $$new_props.classesTrack);
    if ("fillPercent" in $$props)
      $$invalidate(5, fillPercent = $$new_props.fillPercent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      $:
        $$invalidate(5, fillPercent = value ? 100 * value / max : 0);
    }
    $:
      $$invalidate(4, classesTrack = `${cBaseTrack2} ${height} ${rounded} ${track} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 384) {
      $:
        $$invalidate(3, classesMeter = `${rounded} ${meter}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    value,
    max,
    classesMeter,
    classesTrack,
    fillPercent,
    height,
    rounded,
    meter,
    track
  ];
}
var ProgressBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance20,
      create_fragment20,
      safe_not_equal,
      {
        label: 0,
        value: 1,
        max: 2,
        height: 6,
        rounded: 7,
        meter: 8,
        track: 9
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressBar",
      options,
      id: create_fragment20.name
    });
  }
  get label() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get meter() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meter(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get track() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressBar_default = ProgressBar;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/ProgressRadial/ProgressRadial.svelte
var file21 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\ProgressRadial\\ProgressRadial.svelte";
function create_if_block14(ctx) {
  let text_1;
  let text_1_class_value;
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      text_1 = claim_svg_element(nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        "dominant-baseline": true,
        "font-weight": true,
        "font-size": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      if (default_slot)
        default_slot.l(text_1_nodes);
      text_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", "50%");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "font-weight", "bold");
      attr_dev(text_1, "font-size", ctx[5]);
      attr_dev(text_1, "class", text_1_class_value = "progress-radial-text " + ctx[4]);
      add_location(text_1, file21, 77, 3, 2442);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, text_1, anchor);
      if (default_slot) {
        default_slot.m(text_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32) {
        attr_dev(text_1, "font-size", ctx2[5]);
      }
      if (!current || dirty & 16 && text_1_class_value !== (text_1_class_value = "progress-radial-text " + ctx2[4])) {
        attr_dev(text_1, "class", text_1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(77:2) {#if value && value >= 0 && $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let figure;
  let svg;
  let circle0;
  let circle0_class_value;
  let circle0_r_value;
  let circle1;
  let circle1_class_value;
  let circle1_r_value;
  let style_stroke_dasharray = `${ctx[7]}
			${ctx[7]}`;
  let svg_viewBox_value;
  let figure_class_value;
  let figure_aria_valuenow_value;
  let figure_aria_valuetext_value;
  let figure_aria_valuemin_value;
  let figure_aria_valuemax_value;
  let current;
  let if_block = ctx[0] && ctx[0] >= 0 && ctx[10].default && create_if_block14(ctx);
  const block = {
    c: function create() {
      figure = element("figure");
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-valuenow": true,
        "aria-valuetext": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var figure_nodes = children(figure);
      svg = claim_svg_element(figure_nodes, "svg", { viewBox: true, class: true });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        r: true,
        cx: true,
        cy: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        r: true,
        cx: true,
        cy: true
      });
      children(circle1).forEach(detach_dev);
      if (if_block)
        if_block.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "class", circle0_class_value = "progress-radial-track " + cBaseTrack + " " + ctx[3]);
      attr_dev(circle0, "stroke-width", ctx[1]);
      attr_dev(circle0, "r", circle0_r_value = baseSize / 2);
      attr_dev(circle0, "cx", "50%");
      attr_dev(circle0, "cy", "50%");
      add_location(circle0, file21, 61, 2, 1990);
      attr_dev(circle1, "class", circle1_class_value = "progress-radial-meter " + cBaseMeter + " " + ctx[2]);
      attr_dev(circle1, "stroke-width", ctx[1]);
      attr_dev(circle1, "r", circle1_r_value = baseSize / 2);
      attr_dev(circle1, "cx", "50%");
      attr_dev(circle1, "cy", "50%");
      set_style(circle1, "stroke-dasharray", style_stroke_dasharray);
      set_style(circle1, "stroke-dashoffset", ctx[8]);
      add_location(circle1, file21, 64, 2, 2129);
      attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + baseSize + " " + baseSize);
      attr_dev(svg, "class", "rounded-full");
      toggle_class(svg, "animate-spin", ctx[0] === void 0);
      add_location(svg, file21, 59, 1, 1867);
      attr_dev(figure, "class", figure_class_value = "progress-radial " + ctx[9]);
      attr_dev(figure, "data-testid", "progress-radial");
      attr_dev(figure, "role", "meter");
      attr_dev(figure, "aria-label", ctx[6]);
      attr_dev(figure, "aria-valuenow", figure_aria_valuenow_value = ctx[0] || 0);
      attr_dev(figure, "aria-valuetext", figure_aria_valuetext_value = ctx[0] ? `${ctx[0]}%` : "Indeterminate Spinner");
      attr_dev(figure, "aria-valuemin", figure_aria_valuemin_value = 0);
      attr_dev(figure, "aria-valuemax", figure_aria_valuemax_value = 100);
      add_location(figure, file21, 48, 0, 1601);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      append_hydration_dev(figure, svg);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      if (if_block)
        if_block.m(svg, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 8 && circle0_class_value !== (circle0_class_value = "progress-radial-track " + cBaseTrack + " " + ctx2[3])) {
        attr_dev(circle0, "class", circle0_class_value);
      }
      if (!current || dirty & 2) {
        attr_dev(circle0, "stroke-width", ctx2[1]);
      }
      if (!current || dirty & 4 && circle1_class_value !== (circle1_class_value = "progress-radial-meter " + cBaseMeter + " " + ctx2[2])) {
        attr_dev(circle1, "class", circle1_class_value);
      }
      if (!current || dirty & 2) {
        attr_dev(circle1, "stroke-width", ctx2[1]);
      }
      if (dirty & 128 && style_stroke_dasharray !== (style_stroke_dasharray = `${ctx2[7]}
			${ctx2[7]}`)) {
        set_style(circle1, "stroke-dasharray", style_stroke_dasharray);
      }
      if (dirty & 256) {
        set_style(circle1, "stroke-dashoffset", ctx2[8]);
      }
      if (ctx2[0] && ctx2[0] >= 0 && ctx2[10].default) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1025) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(svg, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 1) {
        toggle_class(svg, "animate-spin", ctx2[0] === void 0);
      }
      if (!current || dirty & 512 && figure_class_value !== (figure_class_value = "progress-radial " + ctx2[9])) {
        attr_dev(figure, "class", figure_class_value);
      }
      if (!current || dirty & 64) {
        attr_dev(figure, "aria-label", ctx2[6]);
      }
      if (!current || dirty & 1 && figure_aria_valuenow_value !== (figure_aria_valuenow_value = ctx2[0] || 0)) {
        attr_dev(figure, "aria-valuenow", figure_aria_valuenow_value);
      }
      if (!current || dirty & 1 && figure_aria_valuetext_value !== (figure_aria_valuetext_value = ctx2[0] ? `${ctx2[0]}%` : "Indeterminate Spinner")) {
        attr_dev(figure, "aria-valuetext", figure_aria_valuetext_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figure);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase14 = "progress-radial relative overflow-hidden";
var cBaseTrack = "fill-transparent";
var cBaseMeter = "fill-transparent transition-[stroke-dashoffset] duration-200 -rotate-90 origin-[50%_50%]";
var baseSize = 512;
function instance21($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressRadial", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { value = void 0 } = $$props;
  let { stroke = 20 } = $$props;
  let { meter = "stroke-accent-500" } = $$props;
  let { track = "stroke-surface-200 dark:stroke-surface-700" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { font = 56 } = $$props;
  let { label = "" } = $$props;
  const radius = baseSize / 2;
  let circumference = radius;
  let dashoffset;
  function setProgress(percent) {
    $$invalidate(7, circumference = radius * 2 * Math.PI);
    $$invalidate(8, dashoffset = circumference - percent / 100 * circumference);
  }
  setProgress(0);
  afterUpdate(() => {
    setProgress(value === void 0 ? 25 : value);
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("stroke" in $$new_props)
      $$invalidate(1, stroke = $$new_props.stroke);
    if ("meter" in $$new_props)
      $$invalidate(2, meter = $$new_props.meter);
    if ("track" in $$new_props)
      $$invalidate(3, track = $$new_props.track);
    if ("fill" in $$new_props)
      $$invalidate(4, fill = $$new_props.fill);
    if ("font" in $$new_props)
      $$invalidate(5, font = $$new_props.font);
    if ("label" in $$new_props)
      $$invalidate(6, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    value,
    stroke,
    meter,
    track,
    fill,
    font,
    label,
    cBase: cBase14,
    cBaseTrack,
    cBaseMeter,
    baseSize,
    radius,
    circumference,
    dashoffset,
    setProgress,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("stroke" in $$props)
      $$invalidate(1, stroke = $$new_props.stroke);
    if ("meter" in $$props)
      $$invalidate(2, meter = $$new_props.meter);
    if ("track" in $$props)
      $$invalidate(3, track = $$new_props.track);
    if ("fill" in $$props)
      $$invalidate(4, fill = $$new_props.fill);
    if ("font" in $$props)
      $$invalidate(5, font = $$new_props.font);
    if ("label" in $$props)
      $$invalidate(6, label = $$new_props.label);
    if ("circumference" in $$props)
      $$invalidate(7, circumference = $$new_props.circumference);
    if ("dashoffset" in $$props)
      $$invalidate(8, dashoffset = $$new_props.dashoffset);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classesBase = `${cBase14} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    stroke,
    meter,
    track,
    fill,
    font,
    label,
    circumference,
    dashoffset,
    classesBase,
    $$slots,
    $$scope,
    slots
  ];
}
var ProgressRadial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      value: 0,
      stroke: 1,
      meter: 2,
      track: 3,
      fill: 4,
      font: 5,
      label: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressRadial",
      options,
      id: create_fragment21.name
    });
  }
  get value() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get meter() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meter(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get track() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get font() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set font(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressRadial_default = ProgressRadial;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Radio/RadioGroup.svelte
var file22 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Radio\\RadioGroup.svelte";
function create_fragment22(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "radio-group " + ctx[1]);
      attr_dev(div, "data-testid", "radio-group");
      attr_dev(div, "role", "radiogroup");
      attr_dev(div, "aria-label", ctx[0]);
      add_location(div, file22, 45, 0, 1865);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && div_class_value !== (div_class_value = "radio-group " + ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 1) {
        attr_dev(div, "aria-label", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let classesGroup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroup", slots, ["default"]);
  let { selected = writable(void 0) } = $$props;
  let { display = "inline-flex" } = $$props;
  let { background = "bg-surface-200-700-token" } = $$props;
  let { borderWidth = "border-token" } = $$props;
  let { borderColor = "border-surface-300 dark:border-surface-600" } = $$props;
  let { padding = "px-4 py-2" } = $$props;
  let { hover = "bg-accent-hover-token" } = $$props;
  let { accent = "bg-accent-active-token" } = $$props;
  let { color = "text-surface-50" } = $$props;
  let { fill = "" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { label = "radiogroup" } = $$props;
  setContext("selected", selected);
  setContext("padding", padding);
  setContext("hover", hover);
  setContext("accent", accent);
  setContext("color", color);
  setContext("fill", fill);
  setContext("rounded", rounded);
  let cBaseGroup = `items-center p-1 overflow-hidden space-x-1 rounded-token`;
  $$self.$$set = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$invalidate(2, selected = $$new_props.selected);
    if ("display" in $$new_props)
      $$invalidate(3, display = $$new_props.display);
    if ("background" in $$new_props)
      $$invalidate(4, background = $$new_props.background);
    if ("borderWidth" in $$new_props)
      $$invalidate(5, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$new_props)
      $$invalidate(6, borderColor = $$new_props.borderColor);
    if ("padding" in $$new_props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("hover" in $$new_props)
      $$invalidate(8, hover = $$new_props.hover);
    if ("accent" in $$new_props)
      $$invalidate(9, accent = $$new_props.accent);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    writable,
    setContext,
    selected,
    display,
    background,
    borderWidth,
    borderColor,
    padding,
    hover,
    accent,
    color,
    fill,
    rounded,
    label,
    cBaseGroup,
    classesGroup
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(2, selected = $$new_props.selected);
    if ("display" in $$props)
      $$invalidate(3, display = $$new_props.display);
    if ("background" in $$props)
      $$invalidate(4, background = $$new_props.background);
    if ("borderWidth" in $$props)
      $$invalidate(5, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$props)
      $$invalidate(6, borderColor = $$new_props.borderColor);
    if ("padding" in $$props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("hover" in $$props)
      $$invalidate(8, hover = $$new_props.hover);
    if ("accent" in $$props)
      $$invalidate(9, accent = $$new_props.accent);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("cBaseGroup" in $$props)
      $$invalidate(15, cBaseGroup = $$new_props.cBaseGroup);
    if ("classesGroup" in $$props)
      $$invalidate(1, classesGroup = $$new_props.classesGroup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classesGroup = `${cBaseGroup} ${display} ${background} ${borderColor} ${borderWidth} ${rounded} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    classesGroup,
    selected,
    display,
    background,
    borderWidth,
    borderColor,
    padding,
    hover,
    accent,
    color,
    fill,
    rounded,
    $$scope,
    slots
  ];
}
var RadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      selected: 2,
      display: 3,
      background: 4,
      borderWidth: 5,
      borderColor: 6,
      padding: 7,
      hover: 8,
      accent: 9,
      color: 10,
      fill: 11,
      rounded: 12,
      label: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroup",
      options,
      id: create_fragment22.name
    });
  }
  get selected() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get display() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set display(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroup_default = RadioGroup;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Radio/RadioItem.svelte
var file23 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Radio\\RadioItem.svelte";
function create_fragment23(ctx) {
  let div;
  let label_1;
  let input;
  let t;
  let label_1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  let div_levels = [
    { class: "radio-item flex-auto" },
    { role: "radio" },
    { "aria-checked": ctx[3] },
    { "aria-label": ctx[1] },
    ctx[7](),
    { tabindex: "0" },
    { "data-testid": "radio-item" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      label_1 = element("label");
      input = element("input");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-checked": true,
        "aria-label": true,
        tabindex: true,
        "data-testid": true
      });
      var div_nodes = children(div);
      label_1 = claim_element(div_nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      input = claim_element(label_1_nodes, "INPUT", { class: true, type: true });
      t = claim_space(label_1_nodes);
      if (default_slot)
        default_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "radio-item-input hidden");
      attr_dev(input, "type", "radio");
      input.__value = ctx[0];
      input.value = input.__value;
      ctx[19][0].push(input);
      add_location(input, file23, 55, 2, 1661);
      attr_dev(label_1, "class", label_1_class_value = "radio-item-label " + ctx[5]);
      add_location(label_1, file23, 54, 1, 1611);
      set_attributes(div, div_data);
      add_location(div, file23, 43, 0, 1417);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, label_1);
      append_hydration_dev(label_1, input);
      input.checked = input.__value === ctx[4];
      append_hydration_dev(label_1, t);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[18]),
          listen_dev(div, "click", ctx[17], false, false, false),
          listen_dev(div, "keydown", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1) {
        prop_dev(input, "__value", ctx2[0]);
        input.value = input.__value;
      }
      if (dirty & 16) {
        input.checked = input.__value === ctx2[4];
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32 && label_1_class_value !== (label_1_class_value = "radio-item-label " + ctx2[5])) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { class: "radio-item flex-auto" },
        { role: "radio" },
        (!current || dirty & 8) && { "aria-checked": ctx2[3] },
        (!current || dirty & 2) && { "aria-label": ctx2[1] },
        ctx2[7](),
        { tabindex: "0" },
        { "data-testid": "radio-item" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[19][0].splice(ctx[19][0].indexOf(input), 1);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase15 = " font-bold text-base text-center cursor-pointer whitespace-nowrap";
function instance23($$self, $$props, $$invalidate) {
  let checked;
  let classesSelected;
  let classesLabel;
  const omit_props_names = ["value", "label", "selected", "padding", "hover", "accent", "color", "fill", "rounded"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selected, $$unsubscribe_selected = noop, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(4, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioItem", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { value = void 0 } = $$props;
  let { label = "" } = $$props;
  let { selected = getContext("selected") } = $$props;
  validate_store(selected, "selected");
  $$subscribe_selected();
  let { padding = getContext("padding") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { accent = getContext("accent") } = $$props;
  let { color = getContext("color") } = $$props;
  let { fill = getContext("fill") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  function onKeyDown3(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      dispatch("keydown", event);
      event.target.children[0].click();
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  const $$binding_groups = [[]];
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    $selected = this.__value;
    selected.set($selected);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("selected" in $$new_props)
      $$subscribe_selected($$invalidate(2, selected = $$new_props.selected));
    if ("padding" in $$new_props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("hover" in $$new_props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("accent" in $$new_props)
      $$invalidate(10, accent = $$new_props.accent);
    if ("color" in $$new_props)
      $$invalidate(11, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(12, fill = $$new_props.fill);
    if ("rounded" in $$new_props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    dispatch,
    value,
    label,
    selected,
    padding,
    hover,
    accent,
    color,
    fill,
    rounded,
    cBase: cBase15,
    onKeyDown: onKeyDown3,
    prunedRestProps,
    classesSelected,
    classesLabel,
    checked,
    $selected
  });
  $$self.$inject_state = ($$new_props) => {
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("selected" in $$props)
      $$subscribe_selected($$invalidate(2, selected = $$new_props.selected));
    if ("padding" in $$props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("hover" in $$props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("accent" in $$props)
      $$invalidate(10, accent = $$new_props.accent);
    if ("color" in $$props)
      $$invalidate(11, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(12, fill = $$new_props.fill);
    if ("rounded" in $$props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("classesSelected" in $$props)
      $$invalidate(14, classesSelected = $$new_props.classesSelected);
    if ("classesLabel" in $$props)
      $$invalidate(5, classesLabel = $$new_props.classesLabel);
    if ("checked" in $$props)
      $$invalidate(3, checked = $$new_props.checked);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 17) {
      $:
        $$invalidate(3, checked = value === $selected);
    }
    if ($$self.$$.dirty & 7688) {
      $:
        $$invalidate(14, classesSelected = checked ? `${accent} ${fill} ${color}` : `${hover}`);
    }
    if ($$self.$$.dirty & 24832) {
      $:
        $$invalidate(5, classesLabel = `${cBase15} ${classesSelected} ${padding} ${rounded}`);
    }
  };
  return [
    value,
    label,
    selected,
    checked,
    $selected,
    classesLabel,
    onKeyDown3,
    prunedRestProps,
    padding,
    hover,
    accent,
    color,
    fill,
    rounded,
    classesSelected,
    $$scope,
    slots,
    click_handler,
    input_change_handler,
    $$binding_groups
  ];
}
var RadioItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      value: 0,
      label: 1,
      selected: 2,
      padding: 8,
      hover: 9,
      accent: 10,
      color: 11,
      fill: 12,
      rounded: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioItem",
      options,
      id: create_fragment23.name
    });
  }
  get value() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioItem_default = RadioItem;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/RangeSlider/RangeSlider.svelte
var file24 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\RangeSlider\\RangeSlider.svelte";
var get_trail_slot_changes5 = (dirty) => ({});
var get_trail_slot_context5 = (ctx) => ({});
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_if_block_24(ctx) {
  let label_1;
  let label_1_class_value;
  let current;
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  const block = {
    c: function create() {
      label_1 = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_1_nodes = children(label_1);
      if (default_slot)
        default_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "class", label_1_class_value = "range-slider-label " + cBaseLabel2);
      attr_dev(label_1, "for", ctx[5]);
      add_location(label_1, file24, 63, 22, 1665);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32) {
        attr_dev(label_1, "for", ctx2[5]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(64:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let datalist;
  let datalist_id_value;
  let each_value = ctx[8];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      datalist = element("datalist");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      datalist = claim_element(nodes, "DATALIST", { id: true, class: true });
      var datalist_nodes = children(datalist);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(datalist_nodes);
      }
      datalist_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(datalist, "id", datalist_id_value = "tickmarks-" + ctx[5]);
      attr_dev(datalist, "class", "range-slider-ticks");
      add_location(datalist, file24, 88, 2, 2143);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, datalist, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(datalist, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 256) {
        each_value = ctx2[8];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(datalist, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 32 && datalist_id_value !== (datalist_id_value = "tickmarks-" + ctx2[5])) {
        attr_dev(datalist, "id", datalist_id_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(datalist);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(88:2) {#if ticked && tickmarks && tickmarks.length}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let option;
  let option_value_value;
  let option_label_value;
  const block = {
    c: function create() {
      option = element("option");
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { label: true });
      children(option).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = ctx[23];
      option.value = option.__value;
      attr_dev(option, "label", option_label_value = ctx[23]);
      add_location(option, file24, 90, 3, 2231);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 256 && option_value_value !== (option_value_value = ctx2[23])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
      if (dirty & 256 && option_label_value !== (option_label_value = ctx2[23])) {
        attr_dev(option, "label", option_label_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(90:3) {#each tickmarks as tm}",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let div;
  let current;
  const trail_slot_template = ctx[15].trail;
  const trail_slot = create_slot(trail_slot_template, ctx, ctx[14], get_trail_slot_context5);
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "range-slider-trail");
      add_location(div, file24, 98, 20, 2349);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(trail_slot_template, ctx2[14], dirty, get_trail_slot_changes5),
            get_trail_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(99:1) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let div1;
  let t0;
  let div0;
  let input;
  let input_class_value;
  let input_list_value;
  let t1;
  let div0_class_value;
  let t2;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[12].default && create_if_block_24(ctx);
  let input_levels = [
    { type: "range" },
    { id: ctx[5] },
    { name: ctx[6] },
    {
      class: input_class_value = "range-slider-input " + ctx[9]
    },
    {
      list: input_list_value = "tickmarks-" + ctx[5]
    },
    { "aria-label": ctx[7] },
    { min: ctx[1] },
    { max: ctx[2] },
    { step: ctx[3] },
    ctx[11]()
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block1 = ctx[4] && ctx[8] && ctx[8].length && create_if_block_19(ctx);
  let if_block2 = ctx[12].trail && create_if_block15(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      input = element("input");
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        class: true,
        list: true,
        "aria-label": true,
        min: true,
        max: true,
        step: true
      });
      t1 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file24, 69, 2, 1829);
      attr_dev(div0, "class", div0_class_value = "range-content " + cBaseContent);
      add_location(div0, file24, 66, 1, 1763);
      attr_dev(div1, "class", div1_class_value = "range-slider " + ctx[10]);
      attr_dev(div1, "data-testid", "range-slider");
      add_location(div1, file24, 57, 0, 1539);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[0]);
      append_hydration_dev(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[19]),
          listen_dev(input, "input", ctx[19]),
          listen_dev(input, "click", ctx[16], false, false, false),
          listen_dev(input, "change", ctx[17], false, false, false),
          listen_dev(input, "blur", ctx[18], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[12].default) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_24(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "range" },
        (!current || dirty & 32) && { id: ctx2[5] },
        (!current || dirty & 64) && { name: ctx2[6] },
        (!current || dirty & 512 && input_class_value !== (input_class_value = "range-slider-input " + ctx2[9])) && { class: input_class_value },
        (!current || dirty & 32 && input_list_value !== (input_list_value = "tickmarks-" + ctx2[5])) && { list: input_list_value },
        (!current || dirty & 128) && { "aria-label": ctx2[7] },
        (!current || dirty & 2) && { min: ctx2[1] },
        (!current || dirty & 4) && { max: ctx2[2] },
        (!current || dirty & 8) && { step: ctx2[3] },
        ctx2[11]()
      ]));
      if (dirty & 1) {
        set_input_value(input, ctx2[0]);
      }
      if (ctx2[4] && ctx2[8] && ctx2[8].length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_19(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[12].trail) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 4096) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block15(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & 1024 && div1_class_value !== (div1_class_value = "range-slider " + ctx2[10])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase16 = "space-y-2";
var cBaseLabel2 = "";
var cBaseContent = "flex justify-center py-2";
var cBaseInput = "w-full h-2";
function instance24($$self, $$props, $$invalidate) {
  let classesBase;
  let classesInput;
  const omit_props_names = ["value", "min", "max", "step", "ticked", "accent", "id", "name", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RangeSlider", slots, ["default", "trail"]);
  const $$slots = compute_slots(slots);
  let { value = 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { ticked = false } = $$props;
  let { accent = "accent-accent-token" } = $$props;
  let { id = crypto.randomUUID() } = $$props;
  let { name = id } = $$props;
  let { label = "" } = $$props;
  let tickmarks;
  function setTicks() {
    if (ticked == false)
      return;
    $$invalidate(8, tickmarks = Array.from({ length: max - min + 1 }, (_, i) => i + 1));
  }
  afterUpdate(() => {
    setTicks();
  });
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(2, max = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(3, step = $$new_props.step);
    if ("ticked" in $$new_props)
      $$invalidate(4, ticked = $$new_props.ticked);
    if ("accent" in $$new_props)
      $$invalidate(13, accent = $$new_props.accent);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(6, name = $$new_props.name);
    if ("label" in $$new_props)
      $$invalidate(7, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    value,
    min,
    max,
    step,
    ticked,
    accent,
    id,
    name,
    label,
    cBase: cBase16,
    cBaseLabel: cBaseLabel2,
    cBaseContent,
    cBaseInput,
    tickmarks,
    setTicks,
    prunedRestProps,
    classesInput,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(2, max = $$new_props.max);
    if ("step" in $$props)
      $$invalidate(3, step = $$new_props.step);
    if ("ticked" in $$props)
      $$invalidate(4, ticked = $$new_props.ticked);
    if ("accent" in $$props)
      $$invalidate(13, accent = $$new_props.accent);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("name" in $$props)
      $$invalidate(6, name = $$new_props.name);
    if ("label" in $$props)
      $$invalidate(7, label = $$new_props.label);
    if ("tickmarks" in $$props)
      $$invalidate(8, tickmarks = $$new_props.tickmarks);
    if ("classesInput" in $$props)
      $$invalidate(9, classesInput = $$new_props.classesInput);
    if ("classesBase" in $$props)
      $$invalidate(10, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(10, classesBase = `${cBase16} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(9, classesInput = `${cBaseInput} ${accent}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    min,
    max,
    step,
    ticked,
    id,
    name,
    label,
    tickmarks,
    classesInput,
    classesBase,
    prunedRestProps,
    $$slots,
    accent,
    $$scope,
    slots,
    click_handler,
    change_handler,
    blur_handler,
    input_change_input_handler
  ];
}
var RangeSlider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      value: 0,
      min: 1,
      max: 2,
      step: 3,
      ticked: 4,
      accent: 13,
      id: 5,
      name: 6,
      label: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RangeSlider",
      options,
      id: create_fragment24.name
    });
  }
  get value() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticked() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticked(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RangeSlider_default = RangeSlider;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/SlideToggle/SlideToggle.svelte
var file25 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\SlideToggle\\SlideToggle.svelte";
function create_if_block16(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[21].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "slide-toggle-text ml-3");
      add_location(div, file25, 94, 23, 3094);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(95:2) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let div2;
  let label_1;
  let input;
  let input_disabled_value;
  let t0;
  let div1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let t1;
  let label_1_class_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    { class: "slide-toggle-input hidden" },
    ctx[7](),
    {
      disabled: input_disabled_value = ctx[8].disabled
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = ctx[9].default && create_if_block16(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      label_1 = element("label");
      input = element("input");
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-checked": true,
        tabindex: true
      });
      var div2_nodes = children(div2);
      label_1 = claim_element(div2_nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      input = claim_element(label_1_nodes, "INPUT", { type: true, class: true });
      t0 = claim_space(label_1_nodes);
      div1 = claim_element(label_1_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(label_1_nodes);
      if (if_block)
        if_block.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file25, 77, 2, 2619);
      attr_dev(div0, "class", div0_class_value = "slide-toggle-thumb " + ctx[2]);
      toggle_class(div0, "cursor-not-allowed", ctx[8].disabled);
      add_location(div0, file25, 91, 3, 2951);
      attr_dev(div1, "class", div1_class_value = "slide-toggle-track " + ctx[3]);
      toggle_class(div1, "cursor-not-allowed", ctx[8].disabled);
      add_location(div1, file25, 90, 2, 2856);
      attr_dev(label_1, "class", label_1_class_value = "slide-toggle-label " + ctx[4]);
      add_location(label_1, file25, 75, 1, 2543);
      attr_dev(div2, "id", ctx[1]);
      attr_dev(div2, "class", div2_class_value = "slide-toggle " + ctx[5]);
      attr_dev(div2, "data-testid", "slide-toggle");
      attr_dev(div2, "role", "switch");
      attr_dev(div2, "aria-label", ctx[1]);
      attr_dev(div2, "aria-checked", ctx[0]);
      attr_dev(div2, "tabindex", "0");
      add_location(div2, file25, 65, 0, 2362);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, label_1);
      append_hydration_dev(label_1, input);
      if (input.autofocus)
        input.focus();
      input.checked = ctx[0];
      append_hydration_dev(label_1, t0);
      append_hydration_dev(label_1, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(label_1, t1);
      if (if_block)
        if_block.m(label_1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[27]),
          listen_dev(input, "click", ctx[22], false, false, false),
          listen_dev(input, "change", ctx[23], false, false, false),
          listen_dev(input, "mouseover", ctx[24], false, false, false),
          listen_dev(input, "focus", ctx[25], false, false, false),
          listen_dev(input, "blur", ctx[26], false, false, false),
          listen_dev(div2, "keydown", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        { class: "slide-toggle-input hidden" },
        ctx2[7](),
        (!current || dirty & 256 && input_disabled_value !== (input_disabled_value = ctx2[8].disabled)) && { disabled: input_disabled_value }
      ]));
      if (dirty & 1) {
        input.checked = ctx2[0];
      }
      if (!current || dirty & 4 && div0_class_value !== (div0_class_value = "slide-toggle-thumb " + ctx2[2])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & 260) {
        toggle_class(div0, "cursor-not-allowed", ctx2[8].disabled);
      }
      if (!current || dirty & 8 && div1_class_value !== (div1_class_value = "slide-toggle-track " + ctx2[3])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & 264) {
        toggle_class(div1, "cursor-not-allowed", ctx2[8].disabled);
      }
      if (ctx2[9].default) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 16 && label_1_class_value !== (label_1_class_value = "slide-toggle-label " + ctx2[4])) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      if (!current || dirty & 2) {
        attr_dev(div2, "id", ctx2[1]);
      }
      if (!current || dirty & 32 && div2_class_value !== (div2_class_value = "slide-toggle " + ctx2[5])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & 2) {
        attr_dev(div2, "aria-label", ctx2[1]);
      }
      if (!current || dirty & 1) {
        attr_dev(div2, "aria-checked", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase17 = "inline-block";
var cLabel4 = "flex items-center";
var cTrack = "flex transition-all duration-[200ms]";
var cThumb = "w-[50%] h-full scale-[0.7] cursor-pointer transition-all duration-[200ms] shadow-lg";
function instance25($$self, $$props, $$invalidate) {
  let cTrackAccent;
  let cThumbBackground;
  let cThumbPos;
  let classesDisabled;
  let classesBase;
  let classesLabel;
  let classesTrack;
  let classesThumb;
  const omit_props_names = ["checked", "size", "accent", "borderWidth", "borderColor", "rounded", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlideToggle", slots, ["default"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { checked = false } = $$props;
  let { size = "md" } = $$props;
  let { accent = "bg-accent-500" } = $$props;
  let { borderWidth = "border-token" } = $$props;
  let { borderColor = "border-surface-300-600-token" } = $$props;
  let { rounded = "rounded-full" } = $$props;
  let { label = "" } = $$props;
  let trackSize;
  switch (size) {
    case "sm":
      trackSize = "w-12 h-6";
      break;
    case "lg":
      trackSize = "w-20 h-10";
      break;
    default:
      trackSize = "w-16 h-8";
  }
  function onKeyDown3(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      dispatch("keyup", event);
      event.target.firstChild.click();
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("size" in $$new_props)
      $$invalidate(10, size = $$new_props.size);
    if ("accent" in $$new_props)
      $$invalidate(11, accent = $$new_props.accent);
    if ("borderWidth" in $$new_props)
      $$invalidate(12, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$new_props)
      $$invalidate(13, borderColor = $$new_props.borderColor);
    if ("rounded" in $$new_props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    checked,
    size,
    accent,
    borderWidth,
    borderColor,
    rounded,
    label,
    cBase: cBase17,
    cLabel: cLabel4,
    cTrack,
    cThumb,
    trackSize,
    onKeyDown: onKeyDown3,
    prunedRestProps,
    cThumbPos,
    cThumbBackground,
    classesThumb,
    cTrackAccent,
    classesTrack,
    classesLabel,
    classesDisabled,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("size" in $$props)
      $$invalidate(10, size = $$new_props.size);
    if ("accent" in $$props)
      $$invalidate(11, accent = $$new_props.accent);
    if ("borderWidth" in $$props)
      $$invalidate(12, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$props)
      $$invalidate(13, borderColor = $$new_props.borderColor);
    if ("rounded" in $$props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("trackSize" in $$props)
      $$invalidate(15, trackSize = $$new_props.trackSize);
    if ("cThumbPos" in $$props)
      $$invalidate(16, cThumbPos = $$new_props.cThumbPos);
    if ("cThumbBackground" in $$props)
      $$invalidate(17, cThumbBackground = $$new_props.cThumbBackground);
    if ("classesThumb" in $$props)
      $$invalidate(2, classesThumb = $$new_props.classesThumb);
    if ("cTrackAccent" in $$props)
      $$invalidate(18, cTrackAccent = $$new_props.cTrackAccent);
    if ("classesTrack" in $$props)
      $$invalidate(3, classesTrack = $$new_props.classesTrack);
    if ("classesLabel" in $$props)
      $$invalidate(4, classesLabel = $$new_props.classesLabel);
    if ("classesDisabled" in $$props)
      $$invalidate(19, classesDisabled = $$new_props.classesDisabled);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2049) {
      $:
        $$invalidate(18, cTrackAccent = checked ? accent : "bg-surface-200-700-token cursor-pointer");
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(17, cThumbBackground = checked ? "bg-white" : "bg-white/50");
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(16, cThumbPos = checked ? "translate-x-full" : "");
    }
    $:
      $$invalidate(19, classesDisabled = $$props.disabled === true ? "opacity-50" : "hover:brightness-[105%] dark:hover:brightness-110 cursor-pointer");
    if ($$self.$$.dirty & 524288) {
      $:
        $$invalidate(5, classesBase = `${cBase17} ${classesDisabled}`);
    }
    $:
      $$invalidate(4, classesLabel = `${cLabel4} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 323584) {
      $:
        $$invalidate(3, classesTrack = `${cTrack} ${borderWidth} ${borderColor} ${rounded} ${trackSize} ${cTrackAccent}`);
    }
    if ($$self.$$.dirty & 212992) {
      $:
        $$invalidate(2, classesThumb = `${cThumb} ${rounded} ${cThumbBackground} ${cThumbPos}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    label,
    classesThumb,
    classesTrack,
    classesLabel,
    classesBase,
    onKeyDown3,
    prunedRestProps,
    $$props,
    $$slots,
    size,
    accent,
    borderWidth,
    borderColor,
    rounded,
    trackSize,
    cThumbPos,
    cThumbBackground,
    cTrackAccent,
    classesDisabled,
    $$scope,
    slots,
    click_handler,
    change_handler,
    mouseover_handler,
    focus_handler,
    blur_handler,
    input_change_handler
  ];
}
var SlideToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      checked: 0,
      size: 10,
      accent: 11,
      borderWidth: 12,
      borderColor: 13,
      rounded: 14,
      label: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlideToggle",
      options,
      id: create_fragment25.name
    });
  }
  get checked() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlideToggle_default = SlideToggle;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Stepper/Stepper.svelte
var file26 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Stepper\\Stepper.svelte";
function create_fragment26(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "stepper " + ctx[0]);
      attr_dev(div, "data-testid", "stepper");
      add_location(div, file26, 39, 0, 1521);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && div_class_value !== (div_class_value = "stepper " + ctx2[0])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let classesStepper;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stepper", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { active = writable(0) } = $$props;
  let { length: length2 = 0 } = $$props;
  let { duration = 200 } = $$props;
  let { color = "text-white" } = $$props;
  let { background = "bg-accent-500" } = $$props;
  let { buttonBack = "btn-ghost-surface" } = $$props;
  let { buttonNext = "btn-filled-surface" } = $$props;
  let { buttonComplete = "btn-filled-primary" } = $$props;
  setContext("dispatch", dispatch);
  setContext("active", active);
  setContext("length", length2);
  setContext("color", color);
  setContext("background", background);
  setContext("buttonBack", buttonBack);
  setContext("buttonNext", buttonNext);
  setContext("buttonComplete", buttonComplete);
  setContext("duration", duration);
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("active" in $$new_props)
      $$invalidate(1, active = $$new_props.active);
    if ("length" in $$new_props)
      $$invalidate(2, length2 = $$new_props.length);
    if ("duration" in $$new_props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("background" in $$new_props)
      $$invalidate(5, background = $$new_props.background);
    if ("buttonBack" in $$new_props)
      $$invalidate(6, buttonBack = $$new_props.buttonBack);
    if ("buttonNext" in $$new_props)
      $$invalidate(7, buttonNext = $$new_props.buttonNext);
    if ("buttonComplete" in $$new_props)
      $$invalidate(8, buttonComplete = $$new_props.buttonComplete);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    writable,
    dispatch,
    active,
    length: length2,
    duration,
    color,
    background,
    buttonBack,
    buttonNext,
    buttonComplete,
    classesStepper
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
    if ("active" in $$props)
      $$invalidate(1, active = $$new_props.active);
    if ("length" in $$props)
      $$invalidate(2, length2 = $$new_props.length);
    if ("duration" in $$props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("background" in $$props)
      $$invalidate(5, background = $$new_props.background);
    if ("buttonBack" in $$props)
      $$invalidate(6, buttonBack = $$new_props.buttonBack);
    if ("buttonNext" in $$props)
      $$invalidate(7, buttonNext = $$new_props.buttonNext);
    if ("buttonComplete" in $$props)
      $$invalidate(8, buttonComplete = $$new_props.buttonComplete);
    if ("classesStepper" in $$props)
      $$invalidate(0, classesStepper = $$new_props.classesStepper);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classesStepper = `${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    classesStepper,
    active,
    length2,
    duration,
    color,
    background,
    buttonBack,
    buttonNext,
    buttonComplete,
    $$scope,
    slots
  ];
}
var Stepper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      active: 1,
      length: 2,
      duration: 3,
      color: 4,
      background: 5,
      buttonBack: 6,
      buttonNext: 7,
      buttonComplete: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stepper",
      options,
      id: create_fragment26.name
    });
  }
  get active() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get length() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set length(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBack() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBack(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNext() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNext(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonComplete() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonComplete(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Stepper_default = Stepper;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Stepper/Step.svelte
var file27 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Stepper\\Step.svelte";
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
function create_else_block_1(ctx) {
  let html_tag;
  let raw_value = (ctx[0] < ctx[9] ? "&check;" : ctx[0] + 1) + "";
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 513 && raw_value !== (raw_value = (ctx2[0] < ctx2[9] ? "&check;" : ctx2[0] + 1) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(67:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("🔒");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "🔒");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(65:3) {#if locked}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "step-line " + ctx[13]);
      add_location(div, file27, 71, 19, 2594);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && div_class_value !== (div_class_value = "step-line " + ctx2[13])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(72:2) {#if !isLastItem}",
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let h4;
  let t0;
  let t1_value = ctx[0] + 1 + "";
  let t1;
  const block = {
    c: function create() {
      h4 = element("h4");
      t0 = text("Step ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      h4 = claim_element(nodes, "H4", {});
      var h4_nodes = children(h4);
      t0 = claim_text(h4_nodes, "Step ");
      t1 = claim_text(h4_nodes, t1_value);
      h4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h4, file27, 76, 50, 2783);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h4, anchor);
      append_hydration_dev(h4, t0);
      append_hydration_dev(h4, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0] + 1 + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(77:50) <h4>",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let div;
  let t0;
  let footer;
  let t1;
  let footer_class_value;
  let div_transition;
  let current;
  const default_slot_template = ctx[26].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[25], null);
  let if_block0 = ctx[0] !== 0 && create_if_block_25(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[9] + 1 < ctx2[3])
      return create_if_block_110;
    return create_else_block4;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t0 = space();
      footer = element("footer");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      footer = claim_element(div_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      if (if_block0)
        if_block0.l(footer_nodes);
      t1 = claim_space(footer_nodes);
      if_block1.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "class", footer_class_value = "step-navigation " + ctx[10]);
      add_location(footer, file27, 82, 4, 2987);
      attr_dev(div, "class", "step-body space-y-4");
      add_location(div, file27, 78, 3, 2854);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t0);
      append_hydration_dev(div, footer);
      if (if_block0)
        if_block0.m(footer, null);
      append_hydration_dev(footer, t1);
      if_block1.m(footer, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[25],
            !current ? get_all_dirty_from_scope(ctx[25]) : get_slot_changes(default_slot_template, ctx[25], dirty, null),
            null
          );
        }
      }
      if (ctx[0] !== 0) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_25(ctx);
          if_block0.c();
          if_block0.m(footer, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block1) {
        if_block1.p(ctx, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx);
        if (if_block1) {
          if_block1.c();
          if_block1.m(footer, null);
        }
      }
      if (!current || dirty & 1024 && footer_class_value !== (footer_class_value = "step-navigation " + ctx[10])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration: ctx[4] }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: ctx[4] }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if_block1.d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(78:2) {#if index === $active}",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let button;
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text("↑");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "↑");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "btn " + ctx[5]);
      add_location(button, file27, 83, 22, 3055);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[15], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32 && button_class_value !== (button_class_value = "btn " + ctx2[5])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(84:5) {#if index !== 0}",
    ctx
  });
  return block;
}
function create_else_block4(ctx) {
  let button;
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text("Complete");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "Complete");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "btn " + ctx[7]);
      button.disabled = ctx[1];
      add_location(button, file27, 87, 6, 3278);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[17], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 128 && button_class_value !== (button_class_value = "btn " + ctx2[7])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & 2) {
        prop_dev(button, "disabled", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(87:5) {:else}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let button;
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text("Next ↓");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "Next ↓");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "btn " + ctx[6]);
      button.disabled = ctx[1];
      add_location(button, file27, 85, 6, 3167);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[16], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 64 && button_class_value !== (button_class_value = "btn " + ctx2[6])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & 2) {
        prop_dev(button, "disabled", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(85:5) {#if $active + 1 < length}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let div3;
  let div1;
  let div0;
  let div0_class_value;
  let t0;
  let t1;
  let div2;
  let header;
  let t2;
  let div2_class_value;
  let div3_class_value;
  let current;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block_43;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  let if_block1 = !ctx[8] && create_if_block_33(ctx);
  const header_slot_template = ctx[26].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[25], get_header_slot_context2);
  const header_slot_or_fallback = header_slot || fallback_block4(ctx);
  let if_block2 = ctx[0] === ctx[9] && create_if_block17(ctx);
  const block = {
    c: function create() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div2 = element("div");
      header = element("header");
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div3_nodes = children(div3);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      header = claim_element(div2_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      if (header_slot_or_fallback)
        header_slot_or_fallback.l(header_nodes);
      header_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block2)
        if_block2.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "step-numeral flex-none " + ctx[12]);
      add_location(div0, file27, 63, 2, 2401);
      attr_dev(div1, "class", "step-timeline flex flex-col items-center");
      add_location(div1, file27, 61, 1, 2325);
      attr_dev(header, "class", "step-header");
      add_location(header, file27, 76, 2, 2735);
      attr_dev(div2, "class", div2_class_value = "step-content " + ctx[11]);
      add_location(div2, file27, 74, 1, 2666);
      attr_dev(div3, "class", div3_class_value = "step " + ctx[14]);
      attr_dev(div3, "data-testid", "step");
      add_location(div3, file27, 59, 0, 2253);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, div0);
      if_block0.m(div0, null);
      append_hydration_dev(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, header);
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(header, null);
      }
      append_hydration_dev(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (!current || dirty & 4096 && div0_class_value !== (div0_class_value = "step-numeral flex-none " + ctx2[12])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!ctx2[8]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_33(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 33554432)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(header_slot_template, ctx2[25], dirty, get_header_slot_changes2),
            get_header_slot_context2
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & 1)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (ctx2[0] === ctx2[9]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 513) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block17(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & 2048 && div2_class_value !== (div2_class_value = "step-content " + ctx2[11])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & 16384 && div3_class_value !== (div3_class_value = "step " + ctx2[14])) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot_or_fallback, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase18 = "grid grid-cols-[32px_1fr] gap-4";
var cLine = "w-1 h-full";
var cLineBackground = "bg-surface-300-600-token";
var cNumeral = "font-bold text-base w-8 h-8 rounded-full flex justify-center items-center";
var cNumralBackground = "bg-surface-300-600-token";
var cDrawer = "ml-1 space-y-4";
var cNav = "flex items-center space-x-2";
function instance27($$self, $$props, $$invalidate) {
  let isLastItem;
  let classesBase;
  let classesLineBackgroundColor;
  let classesLineBackground;
  let classesLine;
  let classesNumeralBackground;
  let classesNumeral;
  let classesDrawerPadding;
  let classesDrawer;
  let classesNav;
  let $active, $$unsubscribe_active = noop, $$subscribe_active = () => ($$unsubscribe_active(), $$unsubscribe_active = subscribe(active, ($$value) => $$invalidate(9, $active = $$value)), active);
  $$self.$$.on_destroy.push(() => $$unsubscribe_active());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Step", slots, ["header", "default"]);
  let { index = 0 } = $$props;
  let { locked = false } = $$props;
  let { dispatch = getContext("dispatch") } = $$props;
  let { active = getContext("active") } = $$props;
  validate_store(active, "active");
  $$subscribe_active();
  let { length: length2 = getContext("length") } = $$props;
  let { duration = getContext("duration") } = $$props;
  let { color = getContext("color") } = $$props;
  let { background = getContext("background") } = $$props;
  let { buttonBack = getContext("buttonBack") } = $$props;
  let { buttonNext = getContext("buttonNext") } = $$props;
  let { buttonComplete = getContext("buttonComplete") } = $$props;
  function stepPrev() {
    active.set($active - 1);
  }
  function stepNext() {
    active.set($active + 1);
  }
  function onComplete() {
    dispatch("complete", {});
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("index" in $$new_props)
      $$invalidate(0, index = $$new_props.index);
    if ("locked" in $$new_props)
      $$invalidate(1, locked = $$new_props.locked);
    if ("dispatch" in $$new_props)
      $$invalidate(18, dispatch = $$new_props.dispatch);
    if ("active" in $$new_props)
      $$subscribe_active($$invalidate(2, active = $$new_props.active));
    if ("length" in $$new_props)
      $$invalidate(3, length2 = $$new_props.length);
    if ("duration" in $$new_props)
      $$invalidate(4, duration = $$new_props.duration);
    if ("color" in $$new_props)
      $$invalidate(19, color = $$new_props.color);
    if ("background" in $$new_props)
      $$invalidate(20, background = $$new_props.background);
    if ("buttonBack" in $$new_props)
      $$invalidate(5, buttonBack = $$new_props.buttonBack);
    if ("buttonNext" in $$new_props)
      $$invalidate(6, buttonNext = $$new_props.buttonNext);
    if ("buttonComplete" in $$new_props)
      $$invalidate(7, buttonComplete = $$new_props.buttonComplete);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    slide,
    index,
    locked,
    cBase: cBase18,
    cLine,
    cLineBackground,
    cNumeral,
    cNumralBackground,
    cDrawer,
    cNav,
    dispatch,
    active,
    length: length2,
    duration,
    color,
    background,
    buttonBack,
    buttonNext,
    buttonComplete,
    stepPrev,
    stepNext,
    onComplete,
    classesNav,
    classesDrawerPadding,
    classesDrawer,
    isLastItem,
    classesNumeralBackground,
    classesNumeral,
    classesLineBackground,
    classesLine,
    classesLineBackgroundColor,
    classesBase,
    $active
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
    if ("index" in $$props)
      $$invalidate(0, index = $$new_props.index);
    if ("locked" in $$props)
      $$invalidate(1, locked = $$new_props.locked);
    if ("dispatch" in $$props)
      $$invalidate(18, dispatch = $$new_props.dispatch);
    if ("active" in $$props)
      $$subscribe_active($$invalidate(2, active = $$new_props.active));
    if ("length" in $$props)
      $$invalidate(3, length2 = $$new_props.length);
    if ("duration" in $$props)
      $$invalidate(4, duration = $$new_props.duration);
    if ("color" in $$props)
      $$invalidate(19, color = $$new_props.color);
    if ("background" in $$props)
      $$invalidate(20, background = $$new_props.background);
    if ("buttonBack" in $$props)
      $$invalidate(5, buttonBack = $$new_props.buttonBack);
    if ("buttonNext" in $$props)
      $$invalidate(6, buttonNext = $$new_props.buttonNext);
    if ("buttonComplete" in $$props)
      $$invalidate(7, buttonComplete = $$new_props.buttonComplete);
    if ("classesNav" in $$props)
      $$invalidate(10, classesNav = $$new_props.classesNav);
    if ("classesDrawerPadding" in $$props)
      $$invalidate(21, classesDrawerPadding = $$new_props.classesDrawerPadding);
    if ("classesDrawer" in $$props)
      $$invalidate(11, classesDrawer = $$new_props.classesDrawer);
    if ("isLastItem" in $$props)
      $$invalidate(8, isLastItem = $$new_props.isLastItem);
    if ("classesNumeralBackground" in $$props)
      $$invalidate(22, classesNumeralBackground = $$new_props.classesNumeralBackground);
    if ("classesNumeral" in $$props)
      $$invalidate(12, classesNumeral = $$new_props.classesNumeral);
    if ("classesLineBackground" in $$props)
      $$invalidate(23, classesLineBackground = $$new_props.classesLineBackground);
    if ("classesLine" in $$props)
      $$invalidate(13, classesLine = $$new_props.classesLine);
    if ("classesLineBackgroundColor" in $$props)
      $$invalidate(24, classesLineBackgroundColor = $$new_props.classesLineBackgroundColor);
    if ("classesBase" in $$props)
      $$invalidate(14, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 9) {
      $:
        $$invalidate(8, isLastItem = index === length2 - 1);
    }
    $:
      $$invalidate(14, classesBase = `${cBase18} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 1049089) {
      $:
        $$invalidate(24, classesLineBackgroundColor = index < $active ? `${background}` : `${cLineBackground}`);
    }
    if ($$self.$$.dirty & 16777472) {
      $:
        $$invalidate(23, classesLineBackground = !isLastItem ? `${classesLineBackgroundColor}` : "");
    }
    if ($$self.$$.dirty & 8388608) {
      $:
        $$invalidate(13, classesLine = `${cLine} ${classesLineBackground}`);
    }
    if ($$self.$$.dirty & 1573377) {
      $:
        $$invalidate(22, classesNumeralBackground = index <= $active ? `${color} ${background}` : `${cNumralBackground}`);
    }
    if ($$self.$$.dirty & 4194304) {
      $:
        $$invalidate(12, classesNumeral = `${cNumeral} ${classesNumeralBackground}`);
    }
    if ($$self.$$.dirty & 256) {
      $:
        $$invalidate(21, classesDrawerPadding = !isLastItem ? "pb-10" : "0");
    }
    if ($$self.$$.dirty & 2097152) {
      $:
        $$invalidate(11, classesDrawer = `${cDrawer} ${classesDrawerPadding}`);
    }
  };
  $:
    $$invalidate(10, classesNav = `${cNav}`);
  $$props = exclude_internal_props($$props);
  return [
    index,
    locked,
    active,
    length2,
    duration,
    buttonBack,
    buttonNext,
    buttonComplete,
    isLastItem,
    $active,
    classesNav,
    classesDrawer,
    classesNumeral,
    classesLine,
    classesBase,
    stepPrev,
    stepNext,
    onComplete,
    dispatch,
    color,
    background,
    classesDrawerPadding,
    classesNumeralBackground,
    classesLineBackground,
    classesLineBackgroundColor,
    $$scope,
    slots
  ];
}
var Step = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      index: 0,
      locked: 1,
      dispatch: 18,
      active: 2,
      length: 3,
      duration: 4,
      color: 19,
      background: 20,
      buttonBack: 5,
      buttonNext: 6,
      buttonComplete: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Step",
      options,
      id: create_fragment27.name
    });
  }
  get index() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set index(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locked() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locked(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispatch() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispatch(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get length() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set length(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBack() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBack(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNext() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNext(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonComplete() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonComplete(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Step_default = Step;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Table/Table.svelte
var file28 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Table\\Table.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[21] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[23] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i];
  return child_ctx;
}
function create_each_block_3(ctx) {
  let th;
  let raw_value = ctx[24] + "";
  const block = {
    c: function create() {
      th = element("th");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {});
      var th_nodes = children(th);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(th, file28, 59, 5, 1939);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      th.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && raw_value !== (raw_value = ctx2[24] + ""))
        th.innerHTML = raw_value;
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(59:4) {#each source.head as heading }",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let td;
  let raw_value = (ctx[16] ? ctx[16] : "-") + "";
  let td_aria_colindex_value;
  let td_tabindex_value;
  const block = {
    c: function create() {
      td = element("td");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {
        role: true,
        "aria-colindex": true,
        tabindex: true
      });
      var td_nodes = children(td);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "role", "gridcell");
      attr_dev(td, "aria-colindex", td_aria_colindex_value = ctx[23] + 1);
      attr_dev(td, "tabindex", td_tabindex_value = ctx[23] === 0 ? 0 : -1);
      add_location(td, file28, 76, 6, 2389);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      td.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && raw_value !== (raw_value = (ctx2[16] ? ctx2[16] : "-") + ""))
        td.innerHTML = raw_value;
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(74:5) {#each row as cell, cellIndex}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let tr;
  let t;
  let tr_aria_rowindex_value;
  let mounted;
  let dispose;
  let each_value_2 = ctx[19];
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  function click_handler(...args) {
    return ctx[12](ctx[21], ...args);
  }
  function keydown_handler(...args) {
    return ctx[13](ctx[21], ...args);
  }
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { "aria-rowindex": true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "aria-rowindex", tr_aria_rowindex_value = ctx[21] + 1);
      add_location(tr, file28, 68, 4, 2144);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
      append_hydration_dev(tr, t);
      if (!mounted) {
        dispose = [
          listen_dev(tr, "click", click_handler, false, false, false),
          listen_dev(tr, "keydown", keydown_handler, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1) {
        each_value_2 = ctx[19];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(66:3) {#each source.body as row, rowIndex}",
    ctx
  });
  return block;
}
function create_if_block18(ctx) {
  let tfoot;
  let tr;
  let tfoot_class_value;
  let each_value = ctx[0].foot;
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      tfoot = element("tfoot");
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      tfoot = claim_element(nodes, "TFOOT", { class: true });
      var tfoot_nodes = children(tfoot);
      tr = claim_element(tfoot_nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      tfoot_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file28, 90, 4, 2677);
      attr_dev(tfoot, "class", tfoot_class_value = "table-foot " + ctx[4]);
      add_location(tfoot, file28, 89, 3, 2633);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tfoot, anchor);
      append_hydration_dev(tfoot, tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1) {
        each_value = ctx2[0].foot;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 16 && tfoot_class_value !== (tfoot_class_value = "table-foot " + ctx2[4])) {
        attr_dev(tfoot, "class", tfoot_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tfoot);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(89:2) {#if source.foot}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let td;
  let raw_value = ctx[16] + "";
  const block = {
    c: function create() {
      td = element("td");
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {});
      var td_nodes = children(td);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(td, file28, 92, 6, 2722);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      td.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && raw_value !== (raw_value = ctx2[16] + ""))
        td.innerHTML = raw_value;
      ;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(92:5) {#each source.foot as cell }",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let div;
  let table;
  let thead;
  let tr;
  let thead_class_value;
  let t0;
  let tbody;
  let tbody_class_value;
  let t1;
  let tableA11y_action;
  let div_class_value;
  let mounted;
  let dispose;
  let each_value_3 = ctx[0].head;
  validate_each_argument(each_value_3);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_1 = ctx[0].body;
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let if_block = ctx[0].foot && create_if_block18(ctx);
  const block = {
    c: function create() {
      div = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      table = claim_element(div_nodes, "TABLE", { class: true, role: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t0 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      t1 = claim_space(table_nodes);
      if (if_block)
        if_block.l(table_nodes);
      table_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file28, 57, 3, 1893);
      attr_dev(thead, "class", thead_class_value = "table-head " + ctx[2]);
      add_location(thead, file28, 56, 2, 1850);
      attr_dev(tbody, "class", tbody_class_value = "table-body " + ctx[3]);
      add_location(tbody, file28, 64, 2, 2014);
      attr_dev(table, "class", ctx[5]);
      attr_dev(table, "role", "grid");
      toggle_class(table, "table-interactive", ctx[1]);
      add_location(table, file28, 48, 1, 1667);
      attr_dev(div, "class", div_class_value = "table-container " + ctx[6]);
      add_location(div, file28, 45, 0, 1580);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, table);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(tr, null);
      }
      append_hydration_dev(table, t0);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tbody, null);
      }
      append_hydration_dev(table, t1);
      if (if_block)
        if_block.m(table, null);
      if (!mounted) {
        dispose = action_destroyer(tableA11y_action = tableA11y.call(null, table));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value_3 = ctx2[0].head;
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_3(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_3.length;
      }
      if (dirty & 4 && thead_class_value !== (thead_class_value = "table-head " + ctx2[2])) {
        attr_dev(thead, "class", thead_class_value);
      }
      if (dirty & 385) {
        each_value_1 = ctx2[0].body;
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & 8 && tbody_class_value !== (tbody_class_value = "table-body " + ctx2[3])) {
        attr_dev(tbody, "class", tbody_class_value);
      }
      if (ctx2[0].foot) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          if_block.m(table, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32) {
        attr_dev(table, "class", ctx2[5]);
      }
      if (dirty & 34) {
        toggle_class(table, "table-interactive", ctx2[1]);
      }
      if (dirty & 64 && div_class_value !== (div_class_value = "table-container " + ctx2[6])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let classesBase;
  let classesTable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, []);
  const dispatch = createEventDispatcher();
  let { source } = $$props;
  let { interactive = false } = $$props;
  let { element: element2 = "table" } = $$props;
  let { text: text2 = "" } = $$props;
  let { color = "" } = $$props;
  let { regionHead = "" } = $$props;
  let { regionBody = "" } = $$props;
  let { regionFoot = "" } = $$props;
  function onRowClick(event, rowIndex) {
    if (!interactive)
      return;
    event.preventDefault();
    event.stopPropagation();
    const rowInfo = source.meta ? source.meta[rowIndex] : source.body[rowIndex];
    dispatch("selected", rowInfo);
  }
  function onRowKeydown(event, rowIndex) {
    if (["Enter", "Space"].includes(event.code))
      onRowClick(event, rowIndex);
  }
  $$self.$$.on_mount.push(function() {
    if (source === void 0 && !("source" in $$props || $$self.$$.bound[$$self.$$.props["source"]])) {
      console.warn("<Table> was created without expected prop 'source'");
    }
  });
  const click_handler = (rowIndex, e) => {
    onRowClick(e, rowIndex);
  };
  const keydown_handler = (rowIndex, e) => {
    onRowKeydown(e, rowIndex);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("source" in $$new_props)
      $$invalidate(0, source = $$new_props.source);
    if ("interactive" in $$new_props)
      $$invalidate(1, interactive = $$new_props.interactive);
    if ("element" in $$new_props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("text" in $$new_props)
      $$invalidate(10, text2 = $$new_props.text);
    if ("color" in $$new_props)
      $$invalidate(11, color = $$new_props.color);
    if ("regionHead" in $$new_props)
      $$invalidate(2, regionHead = $$new_props.regionHead);
    if ("regionBody" in $$new_props)
      $$invalidate(3, regionBody = $$new_props.regionBody);
    if ("regionFoot" in $$new_props)
      $$invalidate(4, regionFoot = $$new_props.regionFoot);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    tableA11y,
    dispatch,
    source,
    interactive,
    element: element2,
    text: text2,
    color,
    regionHead,
    regionBody,
    regionFoot,
    onRowClick,
    onRowKeydown,
    classesTable,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("source" in $$props)
      $$invalidate(0, source = $$new_props.source);
    if ("interactive" in $$props)
      $$invalidate(1, interactive = $$new_props.interactive);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("text" in $$props)
      $$invalidate(10, text2 = $$new_props.text);
    if ("color" in $$props)
      $$invalidate(11, color = $$new_props.color);
    if ("regionHead" in $$props)
      $$invalidate(2, regionHead = $$new_props.regionHead);
    if ("regionBody" in $$props)
      $$invalidate(3, regionBody = $$new_props.regionBody);
    if ("regionFoot" in $$props)
      $$invalidate(4, regionFoot = $$new_props.regionFoot);
    if ("classesTable" in $$props)
      $$invalidate(5, classesTable = $$new_props.classesTable);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(6, classesBase = `${$$props.class || ""}`);
    if ($$self.$$.dirty & 3584) {
      $:
        $$invalidate(5, classesTable = `${element2} ${text2} ${color}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    source,
    interactive,
    regionHead,
    regionBody,
    regionFoot,
    classesTable,
    classesBase,
    onRowClick,
    onRowKeydown,
    element2,
    text2,
    color,
    click_handler,
    keydown_handler
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      source: 0,
      interactive: 1,
      element: 9,
      text: 10,
      color: 11,
      regionHead: 2,
      regionBody: 3,
      regionFoot: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment28.name
    });
  }
  get source() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHead() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHead(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBody() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBody(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFoot() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFoot(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Tab/TabGroup.svelte
var file29 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Tab\\TabGroup.svelte";
function create_fragment29(ctx) {
  let nav;
  let ul;
  let ul_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true, "data-testid": true });
      var nav_nodes = children(nav);
      ul = claim_element(nav_nodes, "UL", {
        class: true,
        role: true,
        "aria-labelledby": true,
        "aria-label": true
      });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "tab-group-list " + ctx[3]);
      attr_dev(ul, "role", "tablist");
      attr_dev(ul, "aria-labelledby", ctx[0]);
      attr_dev(ul, "aria-label", ctx[1]);
      add_location(ul, file29, 58, 1, 2148);
      attr_dev(nav, "class", "tab-group");
      attr_dev(nav, "data-testid", "tab-group");
      add_location(nav, file29, 57, 0, 2099);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[17](ul);
      current = true;
      if (!mounted) {
        dispose = listen_dev(ul, "keydown", ctx[4], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(default_slot_template, ctx2[15], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 8 && ul_class_value !== (ul_class_value = "tab-group-list " + ctx2[3])) {
        attr_dev(ul, "class", ul_class_value);
      }
      if (!current || dirty & 1) {
        attr_dev(ul, "aria-labelledby", ctx2[0]);
      }
      if (!current || dirty & 2) {
        attr_dev(ul, "aria-label", ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if (default_slot)
        default_slot.d(detaching);
      ctx[17](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase19 = "border-surface-300-600-token flex hide-scrollbar overflow-x-auto";
function instance29($$self, $$props, $$invalidate) {
  let classesRail;
  let classesGroup;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabGroup", slots, ["default"]);
  let { selected } = $$props;
  let { rail = true } = $$props;
  let { justify = "justify-start" } = $$props;
  let { borderWidth = "border-b-2" } = $$props;
  let { borderColor = "border-primary-500" } = $$props;
  let { color = "text-primary-500" } = $$props;
  let { fill = "fill-primary-500" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { rounded = "rounded-tl-container-token rounded-tr-container-token" } = $$props;
  let { labeledby = "" } = $$props;
  let { label = "" } = $$props;
  setContext("selected", selected);
  setContext("borderWidth", borderWidth);
  setContext("borderColor", borderColor);
  setContext("color", color);
  setContext("fill", fill);
  setContext("hover", hover);
  setContext("rounded", rounded);
  let elemTabGroup;
  function keydown(event) {
    if (["Home", "End"].includes(event.code)) {
      event.preventDefault();
      if (event.code === "Home") {
        elemTabGroup.children[0].focus();
      }
      if (event.code === "End") {
        elemTabGroup.children[elemTabGroup.children.length - 1].focus();
      }
    }
  }
  $$self.$$.on_mount.push(function() {
    if (selected === void 0 && !("selected" in $$props || $$self.$$.bound[$$self.$$.props["selected"]])) {
      console.warn("<TabGroup> was created without expected prop 'selected'");
    }
  });
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemTabGroup = $$value;
      $$invalidate(2, elemTabGroup);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$invalidate(5, selected = $$new_props.selected);
    if ("rail" in $$new_props)
      $$invalidate(6, rail = $$new_props.rail);
    if ("justify" in $$new_props)
      $$invalidate(7, justify = $$new_props.justify);
    if ("borderWidth" in $$new_props)
      $$invalidate(8, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$new_props)
      $$invalidate(9, borderColor = $$new_props.borderColor);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("hover" in $$new_props)
      $$invalidate(12, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("labeledby" in $$new_props)
      $$invalidate(0, labeledby = $$new_props.labeledby);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    selected,
    rail,
    justify,
    borderWidth,
    borderColor,
    color,
    fill,
    hover,
    rounded,
    labeledby,
    label,
    cBase: cBase19,
    elemTabGroup,
    keydown,
    classesRail,
    classesGroup
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(5, selected = $$new_props.selected);
    if ("rail" in $$props)
      $$invalidate(6, rail = $$new_props.rail);
    if ("justify" in $$props)
      $$invalidate(7, justify = $$new_props.justify);
    if ("borderWidth" in $$props)
      $$invalidate(8, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$props)
      $$invalidate(9, borderColor = $$new_props.borderColor);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(11, fill = $$new_props.fill);
    if ("hover" in $$props)
      $$invalidate(12, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(13, rounded = $$new_props.rounded);
    if ("labeledby" in $$props)
      $$invalidate(0, labeledby = $$new_props.labeledby);
    if ("label" in $$props)
      $$invalidate(1, label = $$new_props.label);
    if ("elemTabGroup" in $$props)
      $$invalidate(2, elemTabGroup = $$new_props.elemTabGroup);
    if ("classesRail" in $$props)
      $$invalidate(14, classesRail = $$new_props.classesRail);
    if ("classesGroup" in $$props)
      $$invalidate(3, classesGroup = $$new_props.classesGroup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 320) {
      $:
        $$invalidate(14, classesRail = rail ? borderWidth : "border-0");
    }
    $:
      $$invalidate(3, classesGroup = `${cBase19} ${classesRail} ${justify} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    labeledby,
    label,
    elemTabGroup,
    classesGroup,
    keydown,
    selected,
    rail,
    justify,
    borderWidth,
    borderColor,
    color,
    fill,
    hover,
    rounded,
    classesRail,
    $$scope,
    slots,
    ul_binding
  ];
}
var TabGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      selected: 5,
      rail: 6,
      justify: 7,
      borderWidth: 8,
      borderColor: 9,
      color: 10,
      fill: 11,
      hover: 12,
      rounded: 13,
      labeledby: 0,
      label: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabGroup",
      options,
      id: create_fragment29.name
    });
  }
  get selected() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rail() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rail(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labeledby() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labeledby(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabGroup_default = TabGroup;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/components/Tab/Tab.svelte
var file30 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\components\\Tab\\Tab.svelte";
var get_lead_slot_changes7 = (dirty) => ({});
var get_lead_slot_context7 = (ctx) => ({});
function create_if_block_111(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = ctx[17].lead;
  const lead_slot = create_slot(lead_slot_template, ctx, ctx[16], get_lead_slot_context7);
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tab-lead " + ctx[4]);
      add_location(div, file30, 53, 19, 1599);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(lead_slot_template, ctx2[16], dirty, get_lead_slot_changes7),
            get_lead_slot_context7
          );
        }
      }
      if (!current || dirty & 16 && div_class_value !== (div_class_value = "tab-lead " + ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(54:1) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block19(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = ctx[17].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[16], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, label: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tab-label " + ctx[3]);
      attr_dev(div, "label", ctx[2]);
      add_location(div, file30, 55, 22, 1713);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(default_slot_template, ctx2[16], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 8 && div_class_value !== (div_class_value = "tab-label " + ctx2[3])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 4) {
        attr_dev(div, "label", ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(56:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let li;
  let t;
  let li_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[6].lead && create_if_block_111(ctx);
  let if_block1 = ctx[6].default && create_if_block19(ctx);
  const block = {
    c: function create() {
      li = element("li");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        "data-testid": true,
        role: true,
        tabindex: true
      });
      var li_nodes = children(li);
      if (if_block0)
        if_block0.l(li_nodes);
      t = claim_space(li_nodes);
      if (if_block1)
        if_block1.l(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", li_class_value = "tab $" + ctx[5]);
      attr_dev(li, "data-testid", "tab");
      attr_dev(li, "role", "tab");
      attr_dev(li, "tabindex", "0");
      add_location(li, file30, 42, 0, 1410);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (if_block0)
        if_block0.m(li, null);
      append_hydration_dev(li, t);
      if (if_block1)
        if_block1.m(li, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", ctx[18], false, false, false),
          listen_dev(li, "keydown", onKeyDown, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[6].lead) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_111(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(li, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[6].default) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block19(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(li, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 32 && li_class_value !== (li_class_value = "tab $" + ctx2[5])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase20 = "font-bold list-none py-2.5 px-4 flex items-center space-x-2 cursor-pointer";
var cBorderColor = "border-transparent";
var cBaseLabel3 = "font-bold whitespace-nowrap";
function onKeyDown(event) {
  if (["Enter", "Space"].includes(event.code)) {
    event.preventDefault();
    event.target.click();
  }
}
function instance30($$self, $$props, $$invalidate) {
  let isSelected;
  let classesSelected;
  let classesBase;
  let classesLead;
  let classesLabel;
  let $selected, $$unsubscribe_selected = noop, $$subscribe_selected = () => ($$unsubscribe_selected(), $$unsubscribe_selected = subscribe(selected, ($$value) => $$invalidate(15, $selected = $$value)), selected);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selected());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { selected = getContext("selected") } = $$props;
  validate_store(selected, "selected");
  $$subscribe_selected();
  let { borderWidth = getContext("borderWidth") } = $$props;
  let { borderColor = getContext("borderColor") } = $$props;
  let { color = getContext("color") } = $$props;
  let { fill = getContext("fill") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { value = $selected.value } = $$props;
  let { label = "tab" } = $$props;
  const click_handler = () => {
    selected.set(value);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selected" in $$new_props)
      $$subscribe_selected($$invalidate(0, selected = $$new_props.selected));
    if ("borderWidth" in $$new_props)
      $$invalidate(7, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$new_props)
      $$invalidate(8, borderColor = $$new_props.borderColor);
    if ("color" in $$new_props)
      $$invalidate(9, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(10, fill = $$new_props.fill);
    if ("hover" in $$new_props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    selected,
    borderWidth,
    borderColor,
    color,
    fill,
    hover,
    rounded,
    value,
    label,
    cBase: cBase20,
    cBorderColor,
    cBaseLabel: cBaseLabel3,
    onKeyDown,
    classesLabel,
    isSelected,
    classesLead,
    classesSelected,
    classesBase,
    $selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$subscribe_selected($$invalidate(0, selected = $$new_props.selected));
    if ("borderWidth" in $$props)
      $$invalidate(7, borderWidth = $$new_props.borderWidth);
    if ("borderColor" in $$props)
      $$invalidate(8, borderColor = $$new_props.borderColor);
    if ("color" in $$props)
      $$invalidate(9, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(10, fill = $$new_props.fill);
    if ("hover" in $$props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$props)
      $$invalidate(2, label = $$new_props.label);
    if ("classesLabel" in $$props)
      $$invalidate(3, classesLabel = $$new_props.classesLabel);
    if ("isSelected" in $$props)
      $$invalidate(13, isSelected = $$new_props.isSelected);
    if ("classesLead" in $$props)
      $$invalidate(4, classesLead = $$new_props.classesLead);
    if ("classesSelected" in $$props)
      $$invalidate(14, classesSelected = $$new_props.classesSelected);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32770) {
      $:
        $$invalidate(13, isSelected = value == $selected);
    }
    if ($$self.$$.dirty & 10112) {
      $:
        $$invalidate(14, classesSelected = isSelected ? `${borderWidth} ${borderColor} ${color} ${fill}` : `${borderWidth} ${cBorderColor}`);
    }
    $:
      $$invalidate(5, classesBase = `${cBase20} ${classesSelected} ${hover} ${rounded} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 9216) {
      $:
        $$invalidate(4, classesLead = isSelected ? `${fill}` : "fill-token");
    }
  };
  $:
    $$invalidate(3, classesLabel = `${cBaseLabel3}`);
  $$props = exclude_internal_props($$props);
  return [
    selected,
    value,
    label,
    classesLabel,
    classesLead,
    classesBase,
    $$slots,
    borderWidth,
    borderColor,
    color,
    fill,
    hover,
    rounded,
    isSelected,
    classesSelected,
    $selected,
    $$scope,
    slots,
    click_handler
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      selected: 0,
      borderWidth: 7,
      borderColor: 8,
      color: 9,
      fill: 10,
      hover: 11,
      rounded: 12,
      value: 1,
      label: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment30.name
    });
  }
  get selected() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/CodeBlock/CodeBlock.svelte
var file31 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\utilities\\CodeBlock\\CodeBlock.svelte";
function create_if_block20(ctx) {
  let div;
  let header;
  let span;
  let t0_value = languageFormatter(ctx[0]) + "";
  let t0;
  let t1;
  let button;
  let t2_value = !ctx[6] ? "Copy" : "Copied ✓";
  let t2;
  let button_class_value;
  let clipboard_action;
  let header_class_value;
  let t3;
  let pre;
  let code_1;
  let code_1_class_value;
  let pre_class_value;
  let div_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block_112;
    return create_else_block5;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      header = element("header");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      button = element("button");
      t2 = text(t2_value);
      t3 = space();
      pre = element("pre");
      code_1 = element("code");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      header = claim_element(div_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      span = claim_element(header_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(header_nodes);
      button = claim_element(header_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t2 = claim_text(button_nodes, t2_value);
      button_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      t3 = claim_space(div_nodes);
      pre = claim_element(div_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      code_1 = claim_element(pre_nodes, "CODE", { class: true });
      var code_1_nodes = children(code_1);
      if_block.l(code_1_nodes);
      code_1_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "code-block-language text-white/60");
      add_location(span, file31, 53, 2, 1897);
      attr_dev(button, "class", button_class_value = "code-block-btn btn btn-sm " + ctx[3]);
      add_location(button, file31, 55, 2, 2007);
      attr_dev(header, "class", header_class_value = "code-block-header " + cHeader + " " + ctx[2] + " sticky top-0");
      add_location(header, file31, 51, 1, 1804);
      attr_dev(code_1, "class", code_1_class_value = "code-block-code language-" + ctx[0]);
      add_location(code_1, file31, 60, 36, 2223);
      attr_dev(pre, "class", pre_class_value = "code-block-pre " + cPre);
      add_location(pre, file31, 60, 1, 2188);
      attr_dev(div, "class", div_class_value = "code-block " + ctx[7]);
      attr_dev(div, "data-testid", "code-block");
      add_location(div, file31, 49, 0, 1722);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, header);
      append_hydration_dev(header, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(header, t1);
      append_hydration_dev(header, button);
      append_hydration_dev(button, t2);
      append_hydration_dev(div, t3);
      append_hydration_dev(div, pre);
      append_hydration_dev(pre, code_1);
      if_block.m(code_1, null);
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[8], false, false, false),
          action_destroyer(clipboard_action = clipboard.call(null, button, ctx[1]))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = languageFormatter(ctx2[0]) + ""))
        set_data_dev(t0, t0_value);
      if (dirty & 64 && t2_value !== (t2_value = !ctx2[6] ? "Copy" : "Copied ✓"))
        set_data_dev(t2, t2_value);
      if (dirty & 8 && button_class_value !== (button_class_value = "code-block-btn btn btn-sm " + ctx2[3])) {
        attr_dev(button, "class", button_class_value);
      }
      if (clipboard_action && is_function(clipboard_action.update) && dirty & 2)
        clipboard_action.update.call(null, ctx2[1]);
      if (dirty & 4 && header_class_value !== (header_class_value = "code-block-header " + cHeader + " " + ctx2[2] + " sticky top-0")) {
        attr_dev(header, "class", header_class_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(code_1, null);
        }
      }
      if (dirty & 1 && code_1_class_value !== (code_1_class_value = "code-block-code language-" + ctx2[0])) {
        attr_dev(code_1, "class", code_1_class_value);
      }
      if (dirty & 128 && div_class_value !== (div_class_value = "code-block " + ctx2[7])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(49:0) {#if language && code}",
    ctx
  });
  return block;
}
function create_else_block5(ctx) {
  let t_value = ctx[1].trim() + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].trim() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(61:120) {:else}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(ctx[5], target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        html_tag.p(ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(61:86) {#if formatted}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let if_block_anchor;
  let if_block = ctx[0] && ctx[1] && create_if_block20(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0] && ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase21 = "overflow-hidden shadow";
var cHeader = "text-xs uppercase flex justify-between items-center p-2 pl-4";
var cPre = "whitespace-pre-wrap break-all p-4 pt-1";
function languageFormatter(lang) {
  if (lang === "js")
    return "javascript";
  return lang;
}
function instance31($$self, $$props, $$invalidate) {
  let classesBase;
  let $storeHighlightJs;
  validate_store(storeHighlightJs, "storeHighlightJs");
  component_subscribe($$self, storeHighlightJs, ($$value) => $$invalidate(12, $storeHighlightJs = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeBlock", slots, []);
  let { language = "plaintext" } = $$props;
  let { code = "" } = $$props;
  let { background = "bg-[#141517]" } = $$props;
  let { text: text2 = "text-sm" } = $$props;
  let { color = "text-white" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { buttonCopy = "bg-white/5 hover:bg-white/10" } = $$props;
  let formatted = false;
  let displayCode = code;
  let copyState = false;
  function onCopyClick() {
    $$invalidate(6, copyState = true);
    setTimeout(
      () => {
        $$invalidate(6, copyState = false);
      },
      2e3
    );
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("language" in $$new_props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$new_props)
      $$invalidate(1, code = $$new_props.code);
    if ("background" in $$new_props)
      $$invalidate(2, background = $$new_props.background);
    if ("text" in $$new_props)
      $$invalidate(9, text2 = $$new_props.text);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("rounded" in $$new_props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("buttonCopy" in $$new_props)
      $$invalidate(3, buttonCopy = $$new_props.buttonCopy);
  };
  $$self.$capture_state = () => ({
    storeHighlightJs,
    clipboard,
    language,
    code,
    background,
    text: text2,
    color,
    rounded,
    buttonCopy,
    cBase: cBase21,
    cHeader,
    cPre,
    formatted,
    displayCode,
    copyState,
    languageFormatter,
    onCopyClick,
    classesBase,
    $storeHighlightJs
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    if ("language" in $$props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$props)
      $$invalidate(1, code = $$new_props.code);
    if ("background" in $$props)
      $$invalidate(2, background = $$new_props.background);
    if ("text" in $$props)
      $$invalidate(9, text2 = $$new_props.text);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("rounded" in $$props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("buttonCopy" in $$props)
      $$invalidate(3, buttonCopy = $$new_props.buttonCopy);
    if ("formatted" in $$props)
      $$invalidate(4, formatted = $$new_props.formatted);
    if ("displayCode" in $$props)
      $$invalidate(5, displayCode = $$new_props.displayCode);
    if ("copyState" in $$props)
      $$invalidate(6, copyState = $$new_props.copyState);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4099) {
      $:
        if ($storeHighlightJs !== void 0) {
          $$invalidate(5, displayCode = $storeHighlightJs.highlight(code, { language }).value.trim());
          $$invalidate(4, formatted = true);
        }
    }
    $:
      $$invalidate(7, classesBase = `${cBase21} ${background} ${text2} ${color} ${rounded} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    language,
    code,
    background,
    buttonCopy,
    formatted,
    displayCode,
    copyState,
    classesBase,
    onCopyClick,
    text2,
    color,
    rounded,
    $storeHighlightJs
  ];
}
var CodeBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      language: 0,
      code: 1,
      background: 2,
      text: 9,
      color: 10,
      rounded: 11,
      buttonCopy: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeBlock",
      options,
      id: create_fragment31.name
    });
  }
  get language() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set language(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCopy() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCopy(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeBlock_default = CodeBlock;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/Modal/Modal.svelte
var file32 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\utilities\\Modal\\Modal.svelte";
function create_if_block21(ctx) {
  let previous_key = ctx[13];
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  const block = {
    c: function create() {
      key_block.c();
      key_block_anchor = empty();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, key_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && safe_not_equal(previous_key, previous_key = ctx2[13])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(key_block_anchor);
      key_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(118:0) {#if $modalStore.length > 0}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let header;
  let raw_value = ctx[13][0].title + "";
  let header_class_value;
  const block = {
    c: function create() {
      header = element("header");
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", header_class_value = "modal-header " + ctx[6]);
      add_location(header, file32, 139, 5, 4452);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      header.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && raw_value !== (raw_value = ctx2[13][0].title + ""))
        header.innerHTML = raw_value;
      ;
      if (dirty & 64 && header_class_value !== (header_class_value = "modal-header " + ctx2[6])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(139:4) {#if $modalStore[0]?.title}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let article;
  let raw_value = ctx[13][0].body + "";
  let article_class_value;
  const block = {
    c: function create() {
      article = element("article");
      this.h();
    },
    l: function claim(nodes) {
      article = claim_element(nodes, "ARTICLE", { class: true });
      var article_nodes = children(article);
      article_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(article, "class", article_class_value = "modal-body " + ctx[7]);
      add_location(article, file32, 143, 5, 4598);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, article, anchor);
      article.innerHTML = raw_value;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && raw_value !== (raw_value = ctx2[13][0].body + ""))
        article.innerHTML = raw_value;
      ;
      if (dirty & 128 && article_class_value !== (article_class_value = "modal-body " + ctx2[7])) {
        attr_dev(article, "class", article_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(article);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(143:4) {#if $modalStore[0]?.body}",
    ctx
  });
  return block;
}
function create_if_block_52(ctx) {
  let img;
  let img_class_value;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(img, "class", img_class_value = "modal-image " + cModalImage);
      if (!src_url_equal(img.src, img_src_value = (_a = ctx[13][0]) == null ? void 0 : _a.image))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Modal");
      add_location(img, file32, 147, 5, 4788);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a;
      if (dirty & 8192 && !src_url_equal(img.src, img_src_value = (_a = ctx2[13][0]) == null ? void 0 : _a.image)) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(147:4) {#if $modalStore[0]?.image && typeof $modalStore[0]?.image === 'string'}",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  var _a, _b;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [(_a = ctx[13][0].component) == null ? void 0 : _a.props, { parent: ctx[10] }];
  var switch_value = (_b = ctx[13][0].component) == null ? void 0 : _b.ref;
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      const switch_instance_changes = dirty & 9216 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 8192 && get_spread_object((_a2 = ctx2[13][0].component) == null ? void 0 : _a2.props),
        dirty & 1024 && { parent: ctx2[10] }
      ]) : {};
      if (dirty & 536879104) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = (_b2 = ctx2[13][0].component) == null ? void 0 : _b2.ref)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(172:50) ",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let input;
  let t0;
  let footer;
  let button0;
  let t1;
  let button0_class_value;
  let t2;
  let button1;
  let t3;
  let button1_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      footer = element("footer");
      button0 = element("button");
      t1 = text(ctx[3]);
      t2 = space();
      button1 = element("button");
      t3 = text(ctx[5]);
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { class: true, type: true });
      t0 = claim_space(nodes);
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button0 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t1 = claim_text(button0_nodes, ctx[3]);
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(footer_nodes);
      button1 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t3 = claim_text(button1_nodes, ctx[5]);
      button1_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "modal-prompt-input");
      attr_dev(input, "type", "text");
      input.required = true;
      add_location(input, file32, 165, 5, 5594);
      attr_dev(button0, "class", button0_class_value = "btn " + ctx[1]);
      add_location(button0, file32, 168, 5, 5762);
      attr_dev(button1, "class", button1_class_value = "btn " + ctx[2]);
      add_location(button1, file32, 169, 5, 5850);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + ctx[8]);
      add_location(footer, file32, 167, 5, 5712);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(input, ctx[9]);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button0);
      append_hydration_dev(button0, t1);
      append_hydration_dev(footer, t2);
      append_hydration_dev(footer, button1);
      append_hydration_dev(button1, t3);
      if (!mounted) {
        dispose = [
          listen_dev(input, "input", ctx[27]),
          listen_dev(button0, "click", ctx[15], false, false, false),
          listen_dev(button1, "click", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 512 && input.value !== ctx2[9]) {
        set_input_value(input, ctx2[9]);
      }
      if (dirty & 8)
        set_data_dev(t1, ctx2[3]);
      if (dirty & 2 && button0_class_value !== (button0_class_value = "btn " + ctx2[1])) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty & 32)
        set_data_dev(t3, ctx2[5]);
      if (dirty & 4 && button1_class_value !== (button1_class_value = "btn " + ctx2[2])) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty & 256 && footer_class_value !== (footer_class_value = "modal-footer " + ctx2[8])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(footer);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(164:47) ",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let footer;
  let button0;
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2;
  let button1_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      footer = element("footer");
      button0 = element("button");
      t0 = text(ctx[3]);
      t1 = space();
      button1 = element("button");
      t2 = text(ctx[4]);
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button0 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t0 = claim_text(button0_nodes, ctx[3]);
      button0_nodes.forEach(detach_dev);
      t1 = claim_space(footer_nodes);
      button1 = claim_element(footer_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t2 = claim_text(button1_nodes, ctx[4]);
      button1_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "class", button0_class_value = "btn " + ctx[1]);
      add_location(button0, file32, 160, 5, 5321);
      attr_dev(button1, "class", button1_class_value = "btn " + ctx[2]);
      add_location(button1, file32, 161, 5, 5409);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + ctx[8]);
      add_location(footer, file32, 159, 5, 5271);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button0);
      append_hydration_dev(button0, t0);
      append_hydration_dev(footer, t1);
      append_hydration_dev(footer, button1);
      append_hydration_dev(button1, t2);
      if (!mounted) {
        dispose = [
          listen_dev(button0, "click", ctx[15], false, false, false),
          listen_dev(button1, "click", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t0, ctx2[3]);
      if (dirty & 2 && button0_class_value !== (button0_class_value = "btn " + ctx2[1])) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty & 16)
        set_data_dev(t2, ctx2[4]);
      if (dirty & 4 && button1_class_value !== (button1_class_value = "btn " + ctx2[2])) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty & 256 && footer_class_value !== (footer_class_value = "modal-footer " + ctx2[8])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(157:48) ",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let footer;
  let button;
  let t;
  let button_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      footer = element("footer");
      button = element("button");
      t = text(ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button = claim_element(footer_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, ctx[3]);
      button_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "btn " + ctx[1]);
      add_location(button, file32, 154, 6, 5057);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + ctx[8]);
      add_location(footer, file32, 152, 5, 4975);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[15], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
      if (dirty & 2 && button_class_value !== (button_class_value = "btn " + ctx2[1])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & 256 && footer_class_value !== (footer_class_value = "modal-footer " + ctx2[8])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(footer);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(151:4) {#if $modalStore[0].type === 'alert'}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  var _a;
  let html_tag;
  let raw_value = ((_a = ctx[13][0].component) == null ? void 0 : _a.slot) + "";
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (dirty & 8192 && raw_value !== (raw_value = ((_a2 = ctx2[13][0].component) == null ? void 0 : _a2.slot) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(175:5) <svelte:component this={$modalStore[0].component?.ref} {...$modalStore[0].component?.props} {parent}>",
    ctx
  });
  return block;
}
function create_key_block(ctx) {
  var _a, _b, _c, _d;
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let current_block_type_index;
  let if_block3;
  let div0_class_value;
  let div0_aria_label_value;
  let focusTrap_action;
  let div0_transition;
  let div1_class_value;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ((_a = ctx[13][0]) == null ? void 0 : _a.title) && create_if_block_7(ctx);
  let if_block1 = ((_b = ctx[13][0]) == null ? void 0 : _b.body) && create_if_block_6(ctx);
  let if_block2 = ((_c = ctx[13][0]) == null ? void 0 : _c.image) && typeof ((_d = ctx[13][0]) == null ? void 0 : _d.image) === "string" && create_if_block_52(ctx);
  const if_block_creators = [create_if_block_113, create_if_block_26, create_if_block_34, create_if_block_44];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[13][0].type === "alert")
      return 0;
    if (ctx2[13][0].type === "confirm")
      return 1;
    if (ctx2[13][0].type === "prompt")
      return 2;
    if (ctx2[13][0].type === "component")
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-label": true
      });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "modal " + ctx[11] + " " + ctx[13][0].classes);
      attr_dev(div0, "data-testid", "modal");
      attr_dev(div0, "role", "dialog");
      attr_dev(div0, "aria-modal", "true");
      attr_dev(div0, "aria-label", div0_aria_label_value = ctx[13][0].title);
      add_location(div0, file32, 128, 3, 4146);
      attr_dev(div1, "class", div1_class_value = "modal-backdrop " + ctx[12]);
      attr_dev(div1, "data-testid", "modal-backdrop");
      add_location(div1, file32, 120, 2, 3925);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration_dev(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div0, t2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(focusTrap_action = focusTrap.call(null, div0, true)),
          listen_dev(div1, "mousedown", ctx[14], false, false, false),
          listen_dev(div1, "touchstart", ctx[14], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      var _a2, _b2, _c2, _d2;
      ctx = new_ctx;
      if ((_a2 = ctx[13][0]) == null ? void 0 : _a2.title) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_7(ctx);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((_b2 = ctx[13][0]) == null ? void 0 : _b2.body) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_6(ctx);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (((_c2 = ctx[13][0]) == null ? void 0 : _c2.image) && typeof ((_d2 = ctx[13][0]) == null ? void 0 : _d2.image) === "string") {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_52(ctx);
          if_block2.c();
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block3) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block3 = if_blocks[current_block_type_index];
          if (!if_block3) {
            if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block3.c();
          } else {
            if_block3.p(ctx, dirty);
          }
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        } else {
          if_block3 = null;
        }
      }
      if (!current || dirty & 10240 && div0_class_value !== (div0_class_value = "modal " + ctx[11] + " " + ctx[13][0].classes)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & 8192 && div0_aria_label_value !== (div0_aria_label_value = ctx[13][0].title)) {
        attr_dev(div0, "aria-label", div0_aria_label_value);
      }
      if (!current || dirty & 4096 && div1_class_value !== (div1_class_value = "modal-backdrop " + ctx[12])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block3);
      add_render_callback(() => {
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(
            div0,
            fly,
            {
              duration: ctx[0],
              opacity: 0,
              y: 100
            },
            true
          );
        div0_transition.run(1);
      });
      add_render_callback(() => {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: ctx[0] }, true);
        div1_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block3);
      if (!div0_transition)
        div0_transition = create_bidirectional_transition(
          div0,
          fly,
          {
            duration: ctx[0],
            opacity: 0,
            y: 100
          },
          false
        );
      div0_transition.run(0);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, fade, { duration: ctx[0] }, false);
      div1_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div0_transition)
        div0_transition.end();
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(119:1) {#key $modalStore}",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[13].length > 0 && create_if_block21(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(window, "keydown", ctx[18], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[13].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBackdrop = "fixed top-0 left-0 right-0 bottom-0 z-[999] flex justify-center items-center p-4";
var cModalImage = "w-full h-auto";
function instance32($$self, $$props, $$invalidate) {
  let classesBackdrop;
  let classesModal;
  let parent;
  let $modalStore;
  validate_store(modalStore, "modalStore");
  component_subscribe($$self, modalStore, ($$value) => $$invalidate(13, $modalStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, []);
  let { duration = 150 } = $$props;
  let { background = "bg-surface-100-800-token" } = $$props;
  let { width = "w-full max-w-[640px]" } = $$props;
  let { height = "h-auto" } = $$props;
  let { padding = "p-4" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow-xl" } = $$props;
  let { buttonNeutral = "btn-ghost-surface" } = $$props;
  let { buttonPositive = "btn-filled-primary" } = $$props;
  let { buttonTextCancel = "Cancel" } = $$props;
  let { buttonTextConfirm = "Confirm" } = $$props;
  let { buttonTextSubmit = "Submit" } = $$props;
  let { regionBackdrop = "bg-surface-backdrop-token" } = $$props;
  let { regionHeader = "text-2xl font-bold" } = $$props;
  let { regionBody = "max-h-[200px] overflow-hidden" } = $$props;
  let { regionFooter = "flex justify-end space-x-2" } = $$props;
  let promptValue;
  modalStore.subscribe((dArr) => {
    if (!dArr.length)
      return;
    $$invalidate(9, promptValue = dArr[0].value);
  });
  function onBackdropInteraction(e) {
    if (!(e.target instanceof Element))
      return;
    if (e.target.classList.contains("modal-backdrop"))
      onClose();
  }
  function onClose() {
    if ($modalStore[0].response)
      $modalStore[0].response(false);
    modalStore.close();
  }
  function onConfirm() {
    if ($modalStore[0].response)
      $modalStore[0].response(true);
    modalStore.close();
  }
  function onPromptSubmit() {
    if ($modalStore[0].response)
      $modalStore[0].response(promptValue);
    modalStore.close();
  }
  function onKeyDown3(event) {
    if (!$modalStore.length)
      return;
    if (event.code === "Escape")
      onClose();
  }
  function input_input_handler() {
    promptValue = this.value;
    $$invalidate(9, promptValue);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("duration" in $$new_props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("background" in $$new_props)
      $$invalidate(19, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(20, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(21, height = $$new_props.height);
    if ("padding" in $$new_props)
      $$invalidate(22, padding = $$new_props.padding);
    if ("spacing" in $$new_props)
      $$invalidate(23, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(24, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(25, shadow = $$new_props.shadow);
    if ("buttonNeutral" in $$new_props)
      $$invalidate(1, buttonNeutral = $$new_props.buttonNeutral);
    if ("buttonPositive" in $$new_props)
      $$invalidate(2, buttonPositive = $$new_props.buttonPositive);
    if ("buttonTextCancel" in $$new_props)
      $$invalidate(3, buttonTextCancel = $$new_props.buttonTextCancel);
    if ("buttonTextConfirm" in $$new_props)
      $$invalidate(4, buttonTextConfirm = $$new_props.buttonTextConfirm);
    if ("buttonTextSubmit" in $$new_props)
      $$invalidate(5, buttonTextSubmit = $$new_props.buttonTextSubmit);
    if ("regionBackdrop" in $$new_props)
      $$invalidate(26, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionHeader" in $$new_props)
      $$invalidate(6, regionHeader = $$new_props.regionHeader);
    if ("regionBody" in $$new_props)
      $$invalidate(7, regionBody = $$new_props.regionBody);
    if ("regionFooter" in $$new_props)
      $$invalidate(8, regionFooter = $$new_props.regionFooter);
  };
  $$self.$capture_state = () => ({
    fade,
    fly,
    focusTrap,
    modalStore,
    duration,
    background,
    width,
    height,
    padding,
    spacing,
    rounded,
    shadow,
    buttonNeutral,
    buttonPositive,
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit,
    regionBackdrop,
    regionHeader,
    regionBody,
    regionFooter,
    cBackdrop,
    cModalImage,
    promptValue,
    onBackdropInteraction,
    onClose,
    onConfirm,
    onPromptSubmit,
    onKeyDown: onKeyDown3,
    parent,
    classesModal,
    classesBackdrop,
    $modalStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
    if ("duration" in $$props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("background" in $$props)
      $$invalidate(19, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(20, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(21, height = $$new_props.height);
    if ("padding" in $$props)
      $$invalidate(22, padding = $$new_props.padding);
    if ("spacing" in $$props)
      $$invalidate(23, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(24, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(25, shadow = $$new_props.shadow);
    if ("buttonNeutral" in $$props)
      $$invalidate(1, buttonNeutral = $$new_props.buttonNeutral);
    if ("buttonPositive" in $$props)
      $$invalidate(2, buttonPositive = $$new_props.buttonPositive);
    if ("buttonTextCancel" in $$props)
      $$invalidate(3, buttonTextCancel = $$new_props.buttonTextCancel);
    if ("buttonTextConfirm" in $$props)
      $$invalidate(4, buttonTextConfirm = $$new_props.buttonTextConfirm);
    if ("buttonTextSubmit" in $$props)
      $$invalidate(5, buttonTextSubmit = $$new_props.buttonTextSubmit);
    if ("regionBackdrop" in $$props)
      $$invalidate(26, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionHeader" in $$props)
      $$invalidate(6, regionHeader = $$new_props.regionHeader);
    if ("regionBody" in $$props)
      $$invalidate(7, regionBody = $$new_props.regionBody);
    if ("regionFooter" in $$props)
      $$invalidate(8, regionFooter = $$new_props.regionFooter);
    if ("promptValue" in $$props)
      $$invalidate(9, promptValue = $$new_props.promptValue);
    if ("parent" in $$props)
      $$invalidate(10, parent = $$new_props.parent);
    if ("classesModal" in $$props)
      $$invalidate(11, classesModal = $$new_props.classesModal);
    if ("classesBackdrop" in $$props)
      $$invalidate(12, classesBackdrop = $$new_props.classesBackdrop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(12, classesBackdrop = `${cBackdrop} ${regionBackdrop} ${$$props.class || ""}`);
    if ($$self.$$.dirty & 66584576) {
      $:
        $$invalidate(11, classesModal = `${background} ${width} ${height} ${padding} ${spacing} ${rounded} ${shadow}`);
    }
    if ($$self.$$.dirty & 133693950) {
      $:
        $$invalidate(10, parent = {
          background,
          width,
          height,
          padding,
          spacing,
          rounded,
          shadow,
          buttonNeutral,
          buttonPositive,
          buttonTextCancel,
          buttonTextConfirm,
          buttonTextSubmit,
          regionBackdrop,
          regionHeader,
          regionBody,
          regionFooter,
          onClose
        });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    duration,
    buttonNeutral,
    buttonPositive,
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit,
    regionHeader,
    regionBody,
    regionFooter,
    promptValue,
    parent,
    classesModal,
    classesBackdrop,
    $modalStore,
    onBackdropInteraction,
    onClose,
    onConfirm,
    onPromptSubmit,
    onKeyDown3,
    background,
    width,
    height,
    padding,
    spacing,
    rounded,
    shadow,
    regionBackdrop,
    input_input_handler
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {
      duration: 0,
      background: 19,
      width: 20,
      height: 21,
      padding: 22,
      spacing: 23,
      rounded: 24,
      shadow: 25,
      buttonNeutral: 1,
      buttonPositive: 2,
      buttonTextCancel: 3,
      buttonTextConfirm: 4,
      buttonTextSubmit: 5,
      regionBackdrop: 26,
      regionHeader: 6,
      regionBody: 7,
      regionFooter: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment32.name
    });
  }
  get duration() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNeutral() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNeutral(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonPositive() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonPositive(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextCancel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextCancel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextConfirm() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextConfirm(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextSubmit() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextSubmit(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBackdrop() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBackdrop(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeader() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeader(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBody() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBody(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFooter() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFooter(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/Drawer/Drawer.svelte
var { window: window_1 } = globals;
var file33 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\utilities\\Drawer\\Drawer.svelte";
function create_if_block22(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div0_transition;
  let div1_class_value;
  let focusTrap_action;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[23].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[22], null);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-labelledby": true,
        "aria-describedby": true
      });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "drawer " + ctx[5]);
      attr_dev(div0, "data-testid", "drawer");
      attr_dev(div0, "role", "dialog");
      attr_dev(div0, "aria-modal", "true");
      attr_dev(div0, "aria-labelledby", ctx[1]);
      attr_dev(div0, "aria-describedby", ctx[2]);
      add_location(div0, file33, 142, 2, 5134);
      attr_dev(div1, "class", div1_class_value = "drawer-backdrop " + ctx[6]);
      attr_dev(div1, "data-testid", "drawer-backdrop");
      add_location(div1, file33, 128, 1, 4854);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[27](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[28], false, false, false),
          listen_dev(div1, "keydown", ctx[24], false, false, false),
          listen_dev(div1, "keyup", ctx[25], false, false, false),
          listen_dev(div1, "keypress", ctx[26], false, false, false),
          action_destroyer(focusTrap_action = focusTrap.call(null, div1, true))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[22],
            !current ? get_all_dirty_from_scope(ctx[22]) : get_slot_changes(default_slot_template, ctx[22], dirty, null),
            null
          );
        }
      }
      if (!current || dirty[0] & 32 && div0_class_value !== (div0_class_value = "drawer " + ctx[5])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & 2) {
        attr_dev(div0, "aria-labelledby", ctx[1]);
      }
      if (!current || dirty[0] & 4) {
        attr_dev(div0, "aria-describedby", ctx[2]);
      }
      if (!current || dirty[0] & 64 && div1_class_value !== (div1_class_value = "drawer-backdrop " + ctx[6])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!div0_transition)
            div0_transition = create_bidirectional_transition(
              div0,
              fly,
              {
                x: ctx[4].x,
                y: ctx[4].y,
                duration: ctx[0]
              },
              true
            );
          div0_transition.run(1);
        });
      }
      if (local) {
        add_render_callback(() => {
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(div1, fade, { duration: ctx[0] }, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(
            div0,
            fly,
            {
              x: ctx[4].x,
              y: ctx[4].y,
              duration: ctx[0]
            },
            false
          );
        div0_transition.run(0);
      }
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: ctx[0] }, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div0_transition)
        div0_transition.end();
      ctx[27](null);
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(127:0) {#if $drawerStore.open === true}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[7].open === true && create_if_block22(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(window_1, "keydown", ctx[9], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[7].open === true) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBaseBackdrop = "fixed top-0 left-0 right-0 bottom-0 z-40 flex";
var cBaseDrawer = "shadow-xl overflow-y-auto";
function percentage(percent, amount) {
  return amount / 100 * percent;
}
function instance33($$self, $$props, $$invalidate) {
  let classesWidth;
  let classesHeight;
  let classesBackdrop;
  let classesDrawer;
  let $drawerStore;
  validate_store(drawerStore, "drawerStore");
  component_subscribe($$self, drawerStore, ($$value) => $$invalidate(7, $drawerStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Drawer", slots, ["default"]);
  let { position = "left" } = $$props;
  let { duration = 150 } = $$props;
  let { bgBackdrop = "bg-surface-backdrop-token" } = $$props;
  let { blur = "backdrop-blur-xs" } = $$props;
  let { bgDrawer = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "" } = $$props;
  let { width = "" } = $$props;
  let { height = "" } = $$props;
  let { margin = "" } = $$props;
  let { labelledby = "" } = $$props;
  let { describedby = "" } = $$props;
  let elemBackdrop;
  let windowSettings = { width: 1920, height: 1080 };
  let styleSettings = { backdrop: "", width: "", height: "" };
  let animSettings = { x: 0, y: 0 };
  const propDefaults = {
    position,
    duration,
    bgBackdrop,
    blur,
    bgDrawer,
    border,
    rounded,
    width,
    height,
    margin,
    labelledby,
    describedby
  };
  drawerStore.subscribe((settings) => {
    if (settings.open === false)
      return;
    applySettings(settings);
    setPosition();
  });
  function applySettings(settings) {
    $$invalidate(18, position = settings.position || propDefaults.position);
    $$invalidate(0, duration = settings.duration || propDefaults.duration);
    $$invalidate(10, bgBackdrop = settings.bgBackdrop || propDefaults.bgBackdrop);
    $$invalidate(11, blur = settings.blur || propDefaults.blur);
    $$invalidate(12, bgDrawer = settings.bgDrawer || propDefaults.bgDrawer);
    $$invalidate(13, border = settings.border || propDefaults.border);
    $$invalidate(14, rounded = settings.rounded || propDefaults.rounded);
    $$invalidate(15, width = settings.width || propDefaults.width);
    $$invalidate(16, height = settings.height || propDefaults.height);
    $$invalidate(17, margin = settings.margin || propDefaults.margin);
    $$invalidate(1, labelledby = settings.labelledby || propDefaults.labelledby);
    $$invalidate(2, describedby = settings.describedby || propDefaults.describedby);
  }
  function setPosition() {
    switch (position) {
      case "top":
        $$invalidate(19, styleSettings = {
          backdrop: "flex-col justify-start",
          width: "w-full",
          height: "h-[40%]"
        });
        $$invalidate(4, animSettings = {
          x: 0,
          y: -percentage(40, windowSettings.height)
        });
        break;
      case "bottom":
        $$invalidate(19, styleSettings = {
          backdrop: "flex-col justify-end",
          width: "w-full",
          height: "h-[40%]"
        });
        $$invalidate(4, animSettings = {
          x: 0,
          y: percentage(40, windowSettings.height)
        });
        break;
      case "right":
        $$invalidate(19, styleSettings = {
          backdrop: "justify-end",
          width: "w-[90%]",
          height: "h-full"
        });
        $$invalidate(4, animSettings = {
          x: percentage(90, windowSettings.width),
          y: 0
        });
        break;
      default:
        $$invalidate(19, styleSettings = {
          backdrop: "justify-start",
          width: "w-[90%]",
          height: "h-full"
        });
        $$invalidate(4, animSettings = {
          x: -percentage(90, windowSettings.width),
          y: 0
        });
        break;
    }
  }
  function onClickBackdrop(e) {
    if (e.target === elemBackdrop)
      drawerStore.close();
  }
  function onKeydownWindow(e) {
    if (!$drawerStore)
      return;
    if (e.code === "Escape")
      drawerStore.close();
  }
  onMount(() => {
    windowSettings.width = window.innerWidth;
    windowSettings.height = window.innerHeight;
  });
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemBackdrop = $$value;
      $$invalidate(3, elemBackdrop);
    });
  }
  const click_handler = (e) => {
    onClickBackdrop(e);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(33, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("position" in $$new_props)
      $$invalidate(18, position = $$new_props.position);
    if ("duration" in $$new_props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("bgBackdrop" in $$new_props)
      $$invalidate(10, bgBackdrop = $$new_props.bgBackdrop);
    if ("blur" in $$new_props)
      $$invalidate(11, blur = $$new_props.blur);
    if ("bgDrawer" in $$new_props)
      $$invalidate(12, bgDrawer = $$new_props.bgDrawer);
    if ("border" in $$new_props)
      $$invalidate(13, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("width" in $$new_props)
      $$invalidate(15, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(16, height = $$new_props.height);
    if ("margin" in $$new_props)
      $$invalidate(17, margin = $$new_props.margin);
    if ("labelledby" in $$new_props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("describedby" in $$new_props)
      $$invalidate(2, describedby = $$new_props.describedby);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    fly,
    onMount,
    focusTrap,
    drawerStore,
    position,
    duration,
    bgBackdrop,
    blur,
    bgDrawer,
    border,
    rounded,
    width,
    height,
    margin,
    labelledby,
    describedby,
    cBaseBackdrop,
    cBaseDrawer,
    elemBackdrop,
    windowSettings,
    styleSettings,
    animSettings,
    propDefaults,
    applySettings,
    setPosition,
    percentage,
    onClickBackdrop,
    onKeydownWindow,
    classesHeight,
    classesWidth,
    classesDrawer,
    classesBackdrop,
    $drawerStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(33, $$props = assign(assign({}, $$props), $$new_props));
    if ("position" in $$props)
      $$invalidate(18, position = $$new_props.position);
    if ("duration" in $$props)
      $$invalidate(0, duration = $$new_props.duration);
    if ("bgBackdrop" in $$props)
      $$invalidate(10, bgBackdrop = $$new_props.bgBackdrop);
    if ("blur" in $$props)
      $$invalidate(11, blur = $$new_props.blur);
    if ("bgDrawer" in $$props)
      $$invalidate(12, bgDrawer = $$new_props.bgDrawer);
    if ("border" in $$props)
      $$invalidate(13, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("width" in $$props)
      $$invalidate(15, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(16, height = $$new_props.height);
    if ("margin" in $$props)
      $$invalidate(17, margin = $$new_props.margin);
    if ("labelledby" in $$props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("describedby" in $$props)
      $$invalidate(2, describedby = $$new_props.describedby);
    if ("elemBackdrop" in $$props)
      $$invalidate(3, elemBackdrop = $$new_props.elemBackdrop);
    if ("windowSettings" in $$props)
      windowSettings = $$new_props.windowSettings;
    if ("styleSettings" in $$props)
      $$invalidate(19, styleSettings = $$new_props.styleSettings);
    if ("animSettings" in $$props)
      $$invalidate(4, animSettings = $$new_props.animSettings);
    if ("classesHeight" in $$props)
      $$invalidate(20, classesHeight = $$new_props.classesHeight);
    if ("classesWidth" in $$props)
      $$invalidate(21, classesWidth = $$new_props.classesWidth);
    if ("classesDrawer" in $$props)
      $$invalidate(5, classesDrawer = $$new_props.classesDrawer);
    if ("classesBackdrop" in $$props)
      $$invalidate(6, classesBackdrop = $$new_props.classesBackdrop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 557056) {
      $:
        $$invalidate(21, classesWidth = width ? width : styleSettings.width);
    }
    if ($$self.$$.dirty[0] & 589824) {
      $:
        $$invalidate(20, classesHeight = height ? height : styleSettings.height);
    }
    $:
      $$invalidate(6, classesBackdrop = `${cBaseBackdrop} ${styleSettings.backdrop} ${bgBackdrop} ${blur} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & 3305472) {
      $:
        $$invalidate(5, classesDrawer = `${cBaseDrawer} ${classesWidth} ${classesHeight} ${bgDrawer} ${border} ${margin} ${rounded}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    duration,
    labelledby,
    describedby,
    elemBackdrop,
    animSettings,
    classesDrawer,
    classesBackdrop,
    $drawerStore,
    onClickBackdrop,
    onKeydownWindow,
    bgBackdrop,
    blur,
    bgDrawer,
    border,
    rounded,
    width,
    height,
    margin,
    position,
    styleSettings,
    classesHeight,
    classesWidth,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    div1_binding,
    click_handler
  ];
}
var Drawer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance33,
      create_fragment33,
      safe_not_equal,
      {
        position: 18,
        duration: 0,
        bgBackdrop: 10,
        blur: 11,
        bgDrawer: 12,
        border: 13,
        rounded: 14,
        width: 15,
        height: 16,
        margin: 17,
        labelledby: 1,
        describedby: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Drawer",
      options,
      id: create_fragment33.name
    });
  }
  get position() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgBackdrop() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgBackdrop(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blur(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgDrawer() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgDrawer(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get margin() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set margin(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedby() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedby(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Drawer_default = Drawer;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/LightSwitch/LightSwitch.svelte
var file34 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\utilities\\LightSwitch\\LightSwitch.svelte";
function create_fragment34(ctx) {
  let div1;
  let div0;
  let svgicon;
  let div0_class_value;
  let div1_class_value;
  let div1_title_value;
  let current;
  let mounted;
  let dispose;
  svgicon = new SvgIcon_default({
    props: {
      name: ctx[0] === false ? "sun" : "moon",
      class: "lightswitch-icon " + cIcon
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      create_component(svgicon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-label": true,
        "aria-checked": true,
        title: true,
        tabindex: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(svgicon.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "lightswitch-thumb " + ctx[1]);
      add_location(div0, file34, 65, 1, 2365);
      attr_dev(div1, "class", div1_class_value = "lightswitch " + ctx[2]);
      attr_dev(div1, "role", "switch");
      attr_dev(div1, "aria-label", "Light Switch");
      attr_dev(div1, "aria-checked", ctx[0]);
      attr_dev(div1, "title", div1_title_value = "Toggle " + (ctx[0] ? "Light" : "Dark") + " Mode");
      attr_dev(div1, "tabindex", "0");
      add_location(div1, file34, 54, 0, 2112);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      mount_component(svgicon, div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div1, "click", ctx[3], false, false, false),
          listen_dev(div1, "keydown", onKeyDown2, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const svgicon_changes = {};
      if (dirty & 1)
        svgicon_changes.name = ctx2[0] === false ? "sun" : "moon";
      svgicon.$set(svgicon_changes);
      if (!current || dirty & 2 && div0_class_value !== (div0_class_value = "lightswitch-thumb " + ctx2[1])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & 4 && div1_class_value !== (div1_class_value = "lightswitch " + ctx2[2])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & 1) {
        attr_dev(div1, "aria-checked", ctx2[0]);
      }
      if (!current || dirty & 1 && div1_title_value !== (div1_title_value = "Toggle " + (ctx2[0] ? "Light" : "Dark") + " Mode")) {
        attr_dev(div1, "title", div1_title_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svgicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svgicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(svgicon);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cTrack2 = "inline-block bg-surface-200-700-token ring-[1px] ring-surface-300-600-token ring-inset w-12 h-6 rounded-full cursor-pointer transition-all duration-[100ms]";
var cThumb2 = "bg-white dark:bg-black fill-white dark:fill-black w-6 h-6 flex justify-center items-center rounded-full shadow-lg transition-all duration-[100ms] scale-90";
var cIcon = "block w-4 h-4";
function onKeyDown2(event) {
  if (["Enter", "Space"].includes(event.code)) {
    event.preventDefault();
    event.target.click();
  }
}
function instance34($$self, $$props, $$invalidate) {
  let classesPosition;
  let classesBase;
  let classesThumb;
  let $storeLightSwitch;
  let $storePrefersDarkScheme;
  validate_store(storeLightSwitch, "storeLightSwitch");
  component_subscribe($$self, storeLightSwitch, ($$value) => $$invalidate(0, $storeLightSwitch = $$value));
  validate_store(storePrefersDarkScheme, "storePrefersDarkScheme");
  component_subscribe($$self, storePrefersDarkScheme, ($$value) => $$invalidate(5, $storePrefersDarkScheme = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightSwitch", slots, []);
  function setPrefersDarkScheme() {
    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    storePrefersDarkScheme.set(prefersDark);
  }
  function setElemHtmlClass() {
    const elemHtmlClassList = document.documentElement.classList;
    if ($storeLightSwitch === void 0) {
      set_store_value(storeLightSwitch, $storeLightSwitch = $storePrefersDarkScheme, $storeLightSwitch);
    }
    $storeLightSwitch === true ? elemHtmlClassList.add("dark") : elemHtmlClassList.remove("dark");
  }
  function onClick() {
    storeLightSwitch.set(set_store_value(storeLightSwitch, $storeLightSwitch = !$storeLightSwitch, $storeLightSwitch));
    setElemHtmlClass();
  }
  onMount(() => {
    setPrefersDarkScheme();
    setElemHtmlClass();
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$capture_state = () => ({
    onMount,
    SvgIcon: SvgIcon_default,
    storePrefersDarkScheme,
    storeLightSwitch,
    cTrack: cTrack2,
    cThumb: cThumb2,
    cIcon,
    setPrefersDarkScheme,
    setElemHtmlClass,
    onClick,
    onKeyDown: onKeyDown2,
    classesPosition,
    classesThumb,
    classesBase,
    $storeLightSwitch,
    $storePrefersDarkScheme
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("classesPosition" in $$props)
      $$invalidate(4, classesPosition = $$new_props.classesPosition);
    if ("classesThumb" in $$props)
      $$invalidate(1, classesThumb = $$new_props.classesThumb);
    if ("classesBase" in $$props)
      $$invalidate(2, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(4, classesPosition = $storeLightSwitch ? "translate-x-full" : "translate-x-0");
    }
    $:
      $$invalidate(2, classesBase = `${cTrack2} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(1, classesThumb = `${cThumb2} ${classesPosition}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [$storeLightSwitch, classesThumb, classesBase, onClick, classesPosition];
}
var LightSwitch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightSwitch",
      options,
      id: create_fragment34.name
    });
  }
};
var LightSwitch_default = LightSwitch;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/utilities/Toast/Toast.svelte
var file35 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\utilities\\Toast\\Toast.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[25] = i;
  return child_ctx;
}
function create_if_block23(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div0_transition;
  let div1_class_value;
  let current;
  let each_value = ctx[8];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "snackbar " + ctx[6]);
      add_location(div0, file35, 100, 2, 3274);
      attr_dev(div1, "class", div1_class_value = "snackbar-wrapper " + ctx[7]);
      attr_dev(div1, "data-testid", "snackbar-wrapper");
      add_location(div1, file35, 98, 1, 3177);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 813) {
        each_value = ctx[8];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & 64 && div0_class_value !== (div0_class_value = "snackbar " + ctx[6])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & 128 && div1_class_value !== (div1_class_value = "snackbar-wrapper " + ctx[7])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(
            div0,
            fly,
            {
              x: ctx[4].x,
              y: ctx[4].y,
              duration: ctx[1]
            },
            true
          );
        div0_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (!div0_transition)
        div0_transition = create_bidirectional_transition(
          div0,
          fly,
          {
            x: ctx[4].x,
            y: ctx[4].y,
            duration: ctx[1]
          },
          false
        );
      div0_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      if (detaching && div0_transition)
        div0_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(97:0) {#if $toastStore.length}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let div2;
  let div0;
  let raw_value = ctx[23].message + "";
  let t0;
  let div1;
  let t1;
  let button;
  let t2;
  let button_class_value;
  let t3;
  let div2_class_value;
  let mounted;
  let dispose;
  let if_block = ctx[23].action && create_if_block_27(ctx);
  function click_handler_1() {
    return ctx[21](ctx[23]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      button = element("button");
      t2 = text("✕");
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-live": true,
        "data-testid": true
      });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      button = claim_element(div1_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t2 = claim_text(button_nodes, "✕");
      button_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "text-base");
      add_location(div0, file35, 105, 6, 3557);
      attr_dev(button, "class", button_class_value = "btn-icon " + ctx[3]);
      add_location(button, file35, 109, 7, 3812);
      attr_dev(div1, "class", "flex items-center space-x-2");
      add_location(div1, file35, 107, 6, 3641);
      attr_dev(div2, "class", div2_class_value = "toast " + ctx[5] + " " + ctx[23].classes);
      attr_dev(div2, "role", "alert");
      attr_dev(div2, "aria-live", "polite");
      attr_dev(div2, "data-testid", "toast");
      add_location(div2, file35, 104, 5, 3453);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      div0.innerHTML = raw_value;
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, button);
      append_hydration_dev(button, t2);
      append_hydration_dev(div2, t3);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_1, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 256 && raw_value !== (raw_value = ctx[23].message + ""))
        div0.innerHTML = raw_value;
      ;
      if (ctx[23].action) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_27(ctx);
          if_block.c();
          if_block.m(div1, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 8 && button_class_value !== (button_class_value = "btn-icon " + ctx[3])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & 288 && div2_class_value !== (div2_class_value = "toast " + ctx[5] + " " + ctx[23].classes)) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(103:4) {#if i < max + 1}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let button;
  let raw_value = ctx[23].action.label + "";
  let button_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[20](ctx[25]);
  }
  const block = {
    c: function create() {
      button = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "btn " + ctx[2]);
      add_location(button, file35, 108, 21, 3704);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 256 && raw_value !== (raw_value = ctx[23].action.label + ""))
        button.innerHTML = raw_value;
      ;
      if (dirty & 4 && button_class_value !== (button_class_value = "btn " + ctx[2])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(109:7) {#if t.action}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let if_block_anchor;
  let if_block = ctx[25] < ctx[0] + 1 && create_if_block_114(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (ctx2[25] < ctx2[0] + 1) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_114(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(102:3) {#each $toastStore as t, i}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[8].length && create_if_block23(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[8].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cWrapper = "flex fixed top-0 left-0 right-0 bottom-0 z-[888] pointer-events-none";
var cSnackbar = "flex flex-col space-y-2";
var cToast = "flex justify-between items-center pointer-events-auto";
function instance35($$self, $$props, $$invalidate) {
  let classesWrapper;
  let classesSnackbar;
  let classesBase;
  let $toastStore;
  validate_store(toastStore, "toastStore");
  component_subscribe($$self, toastStore, ($$value) => $$invalidate(8, $toastStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toast", slots, []);
  let { position = "b" } = $$props;
  let { max = 3 } = $$props;
  let { duration = 150 } = $$props;
  let { background = "bg-accent-500" } = $$props;
  let { width = "max-w-[640px]" } = $$props;
  let { color = "text-on-accent-token" } = $$props;
  let { padding = "p-4" } = $$props;
  let { spacing = "space-x-4" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow-lg" } = $$props;
  let { buttonAction = "btn-filled" } = $$props;
  let { buttonDismiss = "btn-filled" } = $$props;
  let cPosition;
  let cAlign;
  let animAxis = { x: 0, y: 0 };
  switch (position) {
    case "t":
      cPosition = "justify-center items-start";
      cAlign = "items-center";
      animAxis = { x: 0, y: -100 };
      break;
    case "b":
      cPosition = "justify-center items-end";
      cAlign = "items-center";
      animAxis = { x: 0, y: 100 };
      break;
    case "l":
      cPosition = "justify-start items-center";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "r":
      cPosition = "justify-end items-center";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
    case "tl":
      cPosition = "justify-start items-start";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "tr":
      cPosition = "justify-end items-start";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
    case "bl":
      cPosition = "justify-start items-end";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "br":
      cPosition = "justify-end items-end";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
  }
  function onAction(index) {
    var _a, _b;
    (_b = (_a = $toastStore[index]) == null ? void 0 : _a.action) == null ? void 0 : _b.response();
    toastStore.close($toastStore[index].id);
  }
  const click_handler = (i) => onAction(i);
  const click_handler_1 = (t) => {
    toastStore.close(t.id);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("position" in $$new_props)
      $$invalidate(10, position = $$new_props.position);
    if ("max" in $$new_props)
      $$invalidate(0, max = $$new_props.max);
    if ("duration" in $$new_props)
      $$invalidate(1, duration = $$new_props.duration);
    if ("background" in $$new_props)
      $$invalidate(11, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(12, width = $$new_props.width);
    if ("color" in $$new_props)
      $$invalidate(13, color = $$new_props.color);
    if ("padding" in $$new_props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("spacing" in $$new_props)
      $$invalidate(15, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(16, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(17, shadow = $$new_props.shadow);
    if ("buttonAction" in $$new_props)
      $$invalidate(2, buttonAction = $$new_props.buttonAction);
    if ("buttonDismiss" in $$new_props)
      $$invalidate(3, buttonDismiss = $$new_props.buttonDismiss);
  };
  $$self.$capture_state = () => ({
    fly,
    toastStore,
    position,
    max,
    duration,
    background,
    width,
    color,
    padding,
    spacing,
    rounded,
    shadow,
    buttonAction,
    buttonDismiss,
    cWrapper,
    cSnackbar,
    cToast,
    cPosition,
    cAlign,
    animAxis,
    onAction,
    classesBase,
    classesSnackbar,
    classesWrapper,
    $toastStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("position" in $$props)
      $$invalidate(10, position = $$new_props.position);
    if ("max" in $$props)
      $$invalidate(0, max = $$new_props.max);
    if ("duration" in $$props)
      $$invalidate(1, duration = $$new_props.duration);
    if ("background" in $$props)
      $$invalidate(11, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(12, width = $$new_props.width);
    if ("color" in $$props)
      $$invalidate(13, color = $$new_props.color);
    if ("padding" in $$props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("spacing" in $$props)
      $$invalidate(15, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(16, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(17, shadow = $$new_props.shadow);
    if ("buttonAction" in $$props)
      $$invalidate(2, buttonAction = $$new_props.buttonAction);
    if ("buttonDismiss" in $$props)
      $$invalidate(3, buttonDismiss = $$new_props.buttonDismiss);
    if ("cPosition" in $$props)
      $$invalidate(18, cPosition = $$new_props.cPosition);
    if ("cAlign" in $$props)
      $$invalidate(19, cAlign = $$new_props.cAlign);
    if ("animAxis" in $$props)
      $$invalidate(4, animAxis = $$new_props.animAxis);
    if ("classesBase" in $$props)
      $$invalidate(5, classesBase = $$new_props.classesBase);
    if ("classesSnackbar" in $$props)
      $$invalidate(6, classesSnackbar = $$new_props.classesSnackbar);
    if ("classesWrapper" in $$props)
      $$invalidate(7, classesWrapper = $$new_props.classesWrapper);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesWrapper = `${cWrapper} ${cPosition} ${$$props.class || ""}`);
    if ($$self.$$.dirty & 540672) {
      $:
        $$invalidate(6, classesSnackbar = `${cSnackbar} ${cAlign} ${padding}`);
    }
    if ($$self.$$.dirty & 260096) {
      $:
        $$invalidate(5, classesBase = `${cToast} ${background} ${width} ${color} ${padding} ${spacing} ${rounded} ${shadow}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    max,
    duration,
    buttonAction,
    buttonDismiss,
    animAxis,
    classesBase,
    classesSnackbar,
    classesWrapper,
    $toastStore,
    onAction,
    position,
    background,
    width,
    color,
    padding,
    spacing,
    rounded,
    shadow,
    cPosition,
    cAlign,
    click_handler,
    click_handler_1
  ];
}
var Toast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      position: 10,
      max: 0,
      duration: 1,
      background: 11,
      width: 12,
      color: 13,
      padding: 14,
      spacing: 15,
      rounded: 16,
      shadow: 17,
      buttonAction: 2,
      buttonDismiss: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toast",
      options,
      id: create_fragment35.name
    });
  }
  get position() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonAction() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonAction(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonDismiss() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonDismiss(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toast_default = Toast;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Apollo.svelte
var file36 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\actions\\Filters\\svg-filters\\Apollo.svelte";
function create_fragment36(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { values: true, result: true, in: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "values", "0.8 0.6 -0.4 0.1 0,\n					0 1.2 0.05 0 0,\n					0 -1 3 0.02 0,\n					0 0 0 50 0");
      attr_dev(feColorMatrix, "result", "final");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      add_location(feColorMatrix, file36, 3, 2, 207);
      attr_dev(filter2, "id", "Apollo");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file36, 2, 1, 85);
      attr_dev(svg, "id", "svg-filter-apollo");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file36, 1, 0, 40);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Apollo", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Apollo> was created with unknown prop '${key}'`);
  });
  return [];
}
var Apollo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Apollo",
      options,
      id: create_fragment36.name
    });
  }
};
var Apollo_default = Apollo;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/BlueNight.svelte
var file37 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\actions\\Filters\\svg-filters\\BlueNight.svelte";
function create_fragment37(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.000 0.000 0.000 0.000 0.000 \n                    0.000 1.000 0.000 0.000 0.05 \n                    0.000 0.000 1.000 0.000 0.400 \n                    0.000 0.000 0.000 1.000 0.000");
      add_location(feColorMatrix, file37, 3, 2, 219);
      attr_dev(filter2, "id", "BlueNight");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file37, 2, 1, 94);
      attr_dev(svg, "id", "svg-filter-bluenight");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file37, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BlueNight", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BlueNight> was created with unknown prop '${key}'`);
  });
  return [];
}
var BlueNight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BlueNight",
      options,
      id: create_fragment37.name
    });
  }
};
var BlueNight_default = BlueNight;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Emerald.svelte
var file38 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\actions\\Filters\\svg-filters\\Emerald.svelte";
function create_fragment38(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  let feComponentTransfer;
  let feFuncR;
  let feFuncG;
  let feFuncB;
  let feFuncA;
  let feBlend;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      feComponentTransfer = svg_element("feComponentTransfer");
      feFuncR = svg_element("feFuncR");
      feFuncG = svg_element("feFuncG");
      feFuncB = svg_element("feFuncB");
      feFuncA = svg_element("feFuncA");
      feBlend = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        in: true,
        result: true,
        values: true
      });
      children(feColorMatrix).forEach(detach_dev);
      feComponentTransfer = claim_svg_element(filter_nodes, "feComponentTransfer", { in: true, result: true });
      var feComponentTransfer_nodes = children(feComponentTransfer);
      feFuncR = claim_svg_element(feComponentTransfer_nodes, "feFuncR", { type: true, tableValues: true });
      children(feFuncR).forEach(detach_dev);
      feFuncG = claim_svg_element(feComponentTransfer_nodes, "feFuncG", { type: true, tableValues: true });
      children(feFuncG).forEach(detach_dev);
      feFuncB = claim_svg_element(feComponentTransfer_nodes, "feFuncB", { type: true, tableValues: true });
      children(feFuncB).forEach(detach_dev);
      feFuncA = claim_svg_element(feComponentTransfer_nodes, "feFuncA", { type: true, tableValues: true });
      children(feFuncA).forEach(detach_dev);
      feComponentTransfer_nodes.forEach(detach_dev);
      feBlend = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      attr_dev(feColorMatrix, "values", "\n            .16 .185 .129 0 0\n            .16 .185 .129 0 0\n            .16 .185 .129 0 0\n            0 0 0 0.33 0");
      add_location(feColorMatrix, file38, 4, 2, 245);
      attr_dev(feFuncR, "type", "table");
      attr_dev(feFuncR, "tableValues", "0.03 0.9");
      add_location(feFuncR, file38, 15, 3, 527);
      attr_dev(feFuncG, "type", "table");
      attr_dev(feFuncG, "tableValues", "0.57 1");
      add_location(feFuncG, file38, 16, 3, 578);
      attr_dev(feFuncB, "type", "table");
      attr_dev(feFuncB, "tableValues", "0.49 0.53");
      add_location(feFuncB, file38, 17, 3, 627);
      attr_dev(feFuncA, "type", "table");
      attr_dev(feFuncA, "tableValues", "0 1");
      add_location(feFuncA, file38, 18, 3, 679);
      attr_dev(feComponentTransfer, "in", "colormatrix");
      attr_dev(feComponentTransfer, "result", "componentTransfer");
      add_location(feComponentTransfer, file38, 14, 2, 458);
      attr_dev(feBlend, "mode", "normal");
      attr_dev(feBlend, "in", "componentTransfer");
      attr_dev(feBlend, "in2", "SourceGraphic");
      attr_dev(feBlend, "result", "blend");
      add_location(feBlend, file38, 20, 2, 749);
      attr_dev(filter2, "id", "Emerald");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file38, 2, 1, 88);
      attr_dev(svg, "id", "svg-filter-emerald");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file38, 1, 0, 42);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
      append_hydration_dev(filter2, feComponentTransfer);
      append_hydration_dev(feComponentTransfer, feFuncR);
      append_hydration_dev(feComponentTransfer, feFuncG);
      append_hydration_dev(feComponentTransfer, feFuncB);
      append_hydration_dev(feComponentTransfer, feFuncA);
      append_hydration_dev(filter2, feBlend);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Emerald", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Emerald> was created with unknown prop '${key}'`);
  });
  return [];
}
var Emerald = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Emerald",
      options,
      id: create_fragment38.name
    });
  }
};
var Emerald_default = Emerald;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/GreenFall.svelte
var file39 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\actions\\Filters\\svg-filters\\GreenFall.svelte";
function create_fragment39(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "0.5 -0.4 0.3332 0 0\n					0 0.4 0.3 0 0\n					0 0 0.5 0 0\n					0 0 0 500 -20");
      attr_dev(feColorMatrix, "x", "0%");
      attr_dev(feColorMatrix, "y", "0%");
      attr_dev(feColorMatrix, "width", "100%");
      attr_dev(feColorMatrix, "height", "100%");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      add_location(feColorMatrix, file39, 12, 2, 294);
      attr_dev(filter2, "id", "GreenFall");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file39, 2, 1, 101);
      attr_dev(svg, "id", "svg-filter-greenfall");
      attr_dev(svg, "class", "filter hidden");
      add_location(svg, file39, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GreenFall", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GreenFall> was created with unknown prop '${key}'`);
  });
  return [];
}
var GreenFall = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GreenFall",
      options,
      id: create_fragment39.name
    });
  }
};
var GreenFall_default = GreenFall;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Noir.svelte
var file40 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\actions\\Filters\\svg-filters\\Noir.svelte";
function create_fragment40(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  let feBlend0;
  let feDiffuseLighting;
  let fePointLight;
  let feBlend1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      feBlend0 = svg_element("feBlend");
      feDiffuseLighting = svg_element("feDiffuseLighting");
      fePointLight = svg_element("fePointLight");
      feBlend1 = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix).forEach(detach_dev);
      feBlend0 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend0).forEach(detach_dev);
      feDiffuseLighting = claim_svg_element(filter_nodes, "feDiffuseLighting", {
        surfaceScale: true,
        diffuseConstant: true,
        "lighting-color": true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      var feDiffuseLighting_nodes = children(feDiffuseLighting);
      fePointLight = claim_svg_element(feDiffuseLighting_nodes, "fePointLight", { x: true, y: true, z: true });
      children(fePointLight).forEach(detach_dev);
      feDiffuseLighting_nodes.forEach(detach_dev);
      feBlend1 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend1).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "saturate");
      attr_dev(feColorMatrix, "values", "0");
      attr_dev(feColorMatrix, "x", "0%");
      attr_dev(feColorMatrix, "y", "0%");
      attr_dev(feColorMatrix, "width", "100%");
      attr_dev(feColorMatrix, "height", "100%");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix1");
      add_location(feColorMatrix, file40, 12, 2, 267);
      attr_dev(feBlend0, "mode", "lighten");
      attr_dev(feBlend0, "x", "0%");
      attr_dev(feBlend0, "y", "0%");
      attr_dev(feBlend0, "width", "100%");
      attr_dev(feBlend0, "height", "100%");
      attr_dev(feBlend0, "in", "colormatrix1");
      attr_dev(feBlend0, "in2", "colormatrix1");
      attr_dev(feBlend0, "result", "blend");
      add_location(feBlend0, file40, 13, 2, 396);
      attr_dev(fePointLight, "x", "200");
      attr_dev(fePointLight, "y", "157");
      attr_dev(fePointLight, "z", "200");
      add_location(fePointLight, file40, 25, 3, 714);
      attr_dev(feDiffuseLighting, "surfaceScale", "7.7");
      attr_dev(feDiffuseLighting, "diffuseConstant", "7.3");
      attr_dev(feDiffuseLighting, "lighting-color", "#707070");
      attr_dev(feDiffuseLighting, "x", "0%");
      attr_dev(feDiffuseLighting, "y", "0%");
      attr_dev(feDiffuseLighting, "width", "100%");
      attr_dev(feDiffuseLighting, "height", "100%");
      attr_dev(feDiffuseLighting, "in", "blend");
      attr_dev(feDiffuseLighting, "result", "diffuseLighting");
      add_location(feDiffuseLighting, file40, 14, 2, 518);
      attr_dev(feBlend1, "mode", "multiply");
      attr_dev(feBlend1, "x", "0%");
      attr_dev(feBlend1, "y", "0%");
      attr_dev(feBlend1, "width", "100%");
      attr_dev(feBlend1, "height", "100%");
      attr_dev(feBlend1, "in", "colormatrix1");
      attr_dev(feBlend1, "in2", "diffuseLighting");
      attr_dev(feBlend1, "result", "blend1");
      add_location(feBlend1, file40, 27, 2, 780);
      attr_dev(filter2, "id", "Noir");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file40, 2, 1, 79);
      attr_dev(svg, "id", "svg-filter-noir");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file40, 1, 0, 36);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
      append_hydration_dev(filter2, feBlend0);
      append_hydration_dev(filter2, feDiffuseLighting);
      append_hydration_dev(feDiffuseLighting, fePointLight);
      append_hydration_dev(filter2, feBlend1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noir", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noir> was created with unknown prop '${key}'`);
  });
  return [];
}
var Noir = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noir",
      options,
      id: create_fragment40.name
    });
  }
};
var Noir_default = Noir;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/NoirLight.svelte
var file41 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\actions\\Filters\\svg-filters\\NoirLight.svelte";
function create_fragment41(ctx) {
  let svg;
  let filter2;
  let feColorMatrix0;
  let feBlend0;
  let feBlend1;
  let feColorMatrix1;
  let feBlend2;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix0 = svg_element("feColorMatrix");
      feBlend0 = svg_element("feBlend");
      feBlend1 = svg_element("feBlend");
      feColorMatrix1 = svg_element("feColorMatrix");
      feBlend2 = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix0 = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix0).forEach(detach_dev);
      feBlend0 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend0).forEach(detach_dev);
      feBlend1 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend1).forEach(detach_dev);
      feColorMatrix1 = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix1).forEach(detach_dev);
      feBlend2 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend2).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix0, "type", "saturate");
      attr_dev(feColorMatrix0, "values", "0");
      attr_dev(feColorMatrix0, "x", "0%");
      attr_dev(feColorMatrix0, "y", "0%");
      attr_dev(feColorMatrix0, "width", "100%");
      attr_dev(feColorMatrix0, "height", "100%");
      attr_dev(feColorMatrix0, "in", "SourceGraphic");
      attr_dev(feColorMatrix0, "result", "colormatrix2");
      add_location(feColorMatrix0, file41, 12, 2, 287);
      attr_dev(feBlend0, "mode", "saturation");
      attr_dev(feBlend0, "x", "0%");
      attr_dev(feBlend0, "y", "0%");
      attr_dev(feBlend0, "width", "100%");
      attr_dev(feBlend0, "height", "100%");
      attr_dev(feBlend0, "in", "SourceGraphic");
      attr_dev(feBlend0, "in2", "colormatrix2");
      attr_dev(feBlend0, "result", "blend2");
      add_location(feBlend0, file41, 13, 2, 416);
      attr_dev(feBlend1, "mode", "screen");
      attr_dev(feBlend1, "x", "0%");
      attr_dev(feBlend1, "y", "0%");
      attr_dev(feBlend1, "width", "100%");
      attr_dev(feBlend1, "height", "100%");
      attr_dev(feBlend1, "in", "colormatrix2");
      attr_dev(feBlend1, "in2", "blend2");
      attr_dev(feBlend1, "result", "blend3");
      add_location(feBlend1, file41, 14, 2, 543);
      attr_dev(feColorMatrix1, "type", "luminanceToAlpha");
      attr_dev(feColorMatrix1, "x", "0%");
      attr_dev(feColorMatrix1, "y", "0%");
      attr_dev(feColorMatrix1, "width", "100%");
      attr_dev(feColorMatrix1, "height", "100%");
      attr_dev(feColorMatrix1, "in", "blend3");
      attr_dev(feColorMatrix1, "result", "colormatrix3");
      add_location(feColorMatrix1, file41, 15, 2, 659);
      attr_dev(feBlend2, "mode", "exclusion");
      attr_dev(feBlend2, "x", "0%");
      attr_dev(feBlend2, "y", "0%");
      attr_dev(feBlend2, "width", "100%");
      attr_dev(feBlend2, "height", "100%");
      attr_dev(feBlend2, "in", "blend3");
      attr_dev(feBlend2, "in2", "colormatrix3");
      attr_dev(feBlend2, "result", "blend5");
      add_location(feBlend2, file41, 16, 2, 778);
      attr_dev(filter2, "id", "NoirLight");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file41, 2, 1, 94);
      attr_dev(svg, "id", "svg-filter-noirlight");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file41, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix0);
      append_hydration_dev(filter2, feBlend0);
      append_hydration_dev(filter2, feBlend1);
      append_hydration_dev(filter2, feColorMatrix1);
      append_hydration_dev(filter2, feBlend2);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NoirLight", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NoirLight> was created with unknown prop '${key}'`);
  });
  return [];
}
var NoirLight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NoirLight",
      options,
      id: create_fragment41.name
    });
  }
};
var NoirLight_default = NoirLight;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Rustic.svelte
var file42 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\actions\\Filters\\svg-filters\\Rustic.svelte";
function create_fragment42(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        in: true,
        result: true,
        values: true
      });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      attr_dev(feColorMatrix, "values", "0.39215686274509803 0.39215686274509803 0.39215686274509803  0 0 \n					0.3333333333333333 0.3333333333333333 0.3333333333333333  0 0 \n					0.30980392156862746 0.30980392156862746 0.30980392156862746  0 0  \n					0 0 0 1 0");
      add_location(feColorMatrix, file42, 3, 2, 207);
      attr_dev(filter2, "id", "Rustic");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file42, 2, 1, 85);
      attr_dev(svg, "id", "svg-filter-rustic");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file42, 1, 0, 40);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Rustic", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Rustic> was created with unknown prop '${key}'`);
  });
  return [];
}
var Rustic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rustic",
      options,
      id: create_fragment42.name
    });
  }
};
var Rustic_default = Rustic;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/Summer84.svelte
var file43 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\actions\\Filters\\svg-filters\\Summer84.svelte";
function create_fragment43(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.300 0.200 0.000 0.000 0.000 \n					0.300 0.600 0.200 0.000 0.000 \n					0.200 1.000 0.200 0.000 0.000 \n					0.000 0.000 0.000 1.000 0.000");
      add_location(feColorMatrix, file43, 3, 2, 215);
      attr_dev(filter2, "id", "Summer84");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file43, 2, 1, 91);
      attr_dev(svg, "id", "svg-filter-summer84");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file43, 1, 0, 44);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Summer84", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Summer84> was created with unknown prop '${key}'`);
  });
  return [];
}
var Summer84 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Summer84",
      options,
      id: create_fragment43.name
    });
  }
};
var Summer84_default = Summer84;

// node_modules/.pnpm/@skeletonlabs+skeleton@0.80.8/node_modules/@skeletonlabs/skeleton/actions/Filters/svg-filters/XPro.svelte
var file44 = "node_modules\\.pnpm\\@skeletonlabs+skeleton@0.80.8\\node_modules\\@skeletonlabs\\skeleton\\actions\\Filters\\svg-filters\\XPro.svelte";
function create_fragment44(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.70 -0.20 0.00 0.00 0.00 \n                    0.10 0.800 0.30 0.00 0.00 \n                    0.20 0.300 0.50 0.00 0.00 \n                    0.00 0.00 0.00 1.00 0.00");
      add_location(feColorMatrix, file44, 3, 2, 199);
      attr_dev(filter2, "id", "XPro");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file44, 2, 1, 79);
      attr_dev(svg, "id", "svg-filter-xpro");
      attr_dev(svg, "class", "hidden");
      add_location(svg, file44, 1, 0, 36);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XPro", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XPro> was created with unknown prop '${key}'`);
  });
  return [];
}
var XPro = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XPro",
      options,
      id: create_fragment44.name
    });
  }
};
var XPro_default = XPro;
export {
  AccordionGroup_default as AccordionGroup,
  AccordionItem_default as AccordionItem,
  Alert_default as Alert,
  Apollo_default as Apollo,
  AppBar_default as AppBar,
  AppRail_default as AppRail,
  AppRailTile_default as AppRailTile,
  AppShell_default as AppShell,
  Avatar_default as Avatar,
  BlueNight_default as BlueNight,
  Breadcrumb_default as Breadcrumb,
  CodeBlock_default as CodeBlock,
  ConicGradient_default as ConicGradient,
  Crumb_default as Crumb,
  Divider_default as Divider,
  Drawer_default as Drawer,
  Emerald_default as Emerald,
  FileButton_default as FileButton,
  FileDropzone_default as FileDropzone,
  GradientHeading_default as GradientHeading,
  GreenFall_default as GreenFall,
  LightSwitch_default as LightSwitch,
  ListBox_default as ListBox,
  ListBoxItem_default as ListBoxItem,
  Modal_default as Modal,
  Noir_default as Noir,
  NoirLight_default as NoirLight,
  Paginator_default as Paginator,
  ProgressBar_default as ProgressBar,
  ProgressRadial_default as ProgressRadial,
  RadioGroup_default as RadioGroup,
  RadioItem_default as RadioItem,
  RangeSlider_default as RangeSlider,
  Rustic_default as Rustic,
  SlideToggle_default as SlideToggle,
  Step_default as Step,
  Stepper_default as Stepper,
  Summer84_default as Summer84,
  Tab_default as Tab,
  TabGroup_default as TabGroup,
  Table_default as Table,
  Toast_default as Toast,
  XPro_default as XPro,
  clipboard,
  createDataTableStore,
  dataTableHandler,
  drawerStore,
  filter,
  focusTrap,
  localStorageStore,
  menu,
  modalStore,
  storeHighlightJs,
  storeLightSwitch,
  storePrefersDarkScheme,
  tableA11y,
  tableInteraction,
  tableMapperValues,
  tableSourceMapper,
  tableSourceValues,
  toastStore,
  tooltip
};
//# sourceMappingURL=@skeletonlabs_skeleton.js.map
