import "./chunk-GECN4ROB.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  add_resize_listener,
  append_hydration_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  claim_space,
  createEventDispatcher,
  create_slot,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  init,
  insert_hydration_dev,
  listen_dev,
  onMount,
  run_all,
  safe_not_equal,
  space,
  src_url_equal,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots
} from "./chunk-3LMUIDXO.js";

// node_modules/.pnpm/svelte-image-gallery@1.7.0/node_modules/svelte-image-gallery/Gallery.svelte
var file = "node_modules\\.pnpm\\svelte-image-gallery@1.7.0\\node_modules\\svelte-image-gallery\\Gallery.svelte";
function add_css(target) {
  append_styles(target, "svelte-1aiohow", "#slotHolder.svelte-1aiohow.svelte-1aiohow{display:none}#gallery.svelte-1aiohow.svelte-1aiohow{width:100%;display:grid;gap:var(--gap)}#gallery.svelte-1aiohow .column.svelte-1aiohow{display:flex;flex-direction:column}#gallery.svelte-1aiohow .column .svelte-1aiohow{width:100%;margin-top:var(--gap)}#gallery.svelte-1aiohow .column .svelte-1aiohow:nth-child(1){margin-top:0}.img-hover.svelte-1aiohow.svelte-1aiohow{opacity:0.9;transition:all 0.2s}.img-hover.svelte-1aiohow.svelte-1aiohow:hover{opacity:1;transform:scale(1.05)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FsbGVyeS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNkVJLFdBQUEsOEJBQUEsQ0FBQSxBQUNJLE9BQUEsQ0FBQSxJQUFhLEFBQ2pCLENBQUEsQUFDQSxRQUFBLDhCQUFBLENBQUEsQUFDSSxLQUFBLENBQUEsSUFBVyxDQUNYLE9BQUEsQ0FBQSxJQUFhLENBQ2IsR0FBQSxDQUFBLElBQUEsS0FBQSxDQUFlLEFBQ25CLENBQUEsQUFDQSx1QkFBQSxDQUFBLE9BQUEsZUFBQSxDQUFBLEFBQ0ksT0FBQSxDQUFBLElBQWEsQ0FDYixjQUFBLENBQUEsTUFBc0IsQUFDMUIsQ0FBQSxBQUNBLHVCQUFBLENBQUEsT0FBQSxDQUFBLGVBQUEsQ0FBQSxBQUNJLEtBQUEsQ0FBQSxJQUFXLENBQ1gsVUFBQSxDQUFBLElBQUEsS0FBQSxDQUFzQixBQUMxQixDQUFBLEFBQ0EsdUJBQUEsQ0FBQSxPQUFBLENBQUEsZUFBQSxXQUFBLENBQUEsQ0FBQSxBQUFBLENBQUEsQUFDSSxVQUFBLENBQUEsQ0FBYSxBQUNqQixDQUFBLEFBQ0EsVUFBQSw4QkFBQSxDQUFBLEFBQ0ksT0FBQSxDQUFBLEdBQVksQ0FDWixVQUFBLENBQUEsR0FBQSxDQUFBLElBQW9CLEFBQ3hCLENBQUEsQUFDQSx3Q0FBQSxNQUFBLEFBQUEsQ0FBQSxBQUNJLE9BQUEsQ0FBQSxDQUFVLENBQ1YsU0FBQSxDQUFBLE1BQUEsSUFBQSxDQUFzQixBQUMxQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkdhbGxlcnkuc3ZlbHRlIl19 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let div;
  let div_resize_listener;
  let each_value = ctx[4];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, style: true, class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "id", "gallery");
      attr_dev(div, "style", ctx[5]);
      attr_dev(div, "class", "svelte-1aiohow");
      add_render_callback(() => ctx[14].call(div));
      add_location(div, file, 59, 4, 1543);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      div_resize_listener = add_resize_listener(div, ctx[14].bind(div));
    },
    p: function update(ctx2, dirty) {
      if (dirty & 83) {
        each_value = ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 32) {
        attr_dev(div, "style", ctx2[5]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(59:0) {#if columns}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  let img_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", {
        src: true,
        alt: true,
        class: true,
        loading: true
      });
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = ctx[19].src))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", img_alt_value = ctx[19].alt);
      attr_dev(img, "class", img_class_value = (ctx[0] === true ? "img-hover" : "") + " " + ctx[19].class + " svelte-1aiohow");
      attr_dev(img, "loading", ctx[1]);
      add_location(img, file, 63, 20, 1744);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      if (!mounted) {
        dispose = listen_dev(img, "click", ctx[6], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16 && !src_url_equal(img.src, img_src_value = ctx2[19].src)) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty & 16 && img_alt_value !== (img_alt_value = ctx2[19].alt)) {
        attr_dev(img, "alt", img_alt_value);
      }
      if (dirty & 17 && img_class_value !== (img_class_value = (ctx2[0] === true ? "img-hover" : "") + " " + ctx2[19].class + " svelte-1aiohow")) {
        attr_dev(img, "class", img_class_value);
      }
      if (dirty & 2) {
        attr_dev(img, "loading", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(63:16) {#each column as img}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let div;
  let t;
  let each_value_1 = ctx[16];
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "column svelte-1aiohow");
      add_location(div, file, 61, 12, 1663);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 83) {
        each_value_1 = ctx2[16];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(61:8) {#each columns as column}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let if_block = ctx[4] && create_if_block(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "id", "slotHolder");
      attr_dev(div, "class", "svelte-1aiohow");
      add_location(div, file, 49, 0, 1381);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[13](div);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "DOMNodeInserted", ctx[7], false, false, false),
          listen_dev(div, "DOMNodeRemoved", ctx[7], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[13](null);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let galleryStyle;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Gallery", slots, ["default"]);
  let { gap = 10 } = $$props;
  let { maxColumnWidth = 250 } = $$props;
  let { hover = false } = $$props;
  let { loading } = $$props;
  const dispatch = createEventDispatcher();
  let slotHolder = null;
  let columns = [];
  let galleryWidth = 0;
  let columnCount = 0;
  onMount(Draw);
  function HandleClick(e) {
    dispatch("click", {
      src: e.target.src,
      alt: e.target.alt,
      loading: e.target.loading,
      class: e.target.className
    });
  }
  async function Draw() {
    await tick();
    if (!slotHolder) {
      return;
    }
    const images = Array.from(slotHolder.childNodes).filter((child) => child.tagName === "IMG");
    $$invalidate(4, columns = []);
    for (let i = 0; i < images.length; i++) {
      const idx = i % columnCount;
      $$invalidate(
        4,
        columns[idx] = [
          ...columns[idx] || [],
          {
            src: images[i].src,
            alt: images[i].alt,
            class: images[i].className
          }
        ],
        columns
      );
    }
  }
  $$self.$$.on_mount.push(function() {
    if (loading === void 0 && !("loading" in $$props || $$self.$$.bound[$$self.$$.props["loading"]])) {
      console.warn("<Gallery> was created without expected prop 'loading'");
    }
  });
  const writable_props = ["gap", "maxColumnWidth", "hover", "loading"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Gallery> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      slotHolder = $$value;
      $$invalidate(3, slotHolder);
    });
  }
  function div_elementresize_handler() {
    galleryWidth = this.clientWidth;
    $$invalidate(2, galleryWidth);
  }
  $$self.$$set = ($$props2) => {
    if ("gap" in $$props2)
      $$invalidate(8, gap = $$props2.gap);
    if ("maxColumnWidth" in $$props2)
      $$invalidate(9, maxColumnWidth = $$props2.maxColumnWidth);
    if ("hover" in $$props2)
      $$invalidate(0, hover = $$props2.hover);
    if ("loading" in $$props2)
      $$invalidate(1, loading = $$props2.loading);
    if ("$$scope" in $$props2)
      $$invalidate(11, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    createEventDispatcher,
    tick,
    gap,
    maxColumnWidth,
    hover,
    loading,
    dispatch,
    slotHolder,
    columns,
    galleryWidth,
    columnCount,
    HandleClick,
    Draw,
    galleryStyle
  });
  $$self.$inject_state = ($$props2) => {
    if ("gap" in $$props2)
      $$invalidate(8, gap = $$props2.gap);
    if ("maxColumnWidth" in $$props2)
      $$invalidate(9, maxColumnWidth = $$props2.maxColumnWidth);
    if ("hover" in $$props2)
      $$invalidate(0, hover = $$props2.hover);
    if ("loading" in $$props2)
      $$invalidate(1, loading = $$props2.loading);
    if ("slotHolder" in $$props2)
      $$invalidate(3, slotHolder = $$props2.slotHolder);
    if ("columns" in $$props2)
      $$invalidate(4, columns = $$props2.columns);
    if ("galleryWidth" in $$props2)
      $$invalidate(2, galleryWidth = $$props2.galleryWidth);
    if ("columnCount" in $$props2)
      $$invalidate(10, columnCount = $$props2.columnCount);
    if ("galleryStyle" in $$props2)
      $$invalidate(5, galleryStyle = $$props2.galleryStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 516) {
      $:
        $$invalidate(10, columnCount = parseInt(galleryWidth / maxColumnWidth) || 1);
    }
    if ($$self.$$.dirty & 1024) {
      $:
        columnCount && Draw();
    }
    if ($$self.$$.dirty & 1280) {
      $:
        $$invalidate(5, galleryStyle = `grid-template-columns: repeat(${columnCount}, 1fr); --gap: ${gap}px`);
    }
  };
  return [
    hover,
    loading,
    galleryWidth,
    slotHolder,
    columns,
    galleryStyle,
    HandleClick,
    Draw,
    gap,
    maxColumnWidth,
    columnCount,
    $$scope,
    slots,
    div_binding,
    div_elementresize_handler
  ];
}
var Gallery = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        gap: 8,
        maxColumnWidth: 9,
        hover: 0,
        loading: 1
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Gallery",
      options,
      id: create_fragment.name
    });
  }
  get gap() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxColumnWidth() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxColumnWidth(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Gallery_default = Gallery;

// node_modules/.pnpm/svelte-image-gallery@1.7.0/node_modules/svelte-image-gallery/index.mjs
var svelte_image_gallery_default = Gallery_default;
export {
  svelte_image_gallery_default as default
};
//# sourceMappingURL=svelte-image-gallery.js.map
